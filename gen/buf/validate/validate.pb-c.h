/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: buf/validate/validate.proto */

#ifndef PROTOBUF_C_buf_2fvalidate_2fvalidate_2eproto__INCLUDED
#define PROTOBUF_C_buf_2fvalidate_2fvalidate_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protobuf-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1005002 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protobuf-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protobuf-c.
#endif

#include "google/protobuf/descriptor.pb-c.h"
#include "google/protobuf/duration.pb-c.h"
#include "google/protobuf/timestamp.pb-c.h"

typedef struct Buf__Validate__Rule Buf__Validate__Rule;
typedef struct Buf__Validate__MessageRules Buf__Validate__MessageRules;
typedef struct Buf__Validate__MessageOneofRule Buf__Validate__MessageOneofRule;
typedef struct Buf__Validate__OneofRules Buf__Validate__OneofRules;
typedef struct Buf__Validate__FieldRules Buf__Validate__FieldRules;
typedef struct Buf__Validate__PredefinedRules Buf__Validate__PredefinedRules;
typedef struct Buf__Validate__FloatRules Buf__Validate__FloatRules;
typedef struct Buf__Validate__DoubleRules Buf__Validate__DoubleRules;
typedef struct Buf__Validate__Int32Rules Buf__Validate__Int32Rules;
typedef struct Buf__Validate__Int64Rules Buf__Validate__Int64Rules;
typedef struct Buf__Validate__UInt32Rules Buf__Validate__UInt32Rules;
typedef struct Buf__Validate__UInt64Rules Buf__Validate__UInt64Rules;
typedef struct Buf__Validate__SInt32Rules Buf__Validate__SInt32Rules;
typedef struct Buf__Validate__SInt64Rules Buf__Validate__SInt64Rules;
typedef struct Buf__Validate__Fixed32Rules Buf__Validate__Fixed32Rules;
typedef struct Buf__Validate__Fixed64Rules Buf__Validate__Fixed64Rules;
typedef struct Buf__Validate__SFixed32Rules Buf__Validate__SFixed32Rules;
typedef struct Buf__Validate__SFixed64Rules Buf__Validate__SFixed64Rules;
typedef struct Buf__Validate__BoolRules Buf__Validate__BoolRules;
typedef struct Buf__Validate__StringRules Buf__Validate__StringRules;
typedef struct Buf__Validate__BytesRules Buf__Validate__BytesRules;
typedef struct Buf__Validate__EnumRules Buf__Validate__EnumRules;
typedef struct Buf__Validate__RepeatedRules Buf__Validate__RepeatedRules;
typedef struct Buf__Validate__MapRules Buf__Validate__MapRules;
typedef struct Buf__Validate__AnyRules Buf__Validate__AnyRules;
typedef struct Buf__Validate__DurationRules Buf__Validate__DurationRules;
typedef struct Buf__Validate__TimestampRules Buf__Validate__TimestampRules;
typedef struct Buf__Validate__Violations Buf__Validate__Violations;
typedef struct Buf__Validate__Violation Buf__Validate__Violation;
typedef struct Buf__Validate__FieldPath Buf__Validate__FieldPath;
typedef struct Buf__Validate__FieldPathElement Buf__Validate__FieldPathElement;


/* --- enums --- */

/*
 * Specifies how `FieldRules.ignore` behaves, depending on the field's value, and
 * whether the field tracks presence.
 */
typedef enum _Buf__Validate__Ignore {
  /*
   * Ignore rules if the field tracks presence and is unset. This is the default
   * behavior.
   * In proto3, only message fields, members of a Protobuf `oneof`, and fields
   * with the `optional` label track presence. Consequently, the following fields
   * are always validated, whether a value is set or not:
   * ```proto
   * syntax="proto3";
   * message RulesApply {
   *   string email = 1 [
   *     (buf.validate.field).string.email = true
   *   ];
   *   int32 age = 2 [
   *     (buf.validate.field).int32.gt = 0
   *   ];
   *   repeated string labels = 3 [
   *     (buf.validate.field).repeated.min_items = 1
   *   ];
   * }
   * ```
   * In contrast, the following fields track presence, and are only validated if
   * a value is set:
   * ```proto
   * syntax="proto3";
   * message RulesApplyIfSet {
   *   optional string email = 1 [
   *     (buf.validate.field).string.email = true
   *   ];
   *   oneof ref {
   *     string reference = 2 [
   *       (buf.validate.field).string.uuid = true
   *     ];
   *     string name = 3 [
   *       (buf.validate.field).string.min_len = 4
   *     ];
   *   }
   *   SomeMessage msg = 4 [
   *     (buf.validate.field).cel = { * ... * }
   *   ];
   * }
   * ```
   * To ensure that such a field is set, add the `required` rule.
   * To learn which fields track presence, see the
   * [Field Presence cheat sheet](https://protobuf.dev/programming-guides/field_presence/#cheat).
   */
  BUF__VALIDATE__IGNORE__IGNORE_UNSPECIFIED = 0,
  /*
   * Ignore rules if the field is unset, also for fields that don't track
   * presence.
   * In proto3, repeated fields, map fields, and fields with scalar types don't
   * track presence. Consequently, the following fields are only validated if
   * they are set:
   * ```proto
   * syntax="proto3";
   * message RulesApplyIfSet {
   *   // `string.email` is ignored for the empty string.
   *   string link = 1 [
   *     (buf.validate.field).string.email = true,
   *     (buf.validate.field).ignore = IGNORE_IF_UNPOPULATED
   *   ];
   *   // `int32.gte` is ignored for the zero value.
   *   int32 age = 2 [
   *     (buf.validate.field).int32.gte = 21,
   *     (buf.validate.field).ignore = IGNORE_IF_UNPOPULATED
   *   ];
   *   // `repeated.min_items` is ignored if the list is empty.
   *   repeated string labels = 3 [
   *     (buf.validate.field).repeated.min_items = 3,
   *     (buf.validate.field).ignore = IGNORE_IF_UNPOPULATED
   *   ];
   * }
   * ```
   * For fields that don't track presence, the field's value determines
   * whether the field is set and rules apply:
   * - For string and bytes, an empty value is ignored.
   * - For bool, false is ignored.
   * - For numeric types, zero is ignored.
   * - For enums, the first defined enum value is ignored.
   * - For repeated fields, an empty list is ignored.
   * - For map fields, an empty map is ignored.
   * - For message fields, absence of the message (typically a null-value) is
   *   ignored.
   * For fields that track presence (e.g. adding the `optional` label in proto3),
   * behavior is the same as the default `IGNORE_UNSPECIFIED`.
   * To learn which fields track presence, see the
   * [Field Presence cheat sheet](https://protobuf.dev/programming-guides/field_presence/#cheat).
   */
  BUF__VALIDATE__IGNORE__IGNORE_IF_UNPOPULATED = 1,
  /*
   * Ignore rules if the field is unset, or set to the default value.
   * The default value depends on the field type:
   * - For strings, the default value is the empty string.
   * - For bytes, the default value is empty bytes.
   * - For bool, the default value is false.
   * - For numeric types, the default value is zero.
   * - For enums, the default value is the first defined enum value.
   * - For repeated fields, the default is an empty list.
   * - For map fields, the default is an empty map.
   * - For message fields, Protovalidate treats the empty message as the
   *   default value. All rules of the referenced message are ignored as well.
   * For some fields, the default value can be overridden with the Protobuf
   * `default` option.
   * For fields that don't track presence and don't have the `default` option,
   * behavior is the same as the default `IGNORE_UNSPECIFIED`.
   */
  BUF__VALIDATE__IGNORE__IGNORE_IF_DEFAULT_VALUE = 2,
  /*
   * Always ignore rules, including the `required` rule.
   * This is useful for ignoring the rules of a referenced message, or to
   * temporarily ignore rules during development.
   * ```proto
   * message MyMessage {
   *   // The field's rules will always be ignored, including any validations
   *   // on value's fields.
   *   MyOtherMessage value = 1 [
   *     (buf.validate.field).ignore = IGNORE_ALWAYS];
   * }
   * ```
   */
  BUF__VALIDATE__IGNORE__IGNORE_ALWAYS = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__IGNORE)
} Buf__Validate__Ignore;
/*
 * KnownRegex contains some well-known patterns.
 */
typedef enum _Buf__Validate__KnownRegex {
  BUF__VALIDATE__KNOWN_REGEX__KNOWN_REGEX_UNSPECIFIED = 0,
  /*
   * HTTP header name as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2).
   */
  BUF__VALIDATE__KNOWN_REGEX__KNOWN_REGEX_HTTP_HEADER_NAME = 1,
  /*
   * HTTP header value as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4).
   */
  BUF__VALIDATE__KNOWN_REGEX__KNOWN_REGEX_HTTP_HEADER_VALUE = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__KNOWN_REGEX)
} Buf__Validate__KnownRegex;

/* --- messages --- */

/*
 * `Rule` represents a validation rule written in the Common Expression
 * Language (CEL) syntax. Each Rule includes a unique identifier, an
 * optional error message, and the CEL expression to evaluate. For more
 * information, [see our documentation](https://buf.build/docs/protovalidate/schemas/custom-rules/).
 * ```proto
 * message Foo {
 *   option (buf.validate.message).cel = {
 *     id: "foo.bar"
 *     message: "bar must be greater than 0"
 *     expression: "this.bar > 0"
 *   };
 *   int32 bar = 1;
 * }
 * ```
 */
struct  Buf__Validate__Rule
{
  ProtobufCMessage base;
  /*
   * `id` is a string that serves as a machine-readable name for this Rule.
   * It should be unique within its scope, which could be either a message or a field.
   */
  char *id;
  /*
   * `message` is an optional field that provides a human-readable error message
   * for this Rule when the CEL expression evaluates to false. If a
   * non-empty message is provided, any strings resulting from the CEL
   * expression evaluation are ignored.
   */
  char *message;
  /*
   * `expression` is the actual CEL expression that will be evaluated for
   * validation. This string must resolve to either a boolean or a string
   * value. If the expression evaluates to false or a non-empty string, the
   * validation is considered failed, and the message is rejected.
   */
  char *expression;
};
#define BUF__VALIDATE__RULE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__rule__descriptor) \
, NULL, NULL, NULL }


/*
 * MessageRules represents validation rules that are applied to the entire message.
 * It includes disabling options and a list of Rule messages representing Common Expression Language (CEL) validation rules.
 */
struct  Buf__Validate__MessageRules
{
  ProtobufCMessage base;
  /*
   * `disabled` is a boolean flag that, when set to true, nullifies any validation rules for this message.
   * This includes any fields within the message that would otherwise support validation.
   * ```proto
   * message MyMessage {
   *   // validation will be bypassed for this message
   *   option (buf.validate.message).disabled = true;
   * }
   * ```
   */
  protobuf_c_boolean has_disabled;
  protobuf_c_boolean disabled;
  /*
   * `cel` is a repeated field of type Rule. Each Rule specifies a validation rule to be applied to this message.
   * These rules are written in Common Expression Language (CEL) syntax. For more information,
   * [see our documentation](https://buf.build/docs/protovalidate/schemas/custom-rules/).
   * ```proto
   * message MyMessage {
   *   // The field `foo` must be greater than 42.
   *   option (buf.validate.message).cel = {
   *     id: "my_message.value",
   *     message: "value must be greater than 42",
   *     expression: "this.foo > 42",
   *   };
   *   optional int32 foo = 1;
   * }
   * ```
   */
  size_t n_cel;
  Buf__Validate__Rule **cel;
  /*
   * `oneof` is a repeated field of type MessageOneofRule that specifies a list of fields
   * of which at most one can be present. If `required` is also specified, then exactly one
   * of the specified fields _must_ be present.
   * This will enforce oneof-like constraints with a few features not provided by
   * actual Protobuf oneof declarations:
   *   1. Repeated and map fields are allowed in this validation. In a Protobuf oneof,
   *      only scalar fields are allowed.
   *   2. Fields with implicit presence are allowed. In a Protobuf oneof, all member
   *      fields have explicit presence. This means that, for the purpose of determining
   *      how many fields are set, explicitly setting such a field to its zero value is
   *      effectively the same as not setting it at all.
   *   3. This will always generate validation errors for a message unmarshalled from
   *      serialized data that sets more than one field. With a Protobuf oneof, when
   *      multiple fields are present in the serialized form, earlier values are usually
   *      silently ignored when unmarshalling, with only the last field being set when
   *      unmarshalling completes.
   * Note that adding a field to a `oneof` will also set the IGNORE_IF_UNPOPULATED on the fields. This means
   * only the field that is set will be validated and the unset fields are not validated according to the field rules.
   * This behavior can be overridden by setting `ignore` against a field.
   * ```proto
   * message MyMessage {
   *   // Only one of `field1` or `field2` _can_ be present in this message.
   *   option (buf.validate.message).oneof = { fields: ["field1", "field2"] };
   *   // Exactly one of `field3` or `field4` _must_ be present in this message.
   *   option (buf.validate.message).oneof = { fields: ["field3", "field4"], required: true };
   *   string field1 = 1;
   *   bytes field2 = 2;
   *   bool field3 = 3;
   *   int32 field4 = 4;
   * }
   * ```
   */
  size_t n_oneof;
  Buf__Validate__MessageOneofRule **oneof;
};
#define BUF__VALIDATE__MESSAGE_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__message_rules__descriptor) \
, 0, 0, 0,NULL, 0,NULL }


struct  Buf__Validate__MessageOneofRule
{
  ProtobufCMessage base;
  /*
   * A list of field names to include in the oneof. All field names must be
   * defined in the message. At least one field must be specified, and
   * duplicates are not permitted.
   */
  size_t n_fields;
  char **fields;
  /*
   * If true, one of the fields specified _must_ be set.
   */
  protobuf_c_boolean has_required;
  protobuf_c_boolean required;
};
#define BUF__VALIDATE__MESSAGE_ONEOF_RULE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__message_oneof_rule__descriptor) \
, 0,NULL, 0, 0 }


/*
 * The `OneofRules` message type enables you to manage rules for
 * oneof fields in your protobuf messages.
 */
struct  Buf__Validate__OneofRules
{
  ProtobufCMessage base;
  /*
   * If `required` is true, exactly one field of the oneof must be set. A
   * validation error is returned if no fields in the oneof are set. Further rules
   * should be placed on the fields themselves to ensure they are valid values,
   * such as `min_len` or `gt`.
   * ```proto
   * message MyMessage {
   *   oneof value {
   *     // Either `a` or `b` must be set. If `a` is set, it must also be
   *     // non-empty; whereas if `b` is set, it can still be an empty string.
   *     option (buf.validate.oneof).required = true;
   *     string a = 1 [(buf.validate.field).string.min_len = 1];
   *     string b = 2;
   *   }
   * }
   * ```
   */
  protobuf_c_boolean has_required;
  protobuf_c_boolean required;
};
#define BUF__VALIDATE__ONEOF_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__oneof_rules__descriptor) \
, 0, 0 }


typedef enum {
  BUF__VALIDATE__FIELD_RULES__TYPE__NOT_SET = 0,
  BUF__VALIDATE__FIELD_RULES__TYPE_FLOAT = 1,
  BUF__VALIDATE__FIELD_RULES__TYPE_DOUBLE = 2,
  BUF__VALIDATE__FIELD_RULES__TYPE_INT32 = 3,
  BUF__VALIDATE__FIELD_RULES__TYPE_INT64 = 4,
  BUF__VALIDATE__FIELD_RULES__TYPE_UINT32 = 5,
  BUF__VALIDATE__FIELD_RULES__TYPE_UINT64 = 6,
  BUF__VALIDATE__FIELD_RULES__TYPE_SINT32 = 7,
  BUF__VALIDATE__FIELD_RULES__TYPE_SINT64 = 8,
  BUF__VALIDATE__FIELD_RULES__TYPE_FIXED32 = 9,
  BUF__VALIDATE__FIELD_RULES__TYPE_FIXED64 = 10,
  BUF__VALIDATE__FIELD_RULES__TYPE_SFIXED32 = 11,
  BUF__VALIDATE__FIELD_RULES__TYPE_SFIXED64 = 12,
  BUF__VALIDATE__FIELD_RULES__TYPE_BOOL = 13,
  BUF__VALIDATE__FIELD_RULES__TYPE_STRING = 14,
  BUF__VALIDATE__FIELD_RULES__TYPE_BYTES = 15,
  BUF__VALIDATE__FIELD_RULES__TYPE_ENUM = 16,
  BUF__VALIDATE__FIELD_RULES__TYPE_REPEATED = 18,
  BUF__VALIDATE__FIELD_RULES__TYPE_MAP = 19,
  BUF__VALIDATE__FIELD_RULES__TYPE_ANY = 20,
  BUF__VALIDATE__FIELD_RULES__TYPE_DURATION = 21,
  BUF__VALIDATE__FIELD_RULES__TYPE_TIMESTAMP = 22
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__FIELD_RULES__TYPE__CASE)
} Buf__Validate__FieldRules__TypeCase;

/*
 * FieldRules encapsulates the rules for each type of field. Depending on
 * the field, the correct set should be used to ensure proper validations.
 */
struct  Buf__Validate__FieldRules
{
  ProtobufCMessage base;
  /*
   * `cel` is a repeated field used to represent a textual expression
   * in the Common Expression Language (CEL) syntax. For more information,
   * [see our documentation](https://buf.build/docs/protovalidate/schemas/custom-rules/).
   * ```proto
   * message MyMessage {
   *   // The field `value` must be greater than 42.
   *   optional int32 value = 1 [(buf.validate.field).cel = {
   *     id: "my_message.value",
   *     message: "value must be greater than 42",
   *     expression: "this > 42",
   *   }];
   * }
   * ```
   */
  size_t n_cel;
  Buf__Validate__Rule **cel;
  /*
   * If `required` is true, the field must be set. A validation error is returned
   * if the field is not set.
   * ```proto
   * syntax="proto3";
   * message FieldsWithPresence {
   *   // Requires any string to be set, including the empty string.
   *   optional string link = 1 [
   *     (buf.validate.field).required = true
   *   ];
   *   // Requires true or false to be set.
   *   optional bool disabled = 2 [
   *     (buf.validate.field).required = true
   *   ];
   *   // Requires a message to be set, including the empty message.
   *   SomeMessage msg = 4 [
   *     (buf.validate.field).required = true
   *   ];
   * }
   * ```
   * All fields in the example above track presence. By default, Protovalidate
   * ignores rules on those fields if no value is set. `required` ensures that
   * the fields are set and valid.
   * Fields that don't track presence are always validated by Protovalidate,
   * whether they are set or not. It is not necessary to add `required`:
   * ```proto
   * syntax="proto3";
   * message FieldsWithoutPresence {
   *   // `string.email` always applies, even to an empty string.
   *   string link = 1 [
   *     (buf.validate.field).string.email = true
   *   ];
   *   // `repeated.min_items` always applies, even to an empty list.
   *   repeated string labels = 4 [
   *     (buf.validate.field).repeated.min_items = 1
   *   ];
   * }
   * ```
   * To learn which fields track presence, see the
   * [Field Presence cheat sheet](https://protobuf.dev/programming-guides/field_presence/#cheat).
   * Note: While field rules can be applied to repeated items, map keys, and map
   * values, the elements are always considered to be set. Consequently,
   * specifying `repeated.items.required` is redundant.
   */
  protobuf_c_boolean has_required;
  protobuf_c_boolean required;
  /*
   * Ignore validation rules on the field if its value matches the specified
   * criteria. See the `Ignore` enum for details.
   * ```proto
   * message UpdateRequest {
   *   // The uri rule only applies if the field is populated and not an empty
   *   // string.
   *   optional string url = 1 [
   *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE,
   *     (buf.validate.field).string.uri = true
   *   ];
   * }
   * ```
   */
  protobuf_c_boolean has_ignore;
  Buf__Validate__Ignore ignore;
  Buf__Validate__FieldRules__TypeCase type_case;
  union {
    /*
     * Well-Known Field Types
     */
    Buf__Validate__AnyRules *any;
    Buf__Validate__BoolRules *bool_;
    Buf__Validate__BytesRules *bytes;
    Buf__Validate__DoubleRules *double_;
    Buf__Validate__DurationRules *duration;
    /*
     * Complex Field Types
     */
    Buf__Validate__EnumRules *enum_;
    Buf__Validate__Fixed32Rules *fixed32;
    Buf__Validate__Fixed64Rules *fixed64;
    /*
     * Scalar Field Types
     */
    Buf__Validate__FloatRules *float_;
    Buf__Validate__Int32Rules *int32;
    Buf__Validate__Int64Rules *int64;
    Buf__Validate__MapRules *map;
    Buf__Validate__RepeatedRules *repeated;
    Buf__Validate__SFixed32Rules *sfixed32;
    Buf__Validate__SFixed64Rules *sfixed64;
    Buf__Validate__SInt32Rules *sint32;
    Buf__Validate__SInt64Rules *sint64;
    Buf__Validate__StringRules *string;
    Buf__Validate__TimestampRules *timestamp;
    Buf__Validate__UInt32Rules *uint32;
    Buf__Validate__UInt64Rules *uint64;
  };
};
#define BUF__VALIDATE__FIELD_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__field_rules__descriptor) \
, 0,NULL, 0, 0, 0, BUF__VALIDATE__IGNORE__IGNORE_UNSPECIFIED, BUF__VALIDATE__FIELD_RULES__TYPE__NOT_SET, {0} }


/*
 * PredefinedRules are custom rules that can be re-used with
 * multiple fields.
 */
struct  Buf__Validate__PredefinedRules
{
  ProtobufCMessage base;
  /*
   * `cel` is a repeated field used to represent a textual expression
   * in the Common Expression Language (CEL) syntax. For more information,
   * [see our documentation](https://buf.build/docs/protovalidate/schemas/predefined-rules/).
   * ```proto
   * message MyMessage {
   *   // The field `value` must be greater than 42.
   *   optional int32 value = 1 [(buf.validate.predefined).cel = {
   *     id: "my_message.value",
   *     message: "value must be greater than 42",
   *     expression: "this > 42",
   *   }];
   * }
   * ```
   */
  size_t n_cel;
  Buf__Validate__Rule **cel;
};
#define BUF__VALIDATE__PREDEFINED_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__predefined_rules__descriptor) \
, 0,NULL }


typedef enum {
  BUF__VALIDATE__FLOAT_RULES__LESS_THAN__NOT_SET = 0,
  BUF__VALIDATE__FLOAT_RULES__LESS_THAN_LT = 2,
  BUF__VALIDATE__FLOAT_RULES__LESS_THAN_LTE = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__FLOAT_RULES__LESS_THAN__CASE)
} Buf__Validate__FloatRules__LessThanCase;

typedef enum {
  BUF__VALIDATE__FLOAT_RULES__GREATER_THAN__NOT_SET = 0,
  BUF__VALIDATE__FLOAT_RULES__GREATER_THAN_GT = 4,
  BUF__VALIDATE__FLOAT_RULES__GREATER_THAN_GTE = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__FLOAT_RULES__GREATER_THAN__CASE)
} Buf__Validate__FloatRules__GreaterThanCase;

/*
 * FloatRules describes the rules applied to `float` values. These
 * rules may also be applied to the `google.protobuf.FloatValue` Well-Known-Type.
 */
struct  Buf__Validate__FloatRules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   * ```proto
   * message MyFloat {
   *   // value must equal 42.0
   *   float value = 1 [(buf.validate.field).float.const = 42.0];
   * }
   * ```
   */
  protobuf_c_boolean has_const_;
  float const_;
  /*
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message
   * is generated.
   * ```proto
   * message MyFloat {
   *   // value must be in list [1.0, 2.0, 3.0]
   *   float value = 1 [(buf.validate.field).float = { in: [1.0, 2.0, 3.0] }];
   * }
   * ```
   */
  size_t n_in;
  float *in;
  /*
   * `in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   * ```proto
   * message MyFloat {
   *   // value must not be in list [1.0, 2.0, 3.0]
   *   float value = 1 [(buf.validate.field).float = { not_in: [1.0, 2.0, 3.0] }];
   * }
   * ```
   */
  size_t n_not_in;
  float *not_in;
  /*
   * `finite` requires the field value to be finite. If the field value is
   * infinite or NaN, an error message is generated.
   */
  protobuf_c_boolean has_finite;
  protobuf_c_boolean finite;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MyFloat {
   *   float value = 1 [
   *     (buf.validate.field).float.example = 1.0,
   *     (buf.validate.field).float.example = inf
   *   ];
   * }
   * ```
   */
  size_t n_example;
  float *example;
  Buf__Validate__FloatRules__LessThanCase less_than_case;
  union {
    /*
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     * ```proto
     * message MyFloat {
     *   // value must be less than 10.0
     *   float value = 1 [(buf.validate.field).float.lt = 10.0];
     * }
     * ```
     */
    float lt;
    /*
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     * ```proto
     * message MyFloat {
     *   // value must be less than or equal to 10.0
     *   float value = 1 [(buf.validate.field).float.lte = 10.0];
     * }
     * ```
     */
    float lte;
  };
  Buf__Validate__FloatRules__GreaterThanCase greater_than_case;
  union {
    /*
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyFloat {
     *   // value must be greater than 5.0 [float.gt]
     *   float value = 1 [(buf.validate.field).float.gt = 5.0];
     *   // value must be greater than 5 and less than 10.0 [float.gt_lt]
     *   float other_value = 2 [(buf.validate.field).float = { gt: 5.0, lt: 10.0 }];
     *   // value must be greater than 10 or less than 5.0 [float.gt_lt_exclusive]
     *   float another_value = 3 [(buf.validate.field).float = { gt: 10.0, lt: 5.0 }];
     * }
     * ```
     */
    float gt;
    /*
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyFloat {
     *   // value must be greater than or equal to 5.0 [float.gte]
     *   float value = 1 [(buf.validate.field).float.gte = 5.0];
     *   // value must be greater than or equal to 5.0 and less than 10.0 [float.gte_lt]
     *   float other_value = 2 [(buf.validate.field).float = { gte: 5.0, lt: 10.0 }];
     *   // value must be greater than or equal to 10.0 or less than 5.0 [float.gte_lt_exclusive]
     *   float another_value = 3 [(buf.validate.field).float = { gte: 10.0, lt: 5.0 }];
     * }
     * ```
     */
    float gte;
  };
};
#define BUF__VALIDATE__FLOAT_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__float_rules__descriptor) \
, 0, 0, 0,NULL, 0,NULL, 0, 0, 0,NULL, BUF__VALIDATE__FLOAT_RULES__LESS_THAN__NOT_SET, {0}, BUF__VALIDATE__FLOAT_RULES__GREATER_THAN__NOT_SET, {0} }


typedef enum {
  BUF__VALIDATE__DOUBLE_RULES__LESS_THAN__NOT_SET = 0,
  BUF__VALIDATE__DOUBLE_RULES__LESS_THAN_LT = 2,
  BUF__VALIDATE__DOUBLE_RULES__LESS_THAN_LTE = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__DOUBLE_RULES__LESS_THAN__CASE)
} Buf__Validate__DoubleRules__LessThanCase;

typedef enum {
  BUF__VALIDATE__DOUBLE_RULES__GREATER_THAN__NOT_SET = 0,
  BUF__VALIDATE__DOUBLE_RULES__GREATER_THAN_GT = 4,
  BUF__VALIDATE__DOUBLE_RULES__GREATER_THAN_GTE = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__DOUBLE_RULES__GREATER_THAN__CASE)
} Buf__Validate__DoubleRules__GreaterThanCase;

/*
 * DoubleRules describes the rules applied to `double` values. These
 * rules may also be applied to the `google.protobuf.DoubleValue` Well-Known-Type.
 */
struct  Buf__Validate__DoubleRules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   * ```proto
   * message MyDouble {
   *   // value must equal 42.0
   *   double value = 1 [(buf.validate.field).double.const = 42.0];
   * }
   * ```
   */
  protobuf_c_boolean has_const_;
  double const_;
  /*
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   * ```proto
   * message MyDouble {
   *   // value must be in list [1.0, 2.0, 3.0]
   *   double value = 1 [(buf.validate.field).double = { in: [1.0, 2.0, 3.0] }];
   * }
   * ```
   */
  size_t n_in;
  double *in;
  /*
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   * ```proto
   * message MyDouble {
   *   // value must not be in list [1.0, 2.0, 3.0]
   *   double value = 1 [(buf.validate.field).double = { not_in: [1.0, 2.0, 3.0] }];
   * }
   * ```
   */
  size_t n_not_in;
  double *not_in;
  /*
   * `finite` requires the field value to be finite. If the field value is
   * infinite or NaN, an error message is generated.
   */
  protobuf_c_boolean has_finite;
  protobuf_c_boolean finite;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MyDouble {
   *   double value = 1 [
   *     (buf.validate.field).double.example = 1.0,
   *     (buf.validate.field).double.example = inf
   *   ];
   * }
   * ```
   */
  size_t n_example;
  double *example;
  Buf__Validate__DoubleRules__LessThanCase less_than_case;
  union {
    /*
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified
     * value, an error message is generated.
     * ```proto
     * message MyDouble {
     *   // value must be less than 10.0
     *   double value = 1 [(buf.validate.field).double.lt = 10.0];
     * }
     * ```
     */
    double lt;
    /*
     * `lte` requires the field value to be less than or equal to the specified value
     * (field <= value). If the field value is greater than the specified value,
     * an error message is generated.
     * ```proto
     * message MyDouble {
     *   // value must be less than or equal to 10.0
     *   double value = 1 [(buf.validate.field).double.lte = 10.0];
     * }
     * ```
     */
    double lte;
  };
  Buf__Validate__DoubleRules__GreaterThanCase greater_than_case;
  union {
    /*
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or `lte`,
     * the range is reversed, and the field value must be outside the specified
     * range. If the field value doesn't meet the required conditions, an error
     * message is generated.
     * ```proto
     * message MyDouble {
     *   // value must be greater than 5.0 [double.gt]
     *   double value = 1 [(buf.validate.field).double.gt = 5.0];
     *   // value must be greater than 5 and less than 10.0 [double.gt_lt]
     *   double other_value = 2 [(buf.validate.field).double = { gt: 5.0, lt: 10.0 }];
     *   // value must be greater than 10 or less than 5.0 [double.gt_lt_exclusive]
     *   double another_value = 3 [(buf.validate.field).double = { gt: 10.0, lt: 5.0 }];
     * }
     * ```
     */
    double gt;
    /*
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyDouble {
     *   // value must be greater than or equal to 5.0 [double.gte]
     *   double value = 1 [(buf.validate.field).double.gte = 5.0];
     *   // value must be greater than or equal to 5.0 and less than 10.0 [double.gte_lt]
     *   double other_value = 2 [(buf.validate.field).double = { gte: 5.0, lt: 10.0 }];
     *   // value must be greater than or equal to 10.0 or less than 5.0 [double.gte_lt_exclusive]
     *   double another_value = 3 [(buf.validate.field).double = { gte: 10.0, lt: 5.0 }];
     * }
     * ```
     */
    double gte;
  };
};
#define BUF__VALIDATE__DOUBLE_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__double_rules__descriptor) \
, 0, 0, 0,NULL, 0,NULL, 0, 0, 0,NULL, BUF__VALIDATE__DOUBLE_RULES__LESS_THAN__NOT_SET, {0}, BUF__VALIDATE__DOUBLE_RULES__GREATER_THAN__NOT_SET, {0} }


typedef enum {
  BUF__VALIDATE__INT32_RULES__LESS_THAN__NOT_SET = 0,
  BUF__VALIDATE__INT32_RULES__LESS_THAN_LT = 2,
  BUF__VALIDATE__INT32_RULES__LESS_THAN_LTE = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__INT32_RULES__LESS_THAN__CASE)
} Buf__Validate__Int32Rules__LessThanCase;

typedef enum {
  BUF__VALIDATE__INT32_RULES__GREATER_THAN__NOT_SET = 0,
  BUF__VALIDATE__INT32_RULES__GREATER_THAN_GT = 4,
  BUF__VALIDATE__INT32_RULES__GREATER_THAN_GTE = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__INT32_RULES__GREATER_THAN__CASE)
} Buf__Validate__Int32Rules__GreaterThanCase;

/*
 * Int32Rules describes the rules applied to `int32` values. These
 * rules may also be applied to the `google.protobuf.Int32Value` Well-Known-Type.
 */
struct  Buf__Validate__Int32Rules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   * ```proto
   * message MyInt32 {
   *   // value must equal 42
   *   int32 value = 1 [(buf.validate.field).int32.const = 42];
   * }
   * ```
   */
  protobuf_c_boolean has_const_;
  int32_t const_;
  /*
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   * ```proto
   * message MyInt32 {
   *   // value must be in list [1, 2, 3]
   *   int32 value = 1 [(buf.validate.field).int32 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_in;
  int32_t *in;
  /*
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error message
   * is generated.
   * ```proto
   * message MyInt32 {
   *   // value must not be in list [1, 2, 3]
   *   int32 value = 1 [(buf.validate.field).int32 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_not_in;
  int32_t *not_in;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MyInt32 {
   *   int32 value = 1 [
   *     (buf.validate.field).int32.example = 1,
   *     (buf.validate.field).int32.example = -10
   *   ];
   * }
   * ```
   */
  size_t n_example;
  int32_t *example;
  Buf__Validate__Int32Rules__LessThanCase less_than_case;
  union {
    /*
     * `lt` requires the field value to be less than the specified value (field
     * < value). If the field value is equal to or greater than the specified
     * value, an error message is generated.
     * ```proto
     * message MyInt32 {
     *   // value must be less than 10
     *   int32 value = 1 [(buf.validate.field).int32.lt = 10];
     * }
     * ```
     */
    int32_t lt;
    /*
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     * ```proto
     * message MyInt32 {
     *   // value must be less than or equal to 10
     *   int32 value = 1 [(buf.validate.field).int32.lte = 10];
     * }
     * ```
     */
    int32_t lte;
  };
  Buf__Validate__Int32Rules__GreaterThanCase greater_than_case;
  union {
    /*
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyInt32 {
     *   // value must be greater than 5 [int32.gt]
     *   int32 value = 1 [(buf.validate.field).int32.gt = 5];
     *   // value must be greater than 5 and less than 10 [int32.gt_lt]
     *   int32 other_value = 2 [(buf.validate.field).int32 = { gt: 5, lt: 10 }];
     *   // value must be greater than 10 or less than 5 [int32.gt_lt_exclusive]
     *   int32 another_value = 3 [(buf.validate.field).int32 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    int32_t gt;
    /*
     * `gte` requires the field value to be greater than or equal to the specified value
     * (exclusive). If the value of `gte` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyInt32 {
     *   // value must be greater than or equal to 5 [int32.gte]
     *   int32 value = 1 [(buf.validate.field).int32.gte = 5];
     *   // value must be greater than or equal to 5 and less than 10 [int32.gte_lt]
     *   int32 other_value = 2 [(buf.validate.field).int32 = { gte: 5, lt: 10 }];
     *   // value must be greater than or equal to 10 or less than 5 [int32.gte_lt_exclusive]
     *   int32 another_value = 3 [(buf.validate.field).int32 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    int32_t gte;
  };
};
#define BUF__VALIDATE__INT32_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__int32_rules__descriptor) \
, 0, 0, 0,NULL, 0,NULL, 0,NULL, BUF__VALIDATE__INT32_RULES__LESS_THAN__NOT_SET, {0}, BUF__VALIDATE__INT32_RULES__GREATER_THAN__NOT_SET, {0} }


typedef enum {
  BUF__VALIDATE__INT64_RULES__LESS_THAN__NOT_SET = 0,
  BUF__VALIDATE__INT64_RULES__LESS_THAN_LT = 2,
  BUF__VALIDATE__INT64_RULES__LESS_THAN_LTE = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__INT64_RULES__LESS_THAN__CASE)
} Buf__Validate__Int64Rules__LessThanCase;

typedef enum {
  BUF__VALIDATE__INT64_RULES__GREATER_THAN__NOT_SET = 0,
  BUF__VALIDATE__INT64_RULES__GREATER_THAN_GT = 4,
  BUF__VALIDATE__INT64_RULES__GREATER_THAN_GTE = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__INT64_RULES__GREATER_THAN__CASE)
} Buf__Validate__Int64Rules__GreaterThanCase;

/*
 * Int64Rules describes the rules applied to `int64` values. These
 * rules may also be applied to the `google.protobuf.Int64Value` Well-Known-Type.
 */
struct  Buf__Validate__Int64Rules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   * ```proto
   * message MyInt64 {
   *   // value must equal 42
   *   int64 value = 1 [(buf.validate.field).int64.const = 42];
   * }
   * ```
   */
  protobuf_c_boolean has_const_;
  int64_t const_;
  /*
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   * ```proto
   * message MyInt64 {
   *   // value must be in list [1, 2, 3]
   *   int64 value = 1 [(buf.validate.field).int64 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_in;
  int64_t *in;
  /*
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   * ```proto
   * message MyInt64 {
   *   // value must not be in list [1, 2, 3]
   *   int64 value = 1 [(buf.validate.field).int64 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_not_in;
  int64_t *not_in;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MyInt64 {
   *   int64 value = 1 [
   *     (buf.validate.field).int64.example = 1,
   *     (buf.validate.field).int64.example = -10
   *   ];
   * }
   * ```
   */
  size_t n_example;
  int64_t *example;
  Buf__Validate__Int64Rules__LessThanCase less_than_case;
  union {
    /*
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     * ```proto
     * message MyInt64 {
     *   // value must be less than 10
     *   int64 value = 1 [(buf.validate.field).int64.lt = 10];
     * }
     * ```
     */
    int64_t lt;
    /*
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     * ```proto
     * message MyInt64 {
     *   // value must be less than or equal to 10
     *   int64 value = 1 [(buf.validate.field).int64.lte = 10];
     * }
     * ```
     */
    int64_t lte;
  };
  Buf__Validate__Int64Rules__GreaterThanCase greater_than_case;
  union {
    /*
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyInt64 {
     *   // value must be greater than 5 [int64.gt]
     *   int64 value = 1 [(buf.validate.field).int64.gt = 5];
     *   // value must be greater than 5 and less than 10 [int64.gt_lt]
     *   int64 other_value = 2 [(buf.validate.field).int64 = { gt: 5, lt: 10 }];
     *   // value must be greater than 10 or less than 5 [int64.gt_lt_exclusive]
     *   int64 another_value = 3 [(buf.validate.field).int64 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    int64_t gt;
    /*
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyInt64 {
     *   // value must be greater than or equal to 5 [int64.gte]
     *   int64 value = 1 [(buf.validate.field).int64.gte = 5];
     *   // value must be greater than or equal to 5 and less than 10 [int64.gte_lt]
     *   int64 other_value = 2 [(buf.validate.field).int64 = { gte: 5, lt: 10 }];
     *   // value must be greater than or equal to 10 or less than 5 [int64.gte_lt_exclusive]
     *   int64 another_value = 3 [(buf.validate.field).int64 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    int64_t gte;
  };
};
#define BUF__VALIDATE__INT64_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__int64_rules__descriptor) \
, 0, 0, 0,NULL, 0,NULL, 0,NULL, BUF__VALIDATE__INT64_RULES__LESS_THAN__NOT_SET, {0}, BUF__VALIDATE__INT64_RULES__GREATER_THAN__NOT_SET, {0} }


typedef enum {
  BUF__VALIDATE__UINT32_RULES__LESS_THAN__NOT_SET = 0,
  BUF__VALIDATE__UINT32_RULES__LESS_THAN_LT = 2,
  BUF__VALIDATE__UINT32_RULES__LESS_THAN_LTE = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__UINT32_RULES__LESS_THAN__CASE)
} Buf__Validate__UInt32Rules__LessThanCase;

typedef enum {
  BUF__VALIDATE__UINT32_RULES__GREATER_THAN__NOT_SET = 0,
  BUF__VALIDATE__UINT32_RULES__GREATER_THAN_GT = 4,
  BUF__VALIDATE__UINT32_RULES__GREATER_THAN_GTE = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__UINT32_RULES__GREATER_THAN__CASE)
} Buf__Validate__UInt32Rules__GreaterThanCase;

/*
 * UInt32Rules describes the rules applied to `uint32` values. These
 * rules may also be applied to the `google.protobuf.UInt32Value` Well-Known-Type.
 */
struct  Buf__Validate__UInt32Rules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   * ```proto
   * message MyUInt32 {
   *   // value must equal 42
   *   uint32 value = 1 [(buf.validate.field).uint32.const = 42];
   * }
   * ```
   */
  protobuf_c_boolean has_const_;
  uint32_t const_;
  /*
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   * ```proto
   * message MyUInt32 {
   *   // value must be in list [1, 2, 3]
   *   uint32 value = 1 [(buf.validate.field).uint32 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_in;
  uint32_t *in;
  /*
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   * ```proto
   * message MyUInt32 {
   *   // value must not be in list [1, 2, 3]
   *   uint32 value = 1 [(buf.validate.field).uint32 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_not_in;
  uint32_t *not_in;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MyUInt32 {
   *   uint32 value = 1 [
   *     (buf.validate.field).uint32.example = 1,
   *     (buf.validate.field).uint32.example = 10
   *   ];
   * }
   * ```
   */
  size_t n_example;
  uint32_t *example;
  Buf__Validate__UInt32Rules__LessThanCase less_than_case;
  union {
    /*
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     * ```proto
     * message MyUInt32 {
     *   // value must be less than 10
     *   uint32 value = 1 [(buf.validate.field).uint32.lt = 10];
     * }
     * ```
     */
    uint32_t lt;
    /*
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     * ```proto
     * message MyUInt32 {
     *   // value must be less than or equal to 10
     *   uint32 value = 1 [(buf.validate.field).uint32.lte = 10];
     * }
     * ```
     */
    uint32_t lte;
  };
  Buf__Validate__UInt32Rules__GreaterThanCase greater_than_case;
  union {
    /*
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyUInt32 {
     *   // value must be greater than 5 [uint32.gt]
     *   uint32 value = 1 [(buf.validate.field).uint32.gt = 5];
     *   // value must be greater than 5 and less than 10 [uint32.gt_lt]
     *   uint32 other_value = 2 [(buf.validate.field).uint32 = { gt: 5, lt: 10 }];
     *   // value must be greater than 10 or less than 5 [uint32.gt_lt_exclusive]
     *   uint32 another_value = 3 [(buf.validate.field).uint32 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    uint32_t gt;
    /*
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyUInt32 {
     *   // value must be greater than or equal to 5 [uint32.gte]
     *   uint32 value = 1 [(buf.validate.field).uint32.gte = 5];
     *   // value must be greater than or equal to 5 and less than 10 [uint32.gte_lt]
     *   uint32 other_value = 2 [(buf.validate.field).uint32 = { gte: 5, lt: 10 }];
     *   // value must be greater than or equal to 10 or less than 5 [uint32.gte_lt_exclusive]
     *   uint32 another_value = 3 [(buf.validate.field).uint32 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    uint32_t gte;
  };
};
#define BUF__VALIDATE__UINT32_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__uint32_rules__descriptor) \
, 0, 0, 0,NULL, 0,NULL, 0,NULL, BUF__VALIDATE__UINT32_RULES__LESS_THAN__NOT_SET, {0}, BUF__VALIDATE__UINT32_RULES__GREATER_THAN__NOT_SET, {0} }


typedef enum {
  BUF__VALIDATE__UINT64_RULES__LESS_THAN__NOT_SET = 0,
  BUF__VALIDATE__UINT64_RULES__LESS_THAN_LT = 2,
  BUF__VALIDATE__UINT64_RULES__LESS_THAN_LTE = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__UINT64_RULES__LESS_THAN__CASE)
} Buf__Validate__UInt64Rules__LessThanCase;

typedef enum {
  BUF__VALIDATE__UINT64_RULES__GREATER_THAN__NOT_SET = 0,
  BUF__VALIDATE__UINT64_RULES__GREATER_THAN_GT = 4,
  BUF__VALIDATE__UINT64_RULES__GREATER_THAN_GTE = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__UINT64_RULES__GREATER_THAN__CASE)
} Buf__Validate__UInt64Rules__GreaterThanCase;

/*
 * UInt64Rules describes the rules applied to `uint64` values. These
 * rules may also be applied to the `google.protobuf.UInt64Value` Well-Known-Type.
 */
struct  Buf__Validate__UInt64Rules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   * ```proto
   * message MyUInt64 {
   *   // value must equal 42
   *   uint64 value = 1 [(buf.validate.field).uint64.const = 42];
   * }
   * ```
   */
  protobuf_c_boolean has_const_;
  uint64_t const_;
  /*
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   * ```proto
   * message MyUInt64 {
   *   // value must be in list [1, 2, 3]
   *   uint64 value = 1 [(buf.validate.field).uint64 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_in;
  uint64_t *in;
  /*
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   * ```proto
   * message MyUInt64 {
   *   // value must not be in list [1, 2, 3]
   *   uint64 value = 1 [(buf.validate.field).uint64 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_not_in;
  uint64_t *not_in;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MyUInt64 {
   *   uint64 value = 1 [
   *     (buf.validate.field).uint64.example = 1,
   *     (buf.validate.field).uint64.example = -10
   *   ];
   * }
   * ```
   */
  size_t n_example;
  uint64_t *example;
  Buf__Validate__UInt64Rules__LessThanCase less_than_case;
  union {
    /*
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     * ```proto
     * message MyUInt64 {
     *   // value must be less than 10
     *   uint64 value = 1 [(buf.validate.field).uint64.lt = 10];
     * }
     * ```
     */
    uint64_t lt;
    /*
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     * ```proto
     * message MyUInt64 {
     *   // value must be less than or equal to 10
     *   uint64 value = 1 [(buf.validate.field).uint64.lte = 10];
     * }
     * ```
     */
    uint64_t lte;
  };
  Buf__Validate__UInt64Rules__GreaterThanCase greater_than_case;
  union {
    /*
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyUInt64 {
     *   // value must be greater than 5 [uint64.gt]
     *   uint64 value = 1 [(buf.validate.field).uint64.gt = 5];
     *   // value must be greater than 5 and less than 10 [uint64.gt_lt]
     *   uint64 other_value = 2 [(buf.validate.field).uint64 = { gt: 5, lt: 10 }];
     *   // value must be greater than 10 or less than 5 [uint64.gt_lt_exclusive]
     *   uint64 another_value = 3 [(buf.validate.field).uint64 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    uint64_t gt;
    /*
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyUInt64 {
     *   // value must be greater than or equal to 5 [uint64.gte]
     *   uint64 value = 1 [(buf.validate.field).uint64.gte = 5];
     *   // value must be greater than or equal to 5 and less than 10 [uint64.gte_lt]
     *   uint64 other_value = 2 [(buf.validate.field).uint64 = { gte: 5, lt: 10 }];
     *   // value must be greater than or equal to 10 or less than 5 [uint64.gte_lt_exclusive]
     *   uint64 another_value = 3 [(buf.validate.field).uint64 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    uint64_t gte;
  };
};
#define BUF__VALIDATE__UINT64_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__uint64_rules__descriptor) \
, 0, 0, 0,NULL, 0,NULL, 0,NULL, BUF__VALIDATE__UINT64_RULES__LESS_THAN__NOT_SET, {0}, BUF__VALIDATE__UINT64_RULES__GREATER_THAN__NOT_SET, {0} }


typedef enum {
  BUF__VALIDATE__SINT32_RULES__LESS_THAN__NOT_SET = 0,
  BUF__VALIDATE__SINT32_RULES__LESS_THAN_LT = 2,
  BUF__VALIDATE__SINT32_RULES__LESS_THAN_LTE = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__SINT32_RULES__LESS_THAN__CASE)
} Buf__Validate__SInt32Rules__LessThanCase;

typedef enum {
  BUF__VALIDATE__SINT32_RULES__GREATER_THAN__NOT_SET = 0,
  BUF__VALIDATE__SINT32_RULES__GREATER_THAN_GT = 4,
  BUF__VALIDATE__SINT32_RULES__GREATER_THAN_GTE = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__SINT32_RULES__GREATER_THAN__CASE)
} Buf__Validate__SInt32Rules__GreaterThanCase;

/*
 * SInt32Rules describes the rules applied to `sint32` values.
 */
struct  Buf__Validate__SInt32Rules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   * ```proto
   * message MySInt32 {
   *   // value must equal 42
   *   sint32 value = 1 [(buf.validate.field).sint32.const = 42];
   * }
   * ```
   */
  protobuf_c_boolean has_const_;
  int32_t const_;
  /*
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   * ```proto
   * message MySInt32 {
   *   // value must be in list [1, 2, 3]
   *   sint32 value = 1 [(buf.validate.field).sint32 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_in;
  int32_t *in;
  /*
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   * ```proto
   * message MySInt32 {
   *   // value must not be in list [1, 2, 3]
   *   sint32 value = 1 [(buf.validate.field).sint32 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_not_in;
  int32_t *not_in;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MySInt32 {
   *   sint32 value = 1 [
   *     (buf.validate.field).sint32.example = 1,
   *     (buf.validate.field).sint32.example = -10
   *   ];
   * }
   * ```
   */
  size_t n_example;
  int32_t *example;
  Buf__Validate__SInt32Rules__LessThanCase less_than_case;
  union {
    /*
     * `lt` requires the field value to be less than the specified value (field
     * < value). If the field value is equal to or greater than the specified
     * value, an error message is generated.
     * ```proto
     * message MySInt32 {
     *   // value must be less than 10
     *   sint32 value = 1 [(buf.validate.field).sint32.lt = 10];
     * }
     * ```
     */
    int32_t lt;
    /*
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     * ```proto
     * message MySInt32 {
     *   // value must be less than or equal to 10
     *   sint32 value = 1 [(buf.validate.field).sint32.lte = 10];
     * }
     * ```
     */
    int32_t lte;
  };
  Buf__Validate__SInt32Rules__GreaterThanCase greater_than_case;
  union {
    /*
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MySInt32 {
     *   // value must be greater than 5 [sint32.gt]
     *   sint32 value = 1 [(buf.validate.field).sint32.gt = 5];
     *   // value must be greater than 5 and less than 10 [sint32.gt_lt]
     *   sint32 other_value = 2 [(buf.validate.field).sint32 = { gt: 5, lt: 10 }];
     *   // value must be greater than 10 or less than 5 [sint32.gt_lt_exclusive]
     *   sint32 another_value = 3 [(buf.validate.field).sint32 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    int32_t gt;
    /*
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MySInt32 {
     *  // value must be greater than or equal to 5 [sint32.gte]
     *  sint32 value = 1 [(buf.validate.field).sint32.gte = 5];
     *  // value must be greater than or equal to 5 and less than 10 [sint32.gte_lt]
     *  sint32 other_value = 2 [(buf.validate.field).sint32 = { gte: 5, lt: 10 }];
     *  // value must be greater than or equal to 10 or less than 5 [sint32.gte_lt_exclusive]
     *  sint32 another_value = 3 [(buf.validate.field).sint32 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    int32_t gte;
  };
};
#define BUF__VALIDATE__SINT32_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__sint32_rules__descriptor) \
, 0, 0, 0,NULL, 0,NULL, 0,NULL, BUF__VALIDATE__SINT32_RULES__LESS_THAN__NOT_SET, {0}, BUF__VALIDATE__SINT32_RULES__GREATER_THAN__NOT_SET, {0} }


typedef enum {
  BUF__VALIDATE__SINT64_RULES__LESS_THAN__NOT_SET = 0,
  BUF__VALIDATE__SINT64_RULES__LESS_THAN_LT = 2,
  BUF__VALIDATE__SINT64_RULES__LESS_THAN_LTE = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__SINT64_RULES__LESS_THAN__CASE)
} Buf__Validate__SInt64Rules__LessThanCase;

typedef enum {
  BUF__VALIDATE__SINT64_RULES__GREATER_THAN__NOT_SET = 0,
  BUF__VALIDATE__SINT64_RULES__GREATER_THAN_GT = 4,
  BUF__VALIDATE__SINT64_RULES__GREATER_THAN_GTE = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__SINT64_RULES__GREATER_THAN__CASE)
} Buf__Validate__SInt64Rules__GreaterThanCase;

/*
 * SInt64Rules describes the rules applied to `sint64` values.
 */
struct  Buf__Validate__SInt64Rules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   * ```proto
   * message MySInt64 {
   *   // value must equal 42
   *   sint64 value = 1 [(buf.validate.field).sint64.const = 42];
   * }
   * ```
   */
  protobuf_c_boolean has_const_;
  int64_t const_;
  /*
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message
   * is generated.
   * ```proto
   * message MySInt64 {
   *   // value must be in list [1, 2, 3]
   *   sint64 value = 1 [(buf.validate.field).sint64 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_in;
  int64_t *in;
  /*
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   * ```proto
   * message MySInt64 {
   *   // value must not be in list [1, 2, 3]
   *   sint64 value = 1 [(buf.validate.field).sint64 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_not_in;
  int64_t *not_in;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MySInt64 {
   *   sint64 value = 1 [
   *     (buf.validate.field).sint64.example = 1,
   *     (buf.validate.field).sint64.example = -10
   *   ];
   * }
   * ```
   */
  size_t n_example;
  int64_t *example;
  Buf__Validate__SInt64Rules__LessThanCase less_than_case;
  union {
    /*
     * `lt` requires the field value to be less than the specified value (field
     * < value). If the field value is equal to or greater than the specified
     * value, an error message is generated.
     * ```proto
     * message MySInt64 {
     *   // value must be less than 10
     *   sint64 value = 1 [(buf.validate.field).sint64.lt = 10];
     * }
     * ```
     */
    int64_t lt;
    /*
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     * ```proto
     * message MySInt64 {
     *   // value must be less than or equal to 10
     *   sint64 value = 1 [(buf.validate.field).sint64.lte = 10];
     * }
     * ```
     */
    int64_t lte;
  };
  Buf__Validate__SInt64Rules__GreaterThanCase greater_than_case;
  union {
    /*
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MySInt64 {
     *   // value must be greater than 5 [sint64.gt]
     *   sint64 value = 1 [(buf.validate.field).sint64.gt = 5];
     *   // value must be greater than 5 and less than 10 [sint64.gt_lt]
     *   sint64 other_value = 2 [(buf.validate.field).sint64 = { gt: 5, lt: 10 }];
     *   // value must be greater than 10 or less than 5 [sint64.gt_lt_exclusive]
     *   sint64 another_value = 3 [(buf.validate.field).sint64 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    int64_t gt;
    /*
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MySInt64 {
     *   // value must be greater than or equal to 5 [sint64.gte]
     *   sint64 value = 1 [(buf.validate.field).sint64.gte = 5];
     *   // value must be greater than or equal to 5 and less than 10 [sint64.gte_lt]
     *   sint64 other_value = 2 [(buf.validate.field).sint64 = { gte: 5, lt: 10 }];
     *   // value must be greater than or equal to 10 or less than 5 [sint64.gte_lt_exclusive]
     *   sint64 another_value = 3 [(buf.validate.field).sint64 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    int64_t gte;
  };
};
#define BUF__VALIDATE__SINT64_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__sint64_rules__descriptor) \
, 0, 0, 0,NULL, 0,NULL, 0,NULL, BUF__VALIDATE__SINT64_RULES__LESS_THAN__NOT_SET, {0}, BUF__VALIDATE__SINT64_RULES__GREATER_THAN__NOT_SET, {0} }


typedef enum {
  BUF__VALIDATE__FIXED32_RULES__LESS_THAN__NOT_SET = 0,
  BUF__VALIDATE__FIXED32_RULES__LESS_THAN_LT = 2,
  BUF__VALIDATE__FIXED32_RULES__LESS_THAN_LTE = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__FIXED32_RULES__LESS_THAN__CASE)
} Buf__Validate__Fixed32Rules__LessThanCase;

typedef enum {
  BUF__VALIDATE__FIXED32_RULES__GREATER_THAN__NOT_SET = 0,
  BUF__VALIDATE__FIXED32_RULES__GREATER_THAN_GT = 4,
  BUF__VALIDATE__FIXED32_RULES__GREATER_THAN_GTE = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__FIXED32_RULES__GREATER_THAN__CASE)
} Buf__Validate__Fixed32Rules__GreaterThanCase;

/*
 * Fixed32Rules describes the rules applied to `fixed32` values.
 */
struct  Buf__Validate__Fixed32Rules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified value.
   * If the field value doesn't match, an error message is generated.
   * ```proto
   * message MyFixed32 {
   *   // value must equal 42
   *   fixed32 value = 1 [(buf.validate.field).fixed32.const = 42];
   * }
   * ```
   */
  protobuf_c_boolean has_const_;
  uint32_t const_;
  /*
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message
   * is generated.
   * ```proto
   * message MyFixed32 {
   *   // value must be in list [1, 2, 3]
   *   fixed32 value = 1 [(buf.validate.field).fixed32 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_in;
  uint32_t *in;
  /*
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   * ```proto
   * message MyFixed32 {
   *   // value must not be in list [1, 2, 3]
   *   fixed32 value = 1 [(buf.validate.field).fixed32 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_not_in;
  uint32_t *not_in;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MyFixed32 {
   *   fixed32 value = 1 [
   *     (buf.validate.field).fixed32.example = 1,
   *     (buf.validate.field).fixed32.example = 2
   *   ];
   * }
   * ```
   */
  size_t n_example;
  uint32_t *example;
  Buf__Validate__Fixed32Rules__LessThanCase less_than_case;
  union {
    /*
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     * ```proto
     * message MyFixed32 {
     *   // value must be less than 10
     *   fixed32 value = 1 [(buf.validate.field).fixed32.lt = 10];
     * }
     * ```
     */
    uint32_t lt;
    /*
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     * ```proto
     * message MyFixed32 {
     *   // value must be less than or equal to 10
     *   fixed32 value = 1 [(buf.validate.field).fixed32.lte = 10];
     * }
     * ```
     */
    uint32_t lte;
  };
  Buf__Validate__Fixed32Rules__GreaterThanCase greater_than_case;
  union {
    /*
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyFixed32 {
     *   // value must be greater than 5 [fixed32.gt]
     *   fixed32 value = 1 [(buf.validate.field).fixed32.gt = 5];
     *   // value must be greater than 5 and less than 10 [fixed32.gt_lt]
     *   fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gt: 5, lt: 10 }];
     *   // value must be greater than 10 or less than 5 [fixed32.gt_lt_exclusive]
     *   fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    uint32_t gt;
    /*
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyFixed32 {
     *   // value must be greater than or equal to 5 [fixed32.gte]
     *   fixed32 value = 1 [(buf.validate.field).fixed32.gte = 5];
     *   // value must be greater than or equal to 5 and less than 10 [fixed32.gte_lt]
     *   fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gte: 5, lt: 10 }];
     *   // value must be greater than or equal to 10 or less than 5 [fixed32.gte_lt_exclusive]
     *   fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    uint32_t gte;
  };
};
#define BUF__VALIDATE__FIXED32_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__fixed32_rules__descriptor) \
, 0, 0, 0,NULL, 0,NULL, 0,NULL, BUF__VALIDATE__FIXED32_RULES__LESS_THAN__NOT_SET, {0}, BUF__VALIDATE__FIXED32_RULES__GREATER_THAN__NOT_SET, {0} }


typedef enum {
  BUF__VALIDATE__FIXED64_RULES__LESS_THAN__NOT_SET = 0,
  BUF__VALIDATE__FIXED64_RULES__LESS_THAN_LT = 2,
  BUF__VALIDATE__FIXED64_RULES__LESS_THAN_LTE = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__FIXED64_RULES__LESS_THAN__CASE)
} Buf__Validate__Fixed64Rules__LessThanCase;

typedef enum {
  BUF__VALIDATE__FIXED64_RULES__GREATER_THAN__NOT_SET = 0,
  BUF__VALIDATE__FIXED64_RULES__GREATER_THAN_GT = 4,
  BUF__VALIDATE__FIXED64_RULES__GREATER_THAN_GTE = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__FIXED64_RULES__GREATER_THAN__CASE)
} Buf__Validate__Fixed64Rules__GreaterThanCase;

/*
 * Fixed64Rules describes the rules applied to `fixed64` values.
 */
struct  Buf__Validate__Fixed64Rules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   * ```proto
   * message MyFixed64 {
   *   // value must equal 42
   *   fixed64 value = 1 [(buf.validate.field).fixed64.const = 42];
   * }
   * ```
   */
  protobuf_c_boolean has_const_;
  uint64_t const_;
  /*
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   * ```proto
   * message MyFixed64 {
   *   // value must be in list [1, 2, 3]
   *   fixed64 value = 1 [(buf.validate.field).fixed64 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_in;
  uint64_t *in;
  /*
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   * ```proto
   * message MyFixed64 {
   *   // value must not be in list [1, 2, 3]
   *   fixed64 value = 1 [(buf.validate.field).fixed64 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_not_in;
  uint64_t *not_in;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MyFixed64 {
   *   fixed64 value = 1 [
   *     (buf.validate.field).fixed64.example = 1,
   *     (buf.validate.field).fixed64.example = 2
   *   ];
   * }
   * ```
   */
  size_t n_example;
  uint64_t *example;
  Buf__Validate__Fixed64Rules__LessThanCase less_than_case;
  union {
    /*
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     * ```proto
     * message MyFixed64 {
     *   // value must be less than 10
     *   fixed64 value = 1 [(buf.validate.field).fixed64.lt = 10];
     * }
     * ```
     */
    uint64_t lt;
    /*
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     * ```proto
     * message MyFixed64 {
     *   // value must be less than or equal to 10
     *   fixed64 value = 1 [(buf.validate.field).fixed64.lte = 10];
     * }
     * ```
     */
    uint64_t lte;
  };
  Buf__Validate__Fixed64Rules__GreaterThanCase greater_than_case;
  union {
    /*
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyFixed64 {
     *   // value must be greater than 5 [fixed64.gt]
     *   fixed64 value = 1 [(buf.validate.field).fixed64.gt = 5];
     *   // value must be greater than 5 and less than 10 [fixed64.gt_lt]
     *   fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gt: 5, lt: 10 }];
     *   // value must be greater than 10 or less than 5 [fixed64.gt_lt_exclusive]
     *   fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    uint64_t gt;
    /*
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyFixed64 {
     *   // value must be greater than or equal to 5 [fixed64.gte]
     *   fixed64 value = 1 [(buf.validate.field).fixed64.gte = 5];
     *   // value must be greater than or equal to 5 and less than 10 [fixed64.gte_lt]
     *   fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gte: 5, lt: 10 }];
     *   // value must be greater than or equal to 10 or less than 5 [fixed64.gte_lt_exclusive]
     *   fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    uint64_t gte;
  };
};
#define BUF__VALIDATE__FIXED64_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__fixed64_rules__descriptor) \
, 0, 0, 0,NULL, 0,NULL, 0,NULL, BUF__VALIDATE__FIXED64_RULES__LESS_THAN__NOT_SET, {0}, BUF__VALIDATE__FIXED64_RULES__GREATER_THAN__NOT_SET, {0} }


typedef enum {
  BUF__VALIDATE__SFIXED32_RULES__LESS_THAN__NOT_SET = 0,
  BUF__VALIDATE__SFIXED32_RULES__LESS_THAN_LT = 2,
  BUF__VALIDATE__SFIXED32_RULES__LESS_THAN_LTE = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__SFIXED32_RULES__LESS_THAN__CASE)
} Buf__Validate__SFixed32Rules__LessThanCase;

typedef enum {
  BUF__VALIDATE__SFIXED32_RULES__GREATER_THAN__NOT_SET = 0,
  BUF__VALIDATE__SFIXED32_RULES__GREATER_THAN_GT = 4,
  BUF__VALIDATE__SFIXED32_RULES__GREATER_THAN_GTE = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__SFIXED32_RULES__GREATER_THAN__CASE)
} Buf__Validate__SFixed32Rules__GreaterThanCase;

/*
 * SFixed32Rules describes the rules applied to `fixed32` values.
 */
struct  Buf__Validate__SFixed32Rules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   * ```proto
   * message MySFixed32 {
   *   // value must equal 42
   *   sfixed32 value = 1 [(buf.validate.field).sfixed32.const = 42];
   * }
   * ```
   */
  protobuf_c_boolean has_const_;
  int32_t const_;
  /*
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   * ```proto
   * message MySFixed32 {
   *   // value must be in list [1, 2, 3]
   *   sfixed32 value = 1 [(buf.validate.field).sfixed32 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_in;
  int32_t *in;
  /*
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   * ```proto
   * message MySFixed32 {
   *   // value must not be in list [1, 2, 3]
   *   sfixed32 value = 1 [(buf.validate.field).sfixed32 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_not_in;
  int32_t *not_in;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MySFixed32 {
   *   sfixed32 value = 1 [
   *     (buf.validate.field).sfixed32.example = 1,
   *     (buf.validate.field).sfixed32.example = 2
   *   ];
   * }
   * ```
   */
  size_t n_example;
  int32_t *example;
  Buf__Validate__SFixed32Rules__LessThanCase less_than_case;
  union {
    /*
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     * ```proto
     * message MySFixed32 {
     *   // value must be less than 10
     *   sfixed32 value = 1 [(buf.validate.field).sfixed32.lt = 10];
     * }
     * ```
     */
    int32_t lt;
    /*
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     * ```proto
     * message MySFixed32 {
     *   // value must be less than or equal to 10
     *   sfixed32 value = 1 [(buf.validate.field).sfixed32.lte = 10];
     * }
     * ```
     */
    int32_t lte;
  };
  Buf__Validate__SFixed32Rules__GreaterThanCase greater_than_case;
  union {
    /*
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MySFixed32 {
     *   // value must be greater than 5 [sfixed32.gt]
     *   sfixed32 value = 1 [(buf.validate.field).sfixed32.gt = 5];
     *   // value must be greater than 5 and less than 10 [sfixed32.gt_lt]
     *   sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gt: 5, lt: 10 }];
     *   // value must be greater than 10 or less than 5 [sfixed32.gt_lt_exclusive]
     *   sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    int32_t gt;
    /*
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MySFixed32 {
     *   // value must be greater than or equal to 5 [sfixed32.gte]
     *   sfixed32 value = 1 [(buf.validate.field).sfixed32.gte = 5];
     *   // value must be greater than or equal to 5 and less than 10 [sfixed32.gte_lt]
     *   sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gte: 5, lt: 10 }];
     *   // value must be greater than or equal to 10 or less than 5 [sfixed32.gte_lt_exclusive]
     *   sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    int32_t gte;
  };
};
#define BUF__VALIDATE__SFIXED32_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__sfixed32_rules__descriptor) \
, 0, 0, 0,NULL, 0,NULL, 0,NULL, BUF__VALIDATE__SFIXED32_RULES__LESS_THAN__NOT_SET, {0}, BUF__VALIDATE__SFIXED32_RULES__GREATER_THAN__NOT_SET, {0} }


typedef enum {
  BUF__VALIDATE__SFIXED64_RULES__LESS_THAN__NOT_SET = 0,
  BUF__VALIDATE__SFIXED64_RULES__LESS_THAN_LT = 2,
  BUF__VALIDATE__SFIXED64_RULES__LESS_THAN_LTE = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__SFIXED64_RULES__LESS_THAN__CASE)
} Buf__Validate__SFixed64Rules__LessThanCase;

typedef enum {
  BUF__VALIDATE__SFIXED64_RULES__GREATER_THAN__NOT_SET = 0,
  BUF__VALIDATE__SFIXED64_RULES__GREATER_THAN_GT = 4,
  BUF__VALIDATE__SFIXED64_RULES__GREATER_THAN_GTE = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__SFIXED64_RULES__GREATER_THAN__CASE)
} Buf__Validate__SFixed64Rules__GreaterThanCase;

/*
 * SFixed64Rules describes the rules applied to `fixed64` values.
 */
struct  Buf__Validate__SFixed64Rules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   * ```proto
   * message MySFixed64 {
   *   // value must equal 42
   *   sfixed64 value = 1 [(buf.validate.field).sfixed64.const = 42];
   * }
   * ```
   */
  protobuf_c_boolean has_const_;
  int64_t const_;
  /*
   * `in` requires the field value to be equal to one of the specified values.
   * If the field value isn't one of the specified values, an error message is
   * generated.
   * ```proto
   * message MySFixed64 {
   *   // value must be in list [1, 2, 3]
   *   sfixed64 value = 1 [(buf.validate.field).sfixed64 = { in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_in;
  int64_t *in;
  /*
   * `not_in` requires the field value to not be equal to any of the specified
   * values. If the field value is one of the specified values, an error
   * message is generated.
   * ```proto
   * message MySFixed64 {
   *   // value must not be in list [1, 2, 3]
   *   sfixed64 value = 1 [(buf.validate.field).sfixed64 = { not_in: [1, 2, 3] }];
   * }
   * ```
   */
  size_t n_not_in;
  int64_t *not_in;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MySFixed64 {
   *   sfixed64 value = 1 [
   *     (buf.validate.field).sfixed64.example = 1,
   *     (buf.validate.field).sfixed64.example = 2
   *   ];
   * }
   * ```
   */
  size_t n_example;
  int64_t *example;
  Buf__Validate__SFixed64Rules__LessThanCase less_than_case;
  union {
    /*
     * `lt` requires the field value to be less than the specified value (field <
     * value). If the field value is equal to or greater than the specified value,
     * an error message is generated.
     * ```proto
     * message MySFixed64 {
     *   // value must be less than 10
     *   sfixed64 value = 1 [(buf.validate.field).sfixed64.lt = 10];
     * }
     * ```
     */
    int64_t lt;
    /*
     * `lte` requires the field value to be less than or equal to the specified
     * value (field <= value). If the field value is greater than the specified
     * value, an error message is generated.
     * ```proto
     * message MySFixed64 {
     *   // value must be less than or equal to 10
     *   sfixed64 value = 1 [(buf.validate.field).sfixed64.lte = 10];
     * }
     * ```
     */
    int64_t lte;
  };
  Buf__Validate__SFixed64Rules__GreaterThanCase greater_than_case;
  union {
    /*
     * `gt` requires the field value to be greater than the specified value
     * (exclusive). If the value of `gt` is larger than a specified `lt` or
     * `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MySFixed64 {
     *   // value must be greater than 5 [sfixed64.gt]
     *   sfixed64 value = 1 [(buf.validate.field).sfixed64.gt = 5];
     *   // value must be greater than 5 and less than 10 [sfixed64.gt_lt]
     *   sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gt: 5, lt: 10 }];
     *   // value must be greater than 10 or less than 5 [sfixed64.gt_lt_exclusive]
     *   sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gt: 10, lt: 5 }];
     * }
     * ```
     */
    int64_t gt;
    /*
     * `gte` requires the field value to be greater than or equal to the specified
     * value (exclusive). If the value of `gte` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MySFixed64 {
     *   // value must be greater than or equal to 5 [sfixed64.gte]
     *   sfixed64 value = 1 [(buf.validate.field).sfixed64.gte = 5];
     *   // value must be greater than or equal to 5 and less than 10 [sfixed64.gte_lt]
     *   sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gte: 5, lt: 10 }];
     *   // value must be greater than or equal to 10 or less than 5 [sfixed64.gte_lt_exclusive]
     *   sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gte: 10, lt: 5 }];
     * }
     * ```
     */
    int64_t gte;
  };
};
#define BUF__VALIDATE__SFIXED64_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__sfixed64_rules__descriptor) \
, 0, 0, 0,NULL, 0,NULL, 0,NULL, BUF__VALIDATE__SFIXED64_RULES__LESS_THAN__NOT_SET, {0}, BUF__VALIDATE__SFIXED64_RULES__GREATER_THAN__NOT_SET, {0} }


/*
 * BoolRules describes the rules applied to `bool` values. These rules
 * may also be applied to the `google.protobuf.BoolValue` Well-Known-Type.
 */
struct  Buf__Validate__BoolRules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified boolean value.
   * If the field value doesn't match, an error message is generated.
   * ```proto
   * message MyBool {
   *   // value must equal true
   *   bool value = 1 [(buf.validate.field).bool.const = true];
   * }
   * ```
   */
  protobuf_c_boolean has_const_;
  protobuf_c_boolean const_;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MyBool {
   *   bool value = 1 [
   *     (buf.validate.field).bool.example = 1,
   *     (buf.validate.field).bool.example = 2
   *   ];
   * }
   * ```
   */
  size_t n_example;
  protobuf_c_boolean *example;
};
#define BUF__VALIDATE__BOOL_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__bool_rules__descriptor) \
, 0, 0, 0,NULL }


typedef enum {
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN__NOT_SET = 0,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_EMAIL = 12,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_HOSTNAME = 13,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_IP = 14,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_IPV4 = 15,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_IPV6 = 16,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_URI = 17,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_URI_REF = 18,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_ADDRESS = 21,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_UUID = 22,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_TUUID = 33,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_IP_WITH_PREFIXLEN = 26,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_IPV4_WITH_PREFIXLEN = 27,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_IPV6_WITH_PREFIXLEN = 28,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_IP_PREFIX = 29,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_IPV4_PREFIX = 30,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_IPV6_PREFIX = 31,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_HOST_AND_PORT = 32,
  BUF__VALIDATE__STRING_RULES__WELL_KNOWN_WELL_KNOWN_REGEX = 24
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__STRING_RULES__WELL_KNOWN__CASE)
} Buf__Validate__StringRules__WellKnownCase;

/*
 * StringRules describes the rules applied to `string` values These
 * rules may also be applied to the `google.protobuf.StringValue` Well-Known-Type.
 */
struct  Buf__Validate__StringRules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   * ```proto
   * message MyString {
   *   // value must equal `hello`
   *   string value = 1 [(buf.validate.field).string.const = "hello"];
   * }
   * ```
   */
  char *const_;
  /*
   * `len` dictates that the field value must have the specified
   * number of characters (Unicode code points), which may differ from the number
   * of bytes in the string. If the field value does not meet the specified
   * length, an error message will be generated.
   * ```proto
   * message MyString {
   *   // value length must be 5 characters
   *   string value = 1 [(buf.validate.field).string.len = 5];
   * }
   * ```
   */
  protobuf_c_boolean has_len;
  uint64_t len;
  /*
   * `min_len` specifies that the field value must have at least the specified
   * number of characters (Unicode code points), which may differ from the number
   * of bytes in the string. If the field value contains fewer characters, an error
   * message will be generated.
   * ```proto
   * message MyString {
   *   // value length must be at least 3 characters
   *   string value = 1 [(buf.validate.field).string.min_len = 3];
   * }
   * ```
   */
  protobuf_c_boolean has_min_len;
  uint64_t min_len;
  /*
   * `max_len` specifies that the field value must have no more than the specified
   * number of characters (Unicode code points), which may differ from the
   * number of bytes in the string. If the field value contains more characters,
   * an error message will be generated.
   * ```proto
   * message MyString {
   *   // value length must be at most 10 characters
   *   string value = 1 [(buf.validate.field).string.max_len = 10];
   * }
   * ```
   */
  protobuf_c_boolean has_max_len;
  uint64_t max_len;
  /*
   * `len_bytes` dictates that the field value must have the specified number of
   * bytes. If the field value does not match the specified length in bytes,
   * an error message will be generated.
   * ```proto
   * message MyString {
   *   // value length must be 6 bytes
   *   string value = 1 [(buf.validate.field).string.len_bytes = 6];
   * }
   * ```
   */
  protobuf_c_boolean has_len_bytes;
  uint64_t len_bytes;
  /*
   * `min_bytes` specifies that the field value must have at least the specified
   * number of bytes. If the field value contains fewer bytes, an error message
   * will be generated.
   * ```proto
   * message MyString {
   *   // value length must be at least 4 bytes
   *   string value = 1 [(buf.validate.field).string.min_bytes = 4];
   * }
   * ```
   */
  protobuf_c_boolean has_min_bytes;
  uint64_t min_bytes;
  /*
   * `max_bytes` specifies that the field value must have no more than the
   *specified number of bytes. If the field value contains more bytes, an
   * error message will be generated.
   * ```proto
   * message MyString {
   *   // value length must be at most 8 bytes
   *   string value = 1 [(buf.validate.field).string.max_bytes = 8];
   * }
   * ```
   */
  protobuf_c_boolean has_max_bytes;
  uint64_t max_bytes;
  /*
   * `pattern` specifies that the field value must match the specified
   * regular expression (RE2 syntax), with the expression provided without any
   * delimiters. If the field value doesn't match the regular expression, an
   * error message will be generated.
   * ```proto
   * message MyString {
   *   // value does not match regex pattern `^[a-zA-Z]//$`
   *   string value = 1 [(buf.validate.field).string.pattern = "^[a-zA-Z]//$"];
   * }
   * ```
   */
  char *pattern;
  /*
   * `prefix` specifies that the field value must have the
   *specified substring at the beginning of the string. If the field value
   * doesn't start with the specified prefix, an error message will be
   * generated.
   * ```proto
   * message MyString {
   *   // value does not have prefix `pre`
   *   string value = 1 [(buf.validate.field).string.prefix = "pre"];
   * }
   * ```
   */
  char *prefix;
  /*
   * `suffix` specifies that the field value must have the
   *specified substring at the end of the string. If the field value doesn't
   * end with the specified suffix, an error message will be generated.
   * ```proto
   * message MyString {
   *   // value does not have suffix `post`
   *   string value = 1 [(buf.validate.field).string.suffix = "post"];
   * }
   * ```
   */
  char *suffix;
  /*
   * `contains` specifies that the field value must have the
   *specified substring anywhere in the string. If the field value doesn't
   * contain the specified substring, an error message will be generated.
   * ```proto
   * message MyString {
   *   // value does not contain substring `inside`.
   *   string value = 1 [(buf.validate.field).string.contains = "inside"];
   * }
   * ```
   */
  char *contains;
  /*
   * `not_contains` specifies that the field value must not have the
   *specified substring anywhere in the string. If the field value contains
   * the specified substring, an error message will be generated.
   * ```proto
   * message MyString {
   *   // value contains substring `inside`.
   *   string value = 1 [(buf.validate.field).string.not_contains = "inside"];
   * }
   * ```
   */
  char *not_contains;
  /*
   * `in` specifies that the field value must be equal to one of the specified
   * values. If the field value isn't one of the specified values, an error
   * message will be generated.
   * ```proto
   * message MyString {
   *   // value must be in list ["apple", "banana"]
   *   string value = 1 [(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"];
   * }
   * ```
   */
  size_t n_in;
  char **in;
  /*
   * `not_in` specifies that the field value cannot be equal to any
   * of the specified values. If the field value is one of the specified values,
   * an error message will be generated.
   * ```proto
   * message MyString {
   *   // value must not be in list ["orange", "grape"]
   *   string value = 1 [(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"];
   * }
   * ```
   */
  size_t n_not_in;
  char **not_in;
  /*
   * This applies to regexes `HTTP_HEADER_NAME` and `HTTP_HEADER_VALUE` to
   * enable strict header validation. By default, this is true, and HTTP header
   * validations are [RFC-compliant](https://datatracker.ietf.org/doc/html/rfc7230#section-3). Setting to false will enable looser
   * validations that only disallow `\r\n\0` characters, which can be used to
   * bypass header matching rules.
   * ```proto
   * message MyString {
   *   // The field `value` must have be a valid HTTP headers, but not enforced with strict rules.
   *   string value = 1 [(buf.validate.field).string.strict = false];
   * }
   * ```
   */
  protobuf_c_boolean has_strict;
  protobuf_c_boolean strict;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MyString {
   *   string value = 1 [
   *     (buf.validate.field).string.example = "hello",
   *     (buf.validate.field).string.example = "world"
   *   ];
   * }
   * ```
   */
  size_t n_example;
  char **example;
  Buf__Validate__StringRules__WellKnownCase well_known_case;
  union {
    /*
     * `well_known_regex` specifies a common well-known pattern
     * defined as a regex. If the field value doesn't match the well-known
     * regex, an error message will be generated.
     * ```proto
     * message MyString {
     *   // value must be a valid HTTP header value
     *   string value = 1 [(buf.validate.field).string.well_known_regex = KNOWN_REGEX_HTTP_HEADER_VALUE];
     * }
     * ```
     * #### KnownRegex
     * `well_known_regex` contains some well-known patterns.
     * | Name                          | Number | Description                               |
     * |-------------------------------|--------|-------------------------------------------|
     * | KNOWN_REGEX_UNSPECIFIED       | 0      |                                           |
     * | KNOWN_REGEX_HTTP_HEADER_NAME  | 1      | HTTP header name as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2)  |
     * | KNOWN_REGEX_HTTP_HEADER_VALUE | 2      | HTTP header value as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4) |
     */
    Buf__Validate__KnownRegex well_known_regex;
    /*
     * `address` specifies that the field value must be either a valid hostname
     * (for example, "example.com"), or a valid IP (v4 or v6) address (for example,
     * "192.168.0.1", or "::1"). If the field value isn't a valid hostname or IP,
     * an error message will be generated.
     * ```proto
     * message MyString {
     *   // value must be a valid hostname, or ip address
     *   string value = 1 [(buf.validate.field).string.address = true];
     * }
     * ```
     */
    protobuf_c_boolean address;
    /*
     * `email` specifies that the field value must be a valid email address, for
     * example "foo@example.com".
     * Conforms to the definition for a valid email address from the [HTML standard](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address).
     * Note that this standard willfully deviates from [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322),
     * which allows many unexpected forms of email addresses and will easily match
     * a typographical error.
     * If the field value isn't a valid email address, an error message will be generated.
     * ```proto
     * message MyString {
     *   // value must be a valid email address
     *   string value = 1 [(buf.validate.field).string.email = true];
     * }
     * ```
     */
    protobuf_c_boolean email;
    /*
     * `host_and_port` specifies that the field value must be valid host/port
     * pair—for example, "example.com:8080".
     * The host can be one of:
     *- An IPv4 address in dotted decimal format—for example, "192.168.5.21".
     *- An IPv6 address enclosed in square brackets—for example, "[2001:0DB8:ABCD:0012::F1]".
     *- A hostname—for example, "example.com".
     * The port is separated by a colon. It must be non-empty, with a decimal number
     * in the range of 0-65535, inclusive.
     */
    protobuf_c_boolean host_and_port;
    /*
     * `hostname` specifies that the field value must be a valid hostname, for
     * example "foo.example.com".
     * A valid hostname follows the rules below:
     * - The name consists of one or more labels, separated by a dot (".").
     * - Each label can be 1 to 63 alphanumeric characters.
     * - A label can contain hyphens ("-"), but must not start or end with a hyphen.
     * - The right-most label must not be digits only.
     * - The name can have a trailing dot—for example, "foo.example.com.".
     * - The name can be 253 characters at most, excluding the optional trailing dot.
     * If the field value isn't a valid hostname, an error message will be generated.
     * ```proto
     * message MyString {
     *   // value must be a valid hostname
     *   string value = 1 [(buf.validate.field).string.hostname = true];
     * }
     * ```
     */
    protobuf_c_boolean hostname;
    /*
     * `ip` specifies that the field value must be a valid IP (v4 or v6) address.
     * IPv4 addresses are expected in the dotted decimal format—for example, "192.168.5.21".
     * IPv6 addresses are expected in their text representation—for example, "::1",
     * or "2001:0DB8:ABCD:0012::0".
     * Both formats are well-defined in the internet standard [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986).
     * Zone identifiers for IPv6 addresses (for example, "fe80::a%en1") are supported.
     * If the field value isn't a valid IP address, an error message will be
     * generated.
     * ```proto
     * message MyString {
     *   // value must be a valid IP address
     *   string value = 1 [(buf.validate.field).string.ip = true];
     * }
     * ```
     */
    protobuf_c_boolean ip;
    /*
     * `ip_prefix` specifies that the field value must be a valid IP (v4 or v6)
     * prefix—for example, "192.168.0.0/16" or "2001:0DB8:ABCD:0012::0/64".
     * The prefix must have all zeros for the unmasked bits. For example,
     * "2001:0DB8:ABCD:0012::0/64" designates the left-most 64 bits for the
     * prefix, and the remaining 64 bits must be zero.
     * If the field value isn't a valid IP prefix, an error message will be
     * generated.
     * ```proto
     * message MyString {
     *   // value must be a valid IP prefix
     *    string value = 1 [(buf.validate.field).string.ip_prefix = true];
     * }
     * ```
     */
    protobuf_c_boolean ip_prefix;
    /*
     * `ip_with_prefixlen` specifies that the field value must be a valid IP
     * (v4 or v6) address with prefix length—for example, "192.168.5.21/16" or
     * "2001:0DB8:ABCD:0012::F1/64". If the field value isn't a valid IP with
     * prefix length, an error message will be generated.
     * ```proto
     * message MyString {
     *   // value must be a valid IP with prefix length
     *    string value = 1 [(buf.validate.field).string.ip_with_prefixlen = true];
     * }
     * ```
     */
    protobuf_c_boolean ip_with_prefixlen;
    /*
     * `ipv4` specifies that the field value must be a valid IPv4 address—for
     * example "192.168.5.21". If the field value isn't a valid IPv4 address, an
     * error message will be generated.
     * ```proto
     * message MyString {
     *   // value must be a valid IPv4 address
     *   string value = 1 [(buf.validate.field).string.ipv4 = true];
     * }
     * ```
     */
    protobuf_c_boolean ipv4;
    /*
     * `ipv4_prefix` specifies that the field value must be a valid IPv4
     * prefix, for example "192.168.0.0/16".
     * The prefix must have all zeros for the unmasked bits. For example,
     * "192.168.0.0/16" designates the left-most 16 bits for the prefix,
     * and the remaining 16 bits must be zero.
     * If the field value isn't a valid IPv4 prefix, an error message
     * will be generated.
     * ```proto
     * message MyString {
     *   // value must be a valid IPv4 prefix
     *    string value = 1 [(buf.validate.field).string.ipv4_prefix = true];
     * }
     * ```
     */
    protobuf_c_boolean ipv4_prefix;
    /*
     * `ipv4_with_prefixlen` specifies that the field value must be a valid
     * IPv4 address with prefix length—for example, "192.168.5.21/16". If the
     * field value isn't a valid IPv4 address with prefix length, an error
     * message will be generated.
     * ```proto
     * message MyString {
     *   // value must be a valid IPv4 address with prefix length
     *    string value = 1 [(buf.validate.field).string.ipv4_with_prefixlen = true];
     * }
     * ```
     */
    protobuf_c_boolean ipv4_with_prefixlen;
    /*
     * `ipv6` specifies that the field value must be a valid IPv6 address—for
     * example "::1", or "d7a:115c:a1e0:ab12:4843:cd96:626b:430b". If the field
     * value is not a valid IPv6 address, an error message will be generated.
     * ```proto
     * message MyString {
     *   // value must be a valid IPv6 address
     *   string value = 1 [(buf.validate.field).string.ipv6 = true];
     * }
     * ```
     */
    protobuf_c_boolean ipv6;
    /*
     * `ipv6_prefix` specifies that the field value must be a valid IPv6 prefix—for
     * example, "2001:0DB8:ABCD:0012::0/64".
     * The prefix must have all zeros for the unmasked bits. For example,
     * "2001:0DB8:ABCD:0012::0/64" designates the left-most 64 bits for the
     * prefix, and the remaining 64 bits must be zero.
     * If the field value is not a valid IPv6 prefix, an error message will be
     * generated.
     * ```proto
     * message MyString {
     *   // value must be a valid IPv6 prefix
     *    string value = 1 [(buf.validate.field).string.ipv6_prefix = true];
     * }
     * ```
     */
    protobuf_c_boolean ipv6_prefix;
    /*
     * `ipv6_with_prefixlen` specifies that the field value must be a valid
     * IPv6 address with prefix length—for example, "2001:0DB8:ABCD:0012::F1/64".
     * If the field value is not a valid IPv6 address with prefix length,
     * an error message will be generated.
     * ```proto
     * message MyString {
     *   // value must be a valid IPv6 address prefix length
     *    string value = 1 [(buf.validate.field).string.ipv6_with_prefixlen = true];
     * }
     * ```
     */
    protobuf_c_boolean ipv6_with_prefixlen;
    /*
     * `tuuid` (trimmed UUID) specifies that the field value must be a valid UUID as
     * defined by [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2) with all dashes
     * omitted. If the field value isn't a valid UUID without dashes, an error message
     * will be generated.
     * ```proto
     * message MyString {
     *   // value must be a valid trimmed UUID
     *   string value = 1 [(buf.validate.field).string.tuuid = true];
     * }
     * ```
     */
    protobuf_c_boolean tuuid;
    /*
     * `uri` specifies that the field value must be a valid URI, for example
     * "https://example.com/foo/bar?baz=quux#frag".
     * URI is defined in the internet standard [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986).
     * Zone Identifiers in IPv6 address literals are supported ([RFC 6874](https://datatracker.ietf.org/doc/html/rfc6874)).
     * If the field value isn't a valid URI, an error message will be generated.
     * ```proto
     * message MyString {
     *   // value must be a valid URI
     *   string value = 1 [(buf.validate.field).string.uri = true];
     * }
     * ```
     */
    protobuf_c_boolean uri;
    /*
     * `uri_ref` specifies that the field value must be a valid URI Reference—either
     * a URI such as "https://example.com/foo/bar?baz=quux#frag", or a Relative
     * Reference such as "./foo/bar?query".
     * URI, URI Reference, and Relative Reference are defined in the internet
     * standard [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986). Zone
     * Identifiers in IPv6 address literals are supported ([RFC 6874](https://datatracker.ietf.org/doc/html/rfc6874)).
     * If the field value isn't a valid URI Reference, an error message will be
     * generated.
     * ```proto
     * message MyString {
     *   // value must be a valid URI Reference
     *   string value = 1 [(buf.validate.field).string.uri_ref = true];
     * }
     * ```
     */
    protobuf_c_boolean uri_ref;
    /*
     * `uuid` specifies that the field value must be a valid UUID as defined by
     * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2). If the
     * field value isn't a valid UUID, an error message will be generated.
     * ```proto
     * message MyString {
     *   // value must be a valid UUID
     *   string value = 1 [(buf.validate.field).string.uuid = true];
     * }
     * ```
     */
    protobuf_c_boolean uuid;
  };
};
#define BUF__VALIDATE__STRING_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__string_rules__descriptor) \
, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL, 0,NULL, 0,NULL, 0, 0, 0,NULL, BUF__VALIDATE__STRING_RULES__WELL_KNOWN__NOT_SET, {0} }


typedef enum {
  BUF__VALIDATE__BYTES_RULES__WELL_KNOWN__NOT_SET = 0,
  BUF__VALIDATE__BYTES_RULES__WELL_KNOWN_IP = 10,
  BUF__VALIDATE__BYTES_RULES__WELL_KNOWN_IPV4 = 11,
  BUF__VALIDATE__BYTES_RULES__WELL_KNOWN_IPV6 = 12
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__BYTES_RULES__WELL_KNOWN__CASE)
} Buf__Validate__BytesRules__WellKnownCase;

/*
 * BytesRules describe the rules applied to `bytes` values. These rules
 * may also be applied to the `google.protobuf.BytesValue` Well-Known-Type.
 */
struct  Buf__Validate__BytesRules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified bytes
   * value. If the field value doesn't match, an error message is generated.
   * ```proto
   * message MyBytes {
   *   // value must be "\x01\x02\x03\x04"
   *   bytes value = 1 [(buf.validate.field).bytes.const = "\x01\x02\x03\x04"];
   * }
   * ```
   */
  protobuf_c_boolean has_const_;
  ProtobufCBinaryData const_;
  /*
   * `len` requires the field value to have the specified length in bytes.
   * If the field value doesn't match, an error message is generated.
   * ```proto
   * message MyBytes {
   *   // value length must be 4 bytes.
   *   optional bytes value = 1 [(buf.validate.field).bytes.len = 4];
   * }
   * ```
   */
  protobuf_c_boolean has_len;
  uint64_t len;
  /*
   * `min_len` requires the field value to have at least the specified minimum
   * length in bytes.
   * If the field value doesn't meet the requirement, an error message is generated.
   * ```proto
   * message MyBytes {
   *   // value length must be at least 2 bytes.
   *   optional bytes value = 1 [(buf.validate.field).bytes.min_len = 2];
   * }
   * ```
   */
  protobuf_c_boolean has_min_len;
  uint64_t min_len;
  /*
   * `max_len` requires the field value to have at most the specified maximum
   * length in bytes.
   * If the field value exceeds the requirement, an error message is generated.
   * ```proto
   * message MyBytes {
   *   // value must be at most 6 bytes.
   *   optional bytes value = 1 [(buf.validate.field).bytes.max_len = 6];
   * }
   * ```
   */
  protobuf_c_boolean has_max_len;
  uint64_t max_len;
  /*
   * `pattern` requires the field value to match the specified regular
   * expression ([RE2 syntax](https://github.com/google/re2/wiki/Syntax)).
   * The value of the field must be valid UTF-8 or validation will fail with a
   * runtime error.
   * If the field value doesn't match the pattern, an error message is generated.
   * ```proto
   * message MyBytes {
   *   // value must match regex pattern "^[a-zA-Z0-9]+$".
   *   optional bytes value = 1 [(buf.validate.field).bytes.pattern = "^[a-zA-Z0-9]+$"];
   * }
   * ```
   */
  char *pattern;
  /*
   * `prefix` requires the field value to have the specified bytes at the
   * beginning of the string.
   * If the field value doesn't meet the requirement, an error message is generated.
   * ```proto
   * message MyBytes {
   *   // value does not have prefix \x01\x02
   *   optional bytes value = 1 [(buf.validate.field).bytes.prefix = "\x01\x02"];
   * }
   * ```
   */
  protobuf_c_boolean has_prefix;
  ProtobufCBinaryData prefix;
  /*
   * `suffix` requires the field value to have the specified bytes at the end
   * of the string.
   * If the field value doesn't meet the requirement, an error message is generated.
   * ```proto
   * message MyBytes {
   *   // value does not have suffix \x03\x04
   *   optional bytes value = 1 [(buf.validate.field).bytes.suffix = "\x03\x04"];
   * }
   * ```
   */
  protobuf_c_boolean has_suffix;
  ProtobufCBinaryData suffix;
  /*
   * `contains` requires the field value to have the specified bytes anywhere in
   * the string.
   * If the field value doesn't meet the requirement, an error message is generated.
   * ```protobuf
   * message MyBytes {
   *   // value does not contain \x02\x03
   *   optional bytes value = 1 [(buf.validate.field).bytes.contains = "\x02\x03"];
   * }
   * ```
   */
  protobuf_c_boolean has_contains;
  ProtobufCBinaryData contains;
  /*
   * `in` requires the field value to be equal to one of the specified
   * values. If the field value doesn't match any of the specified values, an
   * error message is generated.
   * ```protobuf
   * message MyBytes {
   *   // value must in ["\x01\x02", "\x02\x03", "\x03\x04"]
   *   optional bytes value = 1 [(buf.validate.field).bytes.in = {"\x01\x02", "\x02\x03", "\x03\x04"}];
   * }
   * ```
   */
  size_t n_in;
  ProtobufCBinaryData *in;
  /*
   * `not_in` requires the field value to be not equal to any of the specified
   * values.
   * If the field value matches any of the specified values, an error message is
   * generated.
   * ```proto
   * message MyBytes {
   *   // value must not in ["\x01\x02", "\x02\x03", "\x03\x04"]
   *   optional bytes value = 1 [(buf.validate.field).bytes.not_in = {"\x01\x02", "\x02\x03", "\x03\x04"}];
   * }
   * ```
   */
  size_t n_not_in;
  ProtobufCBinaryData *not_in;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MyBytes {
   *   bytes value = 1 [
   *     (buf.validate.field).bytes.example = "\x01\x02",
   *     (buf.validate.field).bytes.example = "\x02\x03"
   *   ];
   * }
   * ```
   */
  size_t n_example;
  ProtobufCBinaryData *example;
  Buf__Validate__BytesRules__WellKnownCase well_known_case;
  union {
    /*
     * `ip` ensures that the field `value` is a valid IP address (v4 or v6) in byte format.
     * If the field value doesn't meet this rule, an error message is generated.
     * ```proto
     * message MyBytes {
     *   // value must be a valid IP address
     *   optional bytes value = 1 [(buf.validate.field).bytes.ip = true];
     * }
     * ```
     */
    protobuf_c_boolean ip;
    /*
     * `ipv4` ensures that the field `value` is a valid IPv4 address in byte format.
     * If the field value doesn't meet this rule, an error message is generated.
     * ```proto
     * message MyBytes {
     *   // value must be a valid IPv4 address
     *   optional bytes value = 1 [(buf.validate.field).bytes.ipv4 = true];
     * }
     * ```
     */
    protobuf_c_boolean ipv4;
    /*
     * `ipv6` ensures that the field `value` is a valid IPv6 address in byte format.
     * If the field value doesn't meet this rule, an error message is generated.
     * ```proto
     * message MyBytes {
     *   // value must be a valid IPv6 address
     *   optional bytes value = 1 [(buf.validate.field).bytes.ipv6 = true];
     * }
     * ```
     */
    protobuf_c_boolean ipv6;
  };
};
#define BUF__VALIDATE__BYTES_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__bytes_rules__descriptor) \
, 0, {0,NULL}, 0, 0, 0, 0, 0, 0, NULL, 0, {0,NULL}, 0, {0,NULL}, 0, {0,NULL}, 0,NULL, 0,NULL, 0,NULL, BUF__VALIDATE__BYTES_RULES__WELL_KNOWN__NOT_SET, {0} }


/*
 * EnumRules describe the rules applied to `enum` values.
 */
struct  Buf__Validate__EnumRules
{
  ProtobufCMessage base;
  /*
   * `const` requires the field value to exactly match the specified enum value.
   * If the field value doesn't match, an error message is generated.
   * ```proto
   * enum MyEnum {
   *   MY_ENUM_UNSPECIFIED = 0;
   *   MY_ENUM_VALUE1 = 1;
   *   MY_ENUM_VALUE2 = 2;
   * }
   * message MyMessage {
   *   // The field `value` must be exactly MY_ENUM_VALUE1.
   *   MyEnum value = 1 [(buf.validate.field).enum.const = 1];
   * }
   * ```
   */
  protobuf_c_boolean has_const_;
  int32_t const_;
  /*
   * `defined_only` requires the field value to be one of the defined values for
   * this enum, failing on any undefined value.
   * ```proto
   * enum MyEnum {
   *   MY_ENUM_UNSPECIFIED = 0;
   *   MY_ENUM_VALUE1 = 1;
   *   MY_ENUM_VALUE2 = 2;
   * }
   * message MyMessage {
   *   // The field `value` must be a defined value of MyEnum.
   *   MyEnum value = 1 [(buf.validate.field).enum.defined_only = true];
   * }
   * ```
   */
  protobuf_c_boolean has_defined_only;
  protobuf_c_boolean defined_only;
  /*
   * `in` requires the field value to be equal to one of the
   *specified enum values. If the field value doesn't match any of the
   *specified values, an error message is generated.
   * ```proto
   * enum MyEnum {
   *   MY_ENUM_UNSPECIFIED = 0;
   *   MY_ENUM_VALUE1 = 1;
   *   MY_ENUM_VALUE2 = 2;
   * }
   * message MyMessage {
   *   // The field `value` must be equal to one of the specified values.
   *   MyEnum value = 1 [(buf.validate.field).enum = { in: [1, 2]}];
   * }
   * ```
   */
  size_t n_in;
  int32_t *in;
  /*
   * `not_in` requires the field value to be not equal to any of the
   *specified enum values. If the field value matches one of the specified
   * values, an error message is generated.
   * ```proto
   * enum MyEnum {
   *   MY_ENUM_UNSPECIFIED = 0;
   *   MY_ENUM_VALUE1 = 1;
   *   MY_ENUM_VALUE2 = 2;
   * }
   * message MyMessage {
   *   // The field `value` must not be equal to any of the specified values.
   *   MyEnum value = 1 [(buf.validate.field).enum = { not_in: [1, 2]}];
   * }
   * ```
   */
  size_t n_not_in;
  int32_t *not_in;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * enum MyEnum {
   *   MY_ENUM_UNSPECIFIED = 0;
   *   MY_ENUM_VALUE1 = 1;
   *   MY_ENUM_VALUE2 = 2;
   * }
   * message MyMessage {
   *     (buf.validate.field).enum.example = 1,
   *     (buf.validate.field).enum.example = 2
   * }
   * ```
   */
  size_t n_example;
  int32_t *example;
};
#define BUF__VALIDATE__ENUM_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__enum_rules__descriptor) \
, 0, 0, 0, 0, 0,NULL, 0,NULL, 0,NULL }


/*
 * RepeatedRules describe the rules applied to `repeated` values.
 */
struct  Buf__Validate__RepeatedRules
{
  ProtobufCMessage base;
  /*
   * `min_items` requires that this field must contain at least the specified
   * minimum number of items.
   * Note that `min_items = 1` is equivalent to setting a field as `required`.
   * ```proto
   * message MyRepeated {
   *   // value must contain at least  2 items
   *   repeated string value = 1 [(buf.validate.field).repeated.min_items = 2];
   * }
   * ```
   */
  protobuf_c_boolean has_min_items;
  uint64_t min_items;
  /*
   * `max_items` denotes that this field must not exceed a
   * certain number of items as the upper limit. If the field contains more
   * items than specified, an error message will be generated, requiring the
   * field to maintain no more than the specified number of items.
   * ```proto
   * message MyRepeated {
   *   // value must contain no more than 3 item(s)
   *   repeated string value = 1 [(buf.validate.field).repeated.max_items = 3];
   * }
   * ```
   */
  protobuf_c_boolean has_max_items;
  uint64_t max_items;
  /*
   * `unique` indicates that all elements in this field must
   * be unique. This rule is strictly applicable to scalar and enum
   * types, with message types not being supported.
   * ```proto
   * message MyRepeated {
   *   // repeated value must contain unique items
   *   repeated string value = 1 [(buf.validate.field).repeated.unique = true];
   * }
   * ```
   */
  protobuf_c_boolean has_unique;
  protobuf_c_boolean unique;
  /*
   * `items` details the rules to be applied to each item
   * in the field. Even for repeated message fields, validation is executed
   * against each item unless `ignore` is specified.
   * ```proto
   * message MyRepeated {
   *   // The items in the field `value` must follow the specified rules.
   *   repeated string value = 1 [(buf.validate.field).repeated.items = {
   *     string: {
   *       min_len: 3
   *       max_len: 10
   *     }
   *   }];
   * }
   * ```
   * Note that the `required` rule does not apply. Repeated items
   * cannot be unset.
   */
  Buf__Validate__FieldRules *items;
};
#define BUF__VALIDATE__REPEATED_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__repeated_rules__descriptor) \
, 0, 0, 0, 0, 0, 0, NULL }


/*
 * MapRules describe the rules applied to `map` values.
 */
struct  Buf__Validate__MapRules
{
  ProtobufCMessage base;
  /*
   * Specifies the minimum number of key-value pairs allowed. If the field has
   * fewer key-value pairs than specified, an error message is generated.
   * ```proto
   * message MyMap {
   *   // The field `value` must have at least 2 key-value pairs.
   *   map<string, string> value = 1 [(buf.validate.field).map.min_pairs = 2];
   * }
   * ```
   */
  protobuf_c_boolean has_min_pairs;
  uint64_t min_pairs;
  /*
   * Specifies the maximum number of key-value pairs allowed. If the field has
   * more key-value pairs than specified, an error message is generated.
   * ```proto
   * message MyMap {
   *   // The field `value` must have at most 3 key-value pairs.
   *   map<string, string> value = 1 [(buf.validate.field).map.max_pairs = 3];
   * }
   * ```
   */
  protobuf_c_boolean has_max_pairs;
  uint64_t max_pairs;
  /*
   * Specifies the rules to be applied to each key in the field.
   * ```proto
   * message MyMap {
   *   // The keys in the field `value` must follow the specified rules.
   *   map<string, string> value = 1 [(buf.validate.field).map.keys = {
   *     string: {
   *       min_len: 3
   *       max_len: 10
   *     }
   *   }];
   * }
   * ```
   * Note that the `required` rule does not apply. Map keys cannot be unset.
   */
  Buf__Validate__FieldRules *keys;
  /*
   * Specifies the rules to be applied to the value of each key in the
   * field. Message values will still have their validations evaluated unless
   * `ignore` is specified.
   * ```proto
   * message MyMap {
   *   // The values in the field `value` must follow the specified rules.
   *   map<string, string> value = 1 [(buf.validate.field).map.values = {
   *     string: {
   *       min_len: 5
   *       max_len: 20
   *     }
   *   }];
   * }
   * ```
   * Note that the `required` rule does not apply. Map values cannot be unset.
   */
  Buf__Validate__FieldRules *values;
};
#define BUF__VALIDATE__MAP_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__map_rules__descriptor) \
, 0, 0, 0, 0, NULL, NULL }


/*
 * AnyRules describe rules applied exclusively to the `google.protobuf.Any` well-known type.
 */
struct  Buf__Validate__AnyRules
{
  ProtobufCMessage base;
  /*
   * `in` requires the field's `type_url` to be equal to one of the
   *specified values. If it doesn't match any of the specified values, an error
   * message is generated.
   * ```proto
   * message MyAny {
   *   //  The `value` field must have a `type_url` equal to one of the specified values.
   *   google.protobuf.Any value = 1 [(buf.validate.field).any = {
   *       in: ["type.googleapis.com/MyType1", "type.googleapis.com/MyType2"]
   *   }];
   * }
   * ```
   */
  size_t n_in;
  char **in;
  /*
   * requires the field's type_url to be not equal to any of the specified values. If it matches any of the specified values, an error message is generated.
   * ```proto
   * message MyAny {
   *   //  The `value` field must not have a `type_url` equal to any of the specified values.
   *   google.protobuf.Any value = 1 [(buf.validate.field).any = {
   *       not_in: ["type.googleapis.com/ForbiddenType1", "type.googleapis.com/ForbiddenType2"]
   *   }];
   * }
   * ```
   */
  size_t n_not_in;
  char **not_in;
};
#define BUF__VALIDATE__ANY_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__any_rules__descriptor) \
, 0,NULL, 0,NULL }


typedef enum {
  BUF__VALIDATE__DURATION_RULES__LESS_THAN__NOT_SET = 0,
  BUF__VALIDATE__DURATION_RULES__LESS_THAN_LT = 3,
  BUF__VALIDATE__DURATION_RULES__LESS_THAN_LTE = 4
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__DURATION_RULES__LESS_THAN__CASE)
} Buf__Validate__DurationRules__LessThanCase;

typedef enum {
  BUF__VALIDATE__DURATION_RULES__GREATER_THAN__NOT_SET = 0,
  BUF__VALIDATE__DURATION_RULES__GREATER_THAN_GT = 5,
  BUF__VALIDATE__DURATION_RULES__GREATER_THAN_GTE = 6
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__DURATION_RULES__GREATER_THAN__CASE)
} Buf__Validate__DurationRules__GreaterThanCase;

/*
 * DurationRules describe the rules applied exclusively to the `google.protobuf.Duration` well-known type.
 */
struct  Buf__Validate__DurationRules
{
  ProtobufCMessage base;
  /*
   * `const` dictates that the field must match the specified value of the `google.protobuf.Duration` type exactly.
   * If the field's value deviates from the specified value, an error message
   * will be generated.
   * ```proto
   * message MyDuration {
   *   // value must equal 5s
   *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.const = "5s"];
   * }
   * ```
   */
  Google__Protobuf__Duration *const_;
  /*
   * `in` asserts that the field must be equal to one of the specified values of the `google.protobuf.Duration` type.
   * If the field's value doesn't correspond to any of the specified values,
   * an error message will be generated.
   * ```proto
   * message MyDuration {
   *   // value must be in list [1s, 2s, 3s]
   *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.in = ["1s", "2s", "3s"]];
   * }
   * ```
   */
  size_t n_in;
  Google__Protobuf__Duration **in;
  /*
   * `not_in` denotes that the field must not be equal to
   * any of the specified values of the `google.protobuf.Duration` type.
   * If the field's value matches any of these values, an error message will be
   * generated.
   * ```proto
   * message MyDuration {
   *   // value must not be in list [1s, 2s, 3s]
   *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.not_in = ["1s", "2s", "3s"]];
   * }
   * ```
   */
  size_t n_not_in;
  Google__Protobuf__Duration **not_in;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MyDuration {
   *   google.protobuf.Duration value = 1 [
   *     (buf.validate.field).duration.example = { seconds: 1 },
   *     (buf.validate.field).duration.example = { seconds: 2 },
   *   ];
   * }
   * ```
   */
  size_t n_example;
  Google__Protobuf__Duration **example;
  Buf__Validate__DurationRules__LessThanCase less_than_case;
  union {
    /*
     * `lt` stipulates that the field must be less than the specified value of the `google.protobuf.Duration` type,
     * exclusive. If the field's value is greater than or equal to the specified
     * value, an error message will be generated.
     * ```proto
     * message MyDuration {
     *   // value must be less than 5s
     *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lt = "5s"];
     * }
     * ```
     */
    Google__Protobuf__Duration *lt;
    /*
     * `lte` indicates that the field must be less than or equal to the specified
     * value of the `google.protobuf.Duration` type, inclusive. If the field's value is greater than the specified value,
     * an error message will be generated.
     * ```proto
     * message MyDuration {
     *   // value must be less than or equal to 10s
     *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lte = "10s"];
     * }
     * ```
     */
    Google__Protobuf__Duration *lte;
  };
  Buf__Validate__DurationRules__GreaterThanCase greater_than_case;
  union {
    /*
     * `gt` requires the duration field value to be greater than the specified
     * value (exclusive). If the value of `gt` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyDuration {
     *   // duration must be greater than 5s [duration.gt]
     *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.gt = { seconds: 5 }];
     *   // duration must be greater than 5s and less than 10s [duration.gt_lt]
     *   google.protobuf.Duration another_value = 2 [(buf.validate.field).duration = { gt: { seconds: 5 }, lt: { seconds: 10 } }];
     *   // duration must be greater than 10s or less than 5s [duration.gt_lt_exclusive]
     *   google.protobuf.Duration other_value = 3 [(buf.validate.field).duration = { gt: { seconds: 10 }, lt: { seconds: 5 } }];
     * }
     * ```
     */
    Google__Protobuf__Duration *gt;
    /*
     * `gte` requires the duration field value to be greater than or equal to the
     * specified value (exclusive). If the value of `gte` is larger than a
     * specified `lt` or `lte`, the range is reversed, and the field value must
     * be outside the specified range. If the field value doesn't meet the
     * required conditions, an error message is generated.
     * ```proto
     * message MyDuration {
     *  // duration must be greater than or equal to 5s [duration.gte]
     *  google.protobuf.Duration value = 1 [(buf.validate.field).duration.gte = { seconds: 5 }];
     *  // duration must be greater than or equal to 5s and less than 10s [duration.gte_lt]
     *  google.protobuf.Duration another_value = 2 [(buf.validate.field).duration = { gte: { seconds: 5 }, lt: { seconds: 10 } }];
     *  // duration must be greater than or equal to 10s or less than 5s [duration.gte_lt_exclusive]
     *  google.protobuf.Duration other_value = 3 [(buf.validate.field).duration = { gte: { seconds: 10 }, lt: { seconds: 5 } }];
     * }
     * ```
     */
    Google__Protobuf__Duration *gte;
  };
};
#define BUF__VALIDATE__DURATION_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__duration_rules__descriptor) \
, NULL, 0,NULL, 0,NULL, 0,NULL, BUF__VALIDATE__DURATION_RULES__LESS_THAN__NOT_SET, {0}, BUF__VALIDATE__DURATION_RULES__GREATER_THAN__NOT_SET, {0} }


typedef enum {
  BUF__VALIDATE__TIMESTAMP_RULES__LESS_THAN__NOT_SET = 0,
  BUF__VALIDATE__TIMESTAMP_RULES__LESS_THAN_LT = 3,
  BUF__VALIDATE__TIMESTAMP_RULES__LESS_THAN_LTE = 4,
  BUF__VALIDATE__TIMESTAMP_RULES__LESS_THAN_LT_NOW = 7
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__TIMESTAMP_RULES__LESS_THAN__CASE)
} Buf__Validate__TimestampRules__LessThanCase;

typedef enum {
  BUF__VALIDATE__TIMESTAMP_RULES__GREATER_THAN__NOT_SET = 0,
  BUF__VALIDATE__TIMESTAMP_RULES__GREATER_THAN_GT = 5,
  BUF__VALIDATE__TIMESTAMP_RULES__GREATER_THAN_GTE = 6,
  BUF__VALIDATE__TIMESTAMP_RULES__GREATER_THAN_GT_NOW = 8
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__TIMESTAMP_RULES__GREATER_THAN__CASE)
} Buf__Validate__TimestampRules__GreaterThanCase;

/*
 * TimestampRules describe the rules applied exclusively to the `google.protobuf.Timestamp` well-known type.
 */
struct  Buf__Validate__TimestampRules
{
  ProtobufCMessage base;
  /*
   * `const` dictates that this field, of the `google.protobuf.Timestamp` type, must exactly match the specified value. If the field value doesn't correspond to the specified timestamp, an error message will be generated.
   * ```proto
   * message MyTimestamp {
   *   // value must equal 2023-05-03T10:00:00Z
   *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.const = {seconds: 1727998800}];
   * }
   * ```
   */
  Google__Protobuf__Timestamp *const_;
  /*
   * `within` specifies that this field, of the `google.protobuf.Timestamp` type, must be within the specified duration of the current time. If the field value isn't within the duration, an error message is generated.
   * ```proto
   * message MyTimestamp {
   *   // value must be within 1 hour of now
   *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.within = {seconds: 3600}];
   * }
   * ```
   */
  Google__Protobuf__Duration *within;
  /*
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   * ```proto
   * message MyTimestamp {
   *   google.protobuf.Timestamp value = 1 [
   *     (buf.validate.field).timestamp.example = { seconds: 1672444800 },
   *     (buf.validate.field).timestamp.example = { seconds: 1672531200 },
   *   ];
   * }
   * ```
   */
  size_t n_example;
  Google__Protobuf__Timestamp **example;
  Buf__Validate__TimestampRules__LessThanCase less_than_case;
  union {
    /*
     * requires the duration field value to be less than the specified value (field < value). If the field value doesn't meet the required conditions, an error message is generated.
     * ```proto
     * message MyDuration {
     *   // duration must be less than 'P3D' [duration.lt]
     *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lt = { seconds: 259200 }];
     * }
     * ```
     */
    Google__Protobuf__Timestamp *lt;
    /*
     * requires the timestamp field value to be less than or equal to the specified value (field <= value). If the field value doesn't meet the required conditions, an error message is generated.
     * ```proto
     * message MyTimestamp {
     *   // timestamp must be less than or equal to '2023-05-14T00:00:00Z' [timestamp.lte]
     *   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.lte = { seconds: 1678867200 }];
     * }
     * ```
     */
    Google__Protobuf__Timestamp *lte;
    /*
     * `lt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be less than the current time. `lt_now` can only be used with the `within` rule.
     * ```proto
     * message MyTimestamp {
     *  // value must be less than now
     *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.lt_now = true];
     * }
     * ```
     */
    protobuf_c_boolean lt_now;
  };
  Buf__Validate__TimestampRules__GreaterThanCase greater_than_case;
  union {
    /*
     * `gt` requires the timestamp field value to be greater than the specified
     * value (exclusive). If the value of `gt` is larger than a specified `lt`
     * or `lte`, the range is reversed, and the field value must be outside the
     * specified range. If the field value doesn't meet the required conditions,
     * an error message is generated.
     * ```proto
     * message MyTimestamp {
     *   // timestamp must be greater than '2023-01-01T00:00:00Z' [timestamp.gt]
     *   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.gt = { seconds: 1672444800 }];
     *   // timestamp must be greater than '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' [timestamp.gt_lt]
     *   google.protobuf.Timestamp another_value = 2 [(buf.validate.field).timestamp = { gt: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }];
     *   // timestamp must be greater than '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' [timestamp.gt_lt_exclusive]
     *   google.protobuf.Timestamp other_value = 3 [(buf.validate.field).timestamp = { gt: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }];
     * }
     * ```
     */
    Google__Protobuf__Timestamp *gt;
    /*
     * `gte` requires the timestamp field value to be greater than or equal to the
     * specified value (exclusive). If the value of `gte` is larger than a
     * specified `lt` or `lte`, the range is reversed, and the field value
     * must be outside the specified range. If the field value doesn't meet
     * the required conditions, an error message is generated.
     * ```proto
     * message MyTimestamp {
     *   // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' [timestamp.gte]
     *   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.gte = { seconds: 1672444800 }];
     *   // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' [timestamp.gte_lt]
     *   google.protobuf.Timestamp another_value = 2 [(buf.validate.field).timestamp = { gte: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }];
     *   // timestamp must be greater than or equal to '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' [timestamp.gte_lt_exclusive]
     *   google.protobuf.Timestamp other_value = 3 [(buf.validate.field).timestamp = { gte: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }];
     * }
     * ```
     */
    Google__Protobuf__Timestamp *gte;
    /*
     * `gt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be greater than the current time. `gt_now` can only be used with the `within` rule.
     * ```proto
     * message MyTimestamp {
     *   // value must be greater than now
     *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.gt_now = true];
     * }
     * ```
     */
    protobuf_c_boolean gt_now;
  };
};
#define BUF__VALIDATE__TIMESTAMP_RULES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__timestamp_rules__descriptor) \
, NULL, NULL, 0,NULL, BUF__VALIDATE__TIMESTAMP_RULES__LESS_THAN__NOT_SET, {0}, BUF__VALIDATE__TIMESTAMP_RULES__GREATER_THAN__NOT_SET, {0} }


/*
 * `Violations` is a collection of `Violation` messages. This message type is returned by
 * Protovalidate when a proto message fails to meet the requirements set by the `Rule` validation rules.
 * Each individual violation is represented by a `Violation` message.
 */
struct  Buf__Validate__Violations
{
  ProtobufCMessage base;
  /*
   * `violations` is a repeated field that contains all the `Violation` messages corresponding to the violations detected.
   */
  size_t n_violations;
  Buf__Validate__Violation **violations;
};
#define BUF__VALIDATE__VIOLATIONS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__violations__descriptor) \
, 0,NULL }


/*
 * `Violation` represents a single instance where a validation rule, expressed
 * as a `Rule`, was not met. It provides information about the field that
 * caused the violation, the specific rule that wasn't fulfilled, and a
 * human-readable error message.
 * For example, consider the following message:
 * ```proto
 * message User {
 *     int32 age = 1 [(buf.validate.field).cel = {
 *         id: "user.age",
 *         expression: "this < 18 ? 'User must be at least 18 years old' : ''",
 *     }];
 * }
 * ```
 * It could produce the following violation:
 * ```json
 * {
 *   "ruleId": "user.age",
 *   "message": "User must be at least 18 years old",
 *   "field": {
 *     "elements": [
 *       {
 *         "fieldNumber": 1,
 *         "fieldName": "age",
 *         "fieldType": "TYPE_INT32"
 *       }
 *     ]
 *   },
 *   "rule": {
 *     "elements": [
 *       {
 *         "fieldNumber": 23,
 *         "fieldName": "cel",
 *         "fieldType": "TYPE_MESSAGE",
 *         "index": "0"
 *       }
 *     ]
 *   }
 * }
 * ```
 */
struct  Buf__Validate__Violation
{
  ProtobufCMessage base;
  /*
   * `field` is a machine-readable path to the field that failed validation.
   * This could be a nested field, in which case the path will include all the parent fields leading to the actual field that caused the violation.
   * For example, consider the following message:
   * ```proto
   * message Message {
   *   bool a = 1 [(buf.validate.field).required = true];
   * }
   * ```
   * It could produce the following violation:
   * ```textproto
   * violation {
   *   field { element { field_number: 1, field_name: "a", field_type: 8 } }
   *   ...
   * }
   * ```
   */
  Buf__Validate__FieldPath *field;
  /*
   * `rule` is a machine-readable path that points to the specific rule that failed validation.
   * This will be a nested field starting from the FieldRules of the field that failed validation.
   * For custom rules, this will provide the path of the rule, e.g. `cel[0]`.
   * For example, consider the following message:
   * ```proto
   * message Message {
   *   bool a = 1 [(buf.validate.field).required = true];
   *   bool b = 2 [(buf.validate.field).cel = {
   *     id: "custom_rule",
   *     expression: "!this ? 'b must be true': ''"
   *   }]
   * }
   * ```
   * It could produce the following violations:
   * ```textproto
   * violation {
   *   rule { element { field_number: 25, field_name: "required", field_type: 8 } }
   *   ...
   * }
   * violation {
   *   rule { element { field_number: 23, field_name: "cel", field_type: 11, index: 0 } }
   *   ...
   * }
   * ```
   */
  Buf__Validate__FieldPath *rule;
  /*
   * `rule_id` is the unique identifier of the `Rule` that was not fulfilled.
   * This is the same `id` that was specified in the `Rule` message, allowing easy tracing of which rule was violated.
   */
  char *rule_id;
  /*
   * `message` is a human-readable error message that describes the nature of the violation.
   * This can be the default error message from the violated `Rule`, or it can be a custom message that gives more context about the violation.
   */
  char *message;
  /*
   * `for_key` indicates whether the violation was caused by a map key, rather than a value.
   */
  protobuf_c_boolean has_for_key;
  protobuf_c_boolean for_key;
};
#define BUF__VALIDATE__VIOLATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__violation__descriptor) \
, NULL, NULL, NULL, NULL, 0, 0 }


/*
 * `FieldPath` provides a path to a nested protobuf field.
 * This message provides enough information to render a dotted field path even without protobuf descriptors.
 * It also provides enough information to resolve a nested field through unknown wire data.
 */
struct  Buf__Validate__FieldPath
{
  ProtobufCMessage base;
  /*
   * `elements` contains each element of the path, starting from the root and recursing downward.
   */
  size_t n_elements;
  Buf__Validate__FieldPathElement **elements;
};
#define BUF__VALIDATE__FIELD_PATH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__field_path__descriptor) \
, 0,NULL }


typedef enum {
  BUF__VALIDATE__FIELD_PATH_ELEMENT__SUBSCRIPT__NOT_SET = 0,
  BUF__VALIDATE__FIELD_PATH_ELEMENT__SUBSCRIPT_INDEX = 6,
  BUF__VALIDATE__FIELD_PATH_ELEMENT__SUBSCRIPT_BOOL_KEY = 7,
  BUF__VALIDATE__FIELD_PATH_ELEMENT__SUBSCRIPT_INT_KEY = 8,
  BUF__VALIDATE__FIELD_PATH_ELEMENT__SUBSCRIPT_UINT_KEY = 9,
  BUF__VALIDATE__FIELD_PATH_ELEMENT__SUBSCRIPT_STRING_KEY = 10
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(BUF__VALIDATE__FIELD_PATH_ELEMENT__SUBSCRIPT__CASE)
} Buf__Validate__FieldPathElement__SubscriptCase;

/*
 * `FieldPathElement` provides enough information to nest through a single protobuf field.
 * If the selected field is a map or repeated field, the `subscript` value selects a specific element from it.
 * A path that refers to a value nested under a map key or repeated field index will have a `subscript` value.
 * The `field_type` field allows unambiguous resolution of a field even if descriptors are not available.
 */
struct  Buf__Validate__FieldPathElement
{
  ProtobufCMessage base;
  /*
   * `field_number` is the field number this path element refers to.
   */
  protobuf_c_boolean has_field_number;
  int32_t field_number;
  /*
   * `field_name` contains the field name this path element refers to.
   * This can be used to display a human-readable path even if the field number is unknown.
   */
  char *field_name;
  /*
   * `field_type` specifies the type of this field. When using reflection, this value is not needed.
   * This value is provided to make it possible to traverse unknown fields through wire data.
   * When traversing wire data, be mindful of both packed[1] and delimited[2] encoding schemes.
   * [1]: https://protobuf.dev/programming-guides/encoding/#packed
   * [2]: https://protobuf.dev/programming-guides/encoding/#groups
   * N.B.: Although groups are deprecated, the corresponding delimited encoding scheme is not, and
   * can be explicitly used in Protocol Buffers 2023 Edition.
   */
  protobuf_c_boolean has_field_type;
  Google__Protobuf__FieldDescriptorProto__Type field_type;
  /*
   * `key_type` specifies the map key type of this field. This value is useful when traversing
   * unknown fields through wire data: specifically, it allows handling the differences between
   * different integer encodings.
   */
  protobuf_c_boolean has_key_type;
  Google__Protobuf__FieldDescriptorProto__Type key_type;
  /*
   * `value_type` specifies map value type of this field. This is useful if you want to display a
   * value inside unknown fields through wire data.
   */
  protobuf_c_boolean has_value_type;
  Google__Protobuf__FieldDescriptorProto__Type value_type;
  Buf__Validate__FieldPathElement__SubscriptCase subscript_case;
  union {
    /*
     * `index` specifies a 0-based index into a repeated field.
     */
    uint64_t index;
    /*
     * `int_key` specifies a map key of type int32, int64, sint32, sint64, sfixed32 or sfixed64.
     */
    int64_t int_key;
    /*
     * `uint_key` specifies a map key of type uint32, uint64, fixed32 or fixed64.
     */
    uint64_t uint_key;
    /*
     * `string_key` specifies a map key of type string.
     */
    char *string_key;
    /*
     * `bool_key` specifies a map key of type bool.
     */
    protobuf_c_boolean bool_key;
  };
};
#define BUF__VALIDATE__FIELD_PATH_ELEMENT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&buf__validate__field_path_element__descriptor) \
, 0, 0, NULL, 0, GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_DOUBLE, 0, GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_DOUBLE, 0, GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_DOUBLE, BUF__VALIDATE__FIELD_PATH_ELEMENT__SUBSCRIPT__NOT_SET, {0} }


/* Buf__Validate__Rule methods */
void   buf__validate__rule__init
                     (Buf__Validate__Rule         *message);
size_t buf__validate__rule__get_packed_size
                     (const Buf__Validate__Rule   *message);
size_t buf__validate__rule__pack
                     (const Buf__Validate__Rule   *message,
                      uint8_t             *out);
size_t buf__validate__rule__pack_to_buffer
                     (const Buf__Validate__Rule   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__Rule *
       buf__validate__rule__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__rule__free_unpacked
                     (Buf__Validate__Rule *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__MessageRules methods */
void   buf__validate__message_rules__init
                     (Buf__Validate__MessageRules         *message);
size_t buf__validate__message_rules__get_packed_size
                     (const Buf__Validate__MessageRules   *message);
size_t buf__validate__message_rules__pack
                     (const Buf__Validate__MessageRules   *message,
                      uint8_t             *out);
size_t buf__validate__message_rules__pack_to_buffer
                     (const Buf__Validate__MessageRules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__MessageRules *
       buf__validate__message_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__message_rules__free_unpacked
                     (Buf__Validate__MessageRules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__MessageOneofRule methods */
void   buf__validate__message_oneof_rule__init
                     (Buf__Validate__MessageOneofRule         *message);
size_t buf__validate__message_oneof_rule__get_packed_size
                     (const Buf__Validate__MessageOneofRule   *message);
size_t buf__validate__message_oneof_rule__pack
                     (const Buf__Validate__MessageOneofRule   *message,
                      uint8_t             *out);
size_t buf__validate__message_oneof_rule__pack_to_buffer
                     (const Buf__Validate__MessageOneofRule   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__MessageOneofRule *
       buf__validate__message_oneof_rule__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__message_oneof_rule__free_unpacked
                     (Buf__Validate__MessageOneofRule *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__OneofRules methods */
void   buf__validate__oneof_rules__init
                     (Buf__Validate__OneofRules         *message);
size_t buf__validate__oneof_rules__get_packed_size
                     (const Buf__Validate__OneofRules   *message);
size_t buf__validate__oneof_rules__pack
                     (const Buf__Validate__OneofRules   *message,
                      uint8_t             *out);
size_t buf__validate__oneof_rules__pack_to_buffer
                     (const Buf__Validate__OneofRules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__OneofRules *
       buf__validate__oneof_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__oneof_rules__free_unpacked
                     (Buf__Validate__OneofRules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__FieldRules methods */
void   buf__validate__field_rules__init
                     (Buf__Validate__FieldRules         *message);
size_t buf__validate__field_rules__get_packed_size
                     (const Buf__Validate__FieldRules   *message);
size_t buf__validate__field_rules__pack
                     (const Buf__Validate__FieldRules   *message,
                      uint8_t             *out);
size_t buf__validate__field_rules__pack_to_buffer
                     (const Buf__Validate__FieldRules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__FieldRules *
       buf__validate__field_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__field_rules__free_unpacked
                     (Buf__Validate__FieldRules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__PredefinedRules methods */
void   buf__validate__predefined_rules__init
                     (Buf__Validate__PredefinedRules         *message);
size_t buf__validate__predefined_rules__get_packed_size
                     (const Buf__Validate__PredefinedRules   *message);
size_t buf__validate__predefined_rules__pack
                     (const Buf__Validate__PredefinedRules   *message,
                      uint8_t             *out);
size_t buf__validate__predefined_rules__pack_to_buffer
                     (const Buf__Validate__PredefinedRules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__PredefinedRules *
       buf__validate__predefined_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__predefined_rules__free_unpacked
                     (Buf__Validate__PredefinedRules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__FloatRules methods */
void   buf__validate__float_rules__init
                     (Buf__Validate__FloatRules         *message);
size_t buf__validate__float_rules__get_packed_size
                     (const Buf__Validate__FloatRules   *message);
size_t buf__validate__float_rules__pack
                     (const Buf__Validate__FloatRules   *message,
                      uint8_t             *out);
size_t buf__validate__float_rules__pack_to_buffer
                     (const Buf__Validate__FloatRules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__FloatRules *
       buf__validate__float_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__float_rules__free_unpacked
                     (Buf__Validate__FloatRules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__DoubleRules methods */
void   buf__validate__double_rules__init
                     (Buf__Validate__DoubleRules         *message);
size_t buf__validate__double_rules__get_packed_size
                     (const Buf__Validate__DoubleRules   *message);
size_t buf__validate__double_rules__pack
                     (const Buf__Validate__DoubleRules   *message,
                      uint8_t             *out);
size_t buf__validate__double_rules__pack_to_buffer
                     (const Buf__Validate__DoubleRules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__DoubleRules *
       buf__validate__double_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__double_rules__free_unpacked
                     (Buf__Validate__DoubleRules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__Int32Rules methods */
void   buf__validate__int32_rules__init
                     (Buf__Validate__Int32Rules         *message);
size_t buf__validate__int32_rules__get_packed_size
                     (const Buf__Validate__Int32Rules   *message);
size_t buf__validate__int32_rules__pack
                     (const Buf__Validate__Int32Rules   *message,
                      uint8_t             *out);
size_t buf__validate__int32_rules__pack_to_buffer
                     (const Buf__Validate__Int32Rules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__Int32Rules *
       buf__validate__int32_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__int32_rules__free_unpacked
                     (Buf__Validate__Int32Rules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__Int64Rules methods */
void   buf__validate__int64_rules__init
                     (Buf__Validate__Int64Rules         *message);
size_t buf__validate__int64_rules__get_packed_size
                     (const Buf__Validate__Int64Rules   *message);
size_t buf__validate__int64_rules__pack
                     (const Buf__Validate__Int64Rules   *message,
                      uint8_t             *out);
size_t buf__validate__int64_rules__pack_to_buffer
                     (const Buf__Validate__Int64Rules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__Int64Rules *
       buf__validate__int64_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__int64_rules__free_unpacked
                     (Buf__Validate__Int64Rules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__UInt32Rules methods */
void   buf__validate__uint32_rules__init
                     (Buf__Validate__UInt32Rules         *message);
size_t buf__validate__uint32_rules__get_packed_size
                     (const Buf__Validate__UInt32Rules   *message);
size_t buf__validate__uint32_rules__pack
                     (const Buf__Validate__UInt32Rules   *message,
                      uint8_t             *out);
size_t buf__validate__uint32_rules__pack_to_buffer
                     (const Buf__Validate__UInt32Rules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__UInt32Rules *
       buf__validate__uint32_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__uint32_rules__free_unpacked
                     (Buf__Validate__UInt32Rules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__UInt64Rules methods */
void   buf__validate__uint64_rules__init
                     (Buf__Validate__UInt64Rules         *message);
size_t buf__validate__uint64_rules__get_packed_size
                     (const Buf__Validate__UInt64Rules   *message);
size_t buf__validate__uint64_rules__pack
                     (const Buf__Validate__UInt64Rules   *message,
                      uint8_t             *out);
size_t buf__validate__uint64_rules__pack_to_buffer
                     (const Buf__Validate__UInt64Rules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__UInt64Rules *
       buf__validate__uint64_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__uint64_rules__free_unpacked
                     (Buf__Validate__UInt64Rules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__SInt32Rules methods */
void   buf__validate__sint32_rules__init
                     (Buf__Validate__SInt32Rules         *message);
size_t buf__validate__sint32_rules__get_packed_size
                     (const Buf__Validate__SInt32Rules   *message);
size_t buf__validate__sint32_rules__pack
                     (const Buf__Validate__SInt32Rules   *message,
                      uint8_t             *out);
size_t buf__validate__sint32_rules__pack_to_buffer
                     (const Buf__Validate__SInt32Rules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__SInt32Rules *
       buf__validate__sint32_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__sint32_rules__free_unpacked
                     (Buf__Validate__SInt32Rules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__SInt64Rules methods */
void   buf__validate__sint64_rules__init
                     (Buf__Validate__SInt64Rules         *message);
size_t buf__validate__sint64_rules__get_packed_size
                     (const Buf__Validate__SInt64Rules   *message);
size_t buf__validate__sint64_rules__pack
                     (const Buf__Validate__SInt64Rules   *message,
                      uint8_t             *out);
size_t buf__validate__sint64_rules__pack_to_buffer
                     (const Buf__Validate__SInt64Rules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__SInt64Rules *
       buf__validate__sint64_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__sint64_rules__free_unpacked
                     (Buf__Validate__SInt64Rules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__Fixed32Rules methods */
void   buf__validate__fixed32_rules__init
                     (Buf__Validate__Fixed32Rules         *message);
size_t buf__validate__fixed32_rules__get_packed_size
                     (const Buf__Validate__Fixed32Rules   *message);
size_t buf__validate__fixed32_rules__pack
                     (const Buf__Validate__Fixed32Rules   *message,
                      uint8_t             *out);
size_t buf__validate__fixed32_rules__pack_to_buffer
                     (const Buf__Validate__Fixed32Rules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__Fixed32Rules *
       buf__validate__fixed32_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__fixed32_rules__free_unpacked
                     (Buf__Validate__Fixed32Rules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__Fixed64Rules methods */
void   buf__validate__fixed64_rules__init
                     (Buf__Validate__Fixed64Rules         *message);
size_t buf__validate__fixed64_rules__get_packed_size
                     (const Buf__Validate__Fixed64Rules   *message);
size_t buf__validate__fixed64_rules__pack
                     (const Buf__Validate__Fixed64Rules   *message,
                      uint8_t             *out);
size_t buf__validate__fixed64_rules__pack_to_buffer
                     (const Buf__Validate__Fixed64Rules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__Fixed64Rules *
       buf__validate__fixed64_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__fixed64_rules__free_unpacked
                     (Buf__Validate__Fixed64Rules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__SFixed32Rules methods */
void   buf__validate__sfixed32_rules__init
                     (Buf__Validate__SFixed32Rules         *message);
size_t buf__validate__sfixed32_rules__get_packed_size
                     (const Buf__Validate__SFixed32Rules   *message);
size_t buf__validate__sfixed32_rules__pack
                     (const Buf__Validate__SFixed32Rules   *message,
                      uint8_t             *out);
size_t buf__validate__sfixed32_rules__pack_to_buffer
                     (const Buf__Validate__SFixed32Rules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__SFixed32Rules *
       buf__validate__sfixed32_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__sfixed32_rules__free_unpacked
                     (Buf__Validate__SFixed32Rules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__SFixed64Rules methods */
void   buf__validate__sfixed64_rules__init
                     (Buf__Validate__SFixed64Rules         *message);
size_t buf__validate__sfixed64_rules__get_packed_size
                     (const Buf__Validate__SFixed64Rules   *message);
size_t buf__validate__sfixed64_rules__pack
                     (const Buf__Validate__SFixed64Rules   *message,
                      uint8_t             *out);
size_t buf__validate__sfixed64_rules__pack_to_buffer
                     (const Buf__Validate__SFixed64Rules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__SFixed64Rules *
       buf__validate__sfixed64_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__sfixed64_rules__free_unpacked
                     (Buf__Validate__SFixed64Rules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__BoolRules methods */
void   buf__validate__bool_rules__init
                     (Buf__Validate__BoolRules         *message);
size_t buf__validate__bool_rules__get_packed_size
                     (const Buf__Validate__BoolRules   *message);
size_t buf__validate__bool_rules__pack
                     (const Buf__Validate__BoolRules   *message,
                      uint8_t             *out);
size_t buf__validate__bool_rules__pack_to_buffer
                     (const Buf__Validate__BoolRules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__BoolRules *
       buf__validate__bool_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__bool_rules__free_unpacked
                     (Buf__Validate__BoolRules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__StringRules methods */
void   buf__validate__string_rules__init
                     (Buf__Validate__StringRules         *message);
size_t buf__validate__string_rules__get_packed_size
                     (const Buf__Validate__StringRules   *message);
size_t buf__validate__string_rules__pack
                     (const Buf__Validate__StringRules   *message,
                      uint8_t             *out);
size_t buf__validate__string_rules__pack_to_buffer
                     (const Buf__Validate__StringRules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__StringRules *
       buf__validate__string_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__string_rules__free_unpacked
                     (Buf__Validate__StringRules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__BytesRules methods */
void   buf__validate__bytes_rules__init
                     (Buf__Validate__BytesRules         *message);
size_t buf__validate__bytes_rules__get_packed_size
                     (const Buf__Validate__BytesRules   *message);
size_t buf__validate__bytes_rules__pack
                     (const Buf__Validate__BytesRules   *message,
                      uint8_t             *out);
size_t buf__validate__bytes_rules__pack_to_buffer
                     (const Buf__Validate__BytesRules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__BytesRules *
       buf__validate__bytes_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__bytes_rules__free_unpacked
                     (Buf__Validate__BytesRules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__EnumRules methods */
void   buf__validate__enum_rules__init
                     (Buf__Validate__EnumRules         *message);
size_t buf__validate__enum_rules__get_packed_size
                     (const Buf__Validate__EnumRules   *message);
size_t buf__validate__enum_rules__pack
                     (const Buf__Validate__EnumRules   *message,
                      uint8_t             *out);
size_t buf__validate__enum_rules__pack_to_buffer
                     (const Buf__Validate__EnumRules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__EnumRules *
       buf__validate__enum_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__enum_rules__free_unpacked
                     (Buf__Validate__EnumRules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__RepeatedRules methods */
void   buf__validate__repeated_rules__init
                     (Buf__Validate__RepeatedRules         *message);
size_t buf__validate__repeated_rules__get_packed_size
                     (const Buf__Validate__RepeatedRules   *message);
size_t buf__validate__repeated_rules__pack
                     (const Buf__Validate__RepeatedRules   *message,
                      uint8_t             *out);
size_t buf__validate__repeated_rules__pack_to_buffer
                     (const Buf__Validate__RepeatedRules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__RepeatedRules *
       buf__validate__repeated_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__repeated_rules__free_unpacked
                     (Buf__Validate__RepeatedRules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__MapRules methods */
void   buf__validate__map_rules__init
                     (Buf__Validate__MapRules         *message);
size_t buf__validate__map_rules__get_packed_size
                     (const Buf__Validate__MapRules   *message);
size_t buf__validate__map_rules__pack
                     (const Buf__Validate__MapRules   *message,
                      uint8_t             *out);
size_t buf__validate__map_rules__pack_to_buffer
                     (const Buf__Validate__MapRules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__MapRules *
       buf__validate__map_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__map_rules__free_unpacked
                     (Buf__Validate__MapRules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__AnyRules methods */
void   buf__validate__any_rules__init
                     (Buf__Validate__AnyRules         *message);
size_t buf__validate__any_rules__get_packed_size
                     (const Buf__Validate__AnyRules   *message);
size_t buf__validate__any_rules__pack
                     (const Buf__Validate__AnyRules   *message,
                      uint8_t             *out);
size_t buf__validate__any_rules__pack_to_buffer
                     (const Buf__Validate__AnyRules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__AnyRules *
       buf__validate__any_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__any_rules__free_unpacked
                     (Buf__Validate__AnyRules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__DurationRules methods */
void   buf__validate__duration_rules__init
                     (Buf__Validate__DurationRules         *message);
size_t buf__validate__duration_rules__get_packed_size
                     (const Buf__Validate__DurationRules   *message);
size_t buf__validate__duration_rules__pack
                     (const Buf__Validate__DurationRules   *message,
                      uint8_t             *out);
size_t buf__validate__duration_rules__pack_to_buffer
                     (const Buf__Validate__DurationRules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__DurationRules *
       buf__validate__duration_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__duration_rules__free_unpacked
                     (Buf__Validate__DurationRules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__TimestampRules methods */
void   buf__validate__timestamp_rules__init
                     (Buf__Validate__TimestampRules         *message);
size_t buf__validate__timestamp_rules__get_packed_size
                     (const Buf__Validate__TimestampRules   *message);
size_t buf__validate__timestamp_rules__pack
                     (const Buf__Validate__TimestampRules   *message,
                      uint8_t             *out);
size_t buf__validate__timestamp_rules__pack_to_buffer
                     (const Buf__Validate__TimestampRules   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__TimestampRules *
       buf__validate__timestamp_rules__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__timestamp_rules__free_unpacked
                     (Buf__Validate__TimestampRules *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__Violations methods */
void   buf__validate__violations__init
                     (Buf__Validate__Violations         *message);
size_t buf__validate__violations__get_packed_size
                     (const Buf__Validate__Violations   *message);
size_t buf__validate__violations__pack
                     (const Buf__Validate__Violations   *message,
                      uint8_t             *out);
size_t buf__validate__violations__pack_to_buffer
                     (const Buf__Validate__Violations   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__Violations *
       buf__validate__violations__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__violations__free_unpacked
                     (Buf__Validate__Violations *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__Violation methods */
void   buf__validate__violation__init
                     (Buf__Validate__Violation         *message);
size_t buf__validate__violation__get_packed_size
                     (const Buf__Validate__Violation   *message);
size_t buf__validate__violation__pack
                     (const Buf__Validate__Violation   *message,
                      uint8_t             *out);
size_t buf__validate__violation__pack_to_buffer
                     (const Buf__Validate__Violation   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__Violation *
       buf__validate__violation__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__violation__free_unpacked
                     (Buf__Validate__Violation *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__FieldPath methods */
void   buf__validate__field_path__init
                     (Buf__Validate__FieldPath         *message);
size_t buf__validate__field_path__get_packed_size
                     (const Buf__Validate__FieldPath   *message);
size_t buf__validate__field_path__pack
                     (const Buf__Validate__FieldPath   *message,
                      uint8_t             *out);
size_t buf__validate__field_path__pack_to_buffer
                     (const Buf__Validate__FieldPath   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__FieldPath *
       buf__validate__field_path__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__field_path__free_unpacked
                     (Buf__Validate__FieldPath *message,
                      ProtobufCAllocator *allocator);
/* Buf__Validate__FieldPathElement methods */
void   buf__validate__field_path_element__init
                     (Buf__Validate__FieldPathElement         *message);
size_t buf__validate__field_path_element__get_packed_size
                     (const Buf__Validate__FieldPathElement   *message);
size_t buf__validate__field_path_element__pack
                     (const Buf__Validate__FieldPathElement   *message,
                      uint8_t             *out);
size_t buf__validate__field_path_element__pack_to_buffer
                     (const Buf__Validate__FieldPathElement   *message,
                      ProtobufCBuffer     *buffer);
Buf__Validate__FieldPathElement *
       buf__validate__field_path_element__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   buf__validate__field_path_element__free_unpacked
                     (Buf__Validate__FieldPathElement *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Buf__Validate__Rule_Closure)
                 (const Buf__Validate__Rule *message,
                  void *closure_data);
typedef void (*Buf__Validate__MessageRules_Closure)
                 (const Buf__Validate__MessageRules *message,
                  void *closure_data);
typedef void (*Buf__Validate__MessageOneofRule_Closure)
                 (const Buf__Validate__MessageOneofRule *message,
                  void *closure_data);
typedef void (*Buf__Validate__OneofRules_Closure)
                 (const Buf__Validate__OneofRules *message,
                  void *closure_data);
typedef void (*Buf__Validate__FieldRules_Closure)
                 (const Buf__Validate__FieldRules *message,
                  void *closure_data);
typedef void (*Buf__Validate__PredefinedRules_Closure)
                 (const Buf__Validate__PredefinedRules *message,
                  void *closure_data);
typedef void (*Buf__Validate__FloatRules_Closure)
                 (const Buf__Validate__FloatRules *message,
                  void *closure_data);
typedef void (*Buf__Validate__DoubleRules_Closure)
                 (const Buf__Validate__DoubleRules *message,
                  void *closure_data);
typedef void (*Buf__Validate__Int32Rules_Closure)
                 (const Buf__Validate__Int32Rules *message,
                  void *closure_data);
typedef void (*Buf__Validate__Int64Rules_Closure)
                 (const Buf__Validate__Int64Rules *message,
                  void *closure_data);
typedef void (*Buf__Validate__UInt32Rules_Closure)
                 (const Buf__Validate__UInt32Rules *message,
                  void *closure_data);
typedef void (*Buf__Validate__UInt64Rules_Closure)
                 (const Buf__Validate__UInt64Rules *message,
                  void *closure_data);
typedef void (*Buf__Validate__SInt32Rules_Closure)
                 (const Buf__Validate__SInt32Rules *message,
                  void *closure_data);
typedef void (*Buf__Validate__SInt64Rules_Closure)
                 (const Buf__Validate__SInt64Rules *message,
                  void *closure_data);
typedef void (*Buf__Validate__Fixed32Rules_Closure)
                 (const Buf__Validate__Fixed32Rules *message,
                  void *closure_data);
typedef void (*Buf__Validate__Fixed64Rules_Closure)
                 (const Buf__Validate__Fixed64Rules *message,
                  void *closure_data);
typedef void (*Buf__Validate__SFixed32Rules_Closure)
                 (const Buf__Validate__SFixed32Rules *message,
                  void *closure_data);
typedef void (*Buf__Validate__SFixed64Rules_Closure)
                 (const Buf__Validate__SFixed64Rules *message,
                  void *closure_data);
typedef void (*Buf__Validate__BoolRules_Closure)
                 (const Buf__Validate__BoolRules *message,
                  void *closure_data);
typedef void (*Buf__Validate__StringRules_Closure)
                 (const Buf__Validate__StringRules *message,
                  void *closure_data);
typedef void (*Buf__Validate__BytesRules_Closure)
                 (const Buf__Validate__BytesRules *message,
                  void *closure_data);
typedef void (*Buf__Validate__EnumRules_Closure)
                 (const Buf__Validate__EnumRules *message,
                  void *closure_data);
typedef void (*Buf__Validate__RepeatedRules_Closure)
                 (const Buf__Validate__RepeatedRules *message,
                  void *closure_data);
typedef void (*Buf__Validate__MapRules_Closure)
                 (const Buf__Validate__MapRules *message,
                  void *closure_data);
typedef void (*Buf__Validate__AnyRules_Closure)
                 (const Buf__Validate__AnyRules *message,
                  void *closure_data);
typedef void (*Buf__Validate__DurationRules_Closure)
                 (const Buf__Validate__DurationRules *message,
                  void *closure_data);
typedef void (*Buf__Validate__TimestampRules_Closure)
                 (const Buf__Validate__TimestampRules *message,
                  void *closure_data);
typedef void (*Buf__Validate__Violations_Closure)
                 (const Buf__Validate__Violations *message,
                  void *closure_data);
typedef void (*Buf__Validate__Violation_Closure)
                 (const Buf__Validate__Violation *message,
                  void *closure_data);
typedef void (*Buf__Validate__FieldPath_Closure)
                 (const Buf__Validate__FieldPath *message,
                  void *closure_data);
typedef void (*Buf__Validate__FieldPathElement_Closure)
                 (const Buf__Validate__FieldPathElement *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    buf__validate__ignore__descriptor;
extern const ProtobufCEnumDescriptor    buf__validate__known_regex__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__rule__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__message_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__message_oneof_rule__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__oneof_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__field_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__predefined_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__float_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__double_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__int32_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__int64_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__uint32_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__uint64_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__sint32_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__sint64_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__fixed32_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__fixed64_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__sfixed32_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__sfixed64_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__bool_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__string_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__bytes_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__enum_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__repeated_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__map_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__any_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__duration_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__timestamp_rules__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__violations__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__violation__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__field_path__descriptor;
extern const ProtobufCMessageDescriptor buf__validate__field_path_element__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_buf_2fvalidate_2fvalidate_2eproto__INCLUDED */

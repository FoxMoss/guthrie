// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: buf/validate/validate.proto

#include "buf/validate/validate.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AnyRules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BoolRules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BytesRules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DoubleRules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_DurationRules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EnumRules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FieldPath_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FieldPathElement_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<20> scc_info_FieldRules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Fixed32Rules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Fixed64Rules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FloatRules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Int32Rules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Int64Rules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MessageOneofRule_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_MessageRules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_OneofRules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PredefinedRules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Rule_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SFixed32Rules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SFixed64Rules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SInt32Rules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SInt64Rules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StringRules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_TimestampRules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UInt32Rules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UInt64Rules_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Violation_buf_2fvalidate_2fvalidate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_google_2fprotobuf_2fduration_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Duration_google_2fprotobuf_2fduration_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_google_2fprotobuf_2ftimestamp_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Timestamp_google_2fprotobuf_2ftimestamp_2eproto;
namespace buf {
namespace validate {
class RuleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Rule> _instance;
} _Rule_default_instance_;
class MessageRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MessageRules> _instance;
} _MessageRules_default_instance_;
class MessageOneofRuleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MessageOneofRule> _instance;
} _MessageOneofRule_default_instance_;
class OneofRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<OneofRules> _instance;
} _OneofRules_default_instance_;
class FieldRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FieldRules> _instance;
  const ::buf::validate::FloatRules* float__;
  const ::buf::validate::DoubleRules* double__;
  const ::buf::validate::Int32Rules* int32_;
  const ::buf::validate::Int64Rules* int64_;
  const ::buf::validate::UInt32Rules* uint32_;
  const ::buf::validate::UInt64Rules* uint64_;
  const ::buf::validate::SInt32Rules* sint32_;
  const ::buf::validate::SInt64Rules* sint64_;
  const ::buf::validate::Fixed32Rules* fixed32_;
  const ::buf::validate::Fixed64Rules* fixed64_;
  const ::buf::validate::SFixed32Rules* sfixed32_;
  const ::buf::validate::SFixed64Rules* sfixed64_;
  const ::buf::validate::BoolRules* bool__;
  const ::buf::validate::StringRules* string_;
  const ::buf::validate::BytesRules* bytes_;
  const ::buf::validate::EnumRules* enum__;
  const ::buf::validate::RepeatedRules* repeated_;
  const ::buf::validate::MapRules* map_;
  const ::buf::validate::AnyRules* any_;
  const ::buf::validate::DurationRules* duration_;
  const ::buf::validate::TimestampRules* timestamp_;
} _FieldRules_default_instance_;
class PredefinedRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PredefinedRules> _instance;
} _PredefinedRules_default_instance_;
class FloatRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FloatRules> _instance;
  float lt_;
  float lte_;
  float gt_;
  float gte_;
} _FloatRules_default_instance_;
class DoubleRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DoubleRules> _instance;
  double lt_;
  double lte_;
  double gt_;
  double gte_;
} _DoubleRules_default_instance_;
class Int32RulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Int32Rules> _instance;
  ::PROTOBUF_NAMESPACE_ID::int32 lt_;
  ::PROTOBUF_NAMESPACE_ID::int32 lte_;
  ::PROTOBUF_NAMESPACE_ID::int32 gt_;
  ::PROTOBUF_NAMESPACE_ID::int32 gte_;
} _Int32Rules_default_instance_;
class Int64RulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Int64Rules> _instance;
  ::PROTOBUF_NAMESPACE_ID::int64 lt_;
  ::PROTOBUF_NAMESPACE_ID::int64 lte_;
  ::PROTOBUF_NAMESPACE_ID::int64 gt_;
  ::PROTOBUF_NAMESPACE_ID::int64 gte_;
} _Int64Rules_default_instance_;
class UInt32RulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UInt32Rules> _instance;
  ::PROTOBUF_NAMESPACE_ID::uint32 lt_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lte_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gt_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gte_;
} _UInt32Rules_default_instance_;
class UInt64RulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UInt64Rules> _instance;
  ::PROTOBUF_NAMESPACE_ID::uint64 lt_;
  ::PROTOBUF_NAMESPACE_ID::uint64 lte_;
  ::PROTOBUF_NAMESPACE_ID::uint64 gt_;
  ::PROTOBUF_NAMESPACE_ID::uint64 gte_;
} _UInt64Rules_default_instance_;
class SInt32RulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SInt32Rules> _instance;
  ::PROTOBUF_NAMESPACE_ID::int32 lt_;
  ::PROTOBUF_NAMESPACE_ID::int32 lte_;
  ::PROTOBUF_NAMESPACE_ID::int32 gt_;
  ::PROTOBUF_NAMESPACE_ID::int32 gte_;
} _SInt32Rules_default_instance_;
class SInt64RulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SInt64Rules> _instance;
  ::PROTOBUF_NAMESPACE_ID::int64 lt_;
  ::PROTOBUF_NAMESPACE_ID::int64 lte_;
  ::PROTOBUF_NAMESPACE_ID::int64 gt_;
  ::PROTOBUF_NAMESPACE_ID::int64 gte_;
} _SInt64Rules_default_instance_;
class Fixed32RulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Fixed32Rules> _instance;
  ::PROTOBUF_NAMESPACE_ID::uint32 lt_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lte_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gt_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gte_;
} _Fixed32Rules_default_instance_;
class Fixed64RulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Fixed64Rules> _instance;
  ::PROTOBUF_NAMESPACE_ID::uint64 lt_;
  ::PROTOBUF_NAMESPACE_ID::uint64 lte_;
  ::PROTOBUF_NAMESPACE_ID::uint64 gt_;
  ::PROTOBUF_NAMESPACE_ID::uint64 gte_;
} _Fixed64Rules_default_instance_;
class SFixed32RulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SFixed32Rules> _instance;
  ::PROTOBUF_NAMESPACE_ID::int32 lt_;
  ::PROTOBUF_NAMESPACE_ID::int32 lte_;
  ::PROTOBUF_NAMESPACE_ID::int32 gt_;
  ::PROTOBUF_NAMESPACE_ID::int32 gte_;
} _SFixed32Rules_default_instance_;
class SFixed64RulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SFixed64Rules> _instance;
  ::PROTOBUF_NAMESPACE_ID::int64 lt_;
  ::PROTOBUF_NAMESPACE_ID::int64 lte_;
  ::PROTOBUF_NAMESPACE_ID::int64 gt_;
  ::PROTOBUF_NAMESPACE_ID::int64 gte_;
} _SFixed64Rules_default_instance_;
class BoolRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BoolRules> _instance;
} _BoolRules_default_instance_;
class StringRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StringRules> _instance;
  bool email_;
  bool hostname_;
  bool ip_;
  bool ipv4_;
  bool ipv6_;
  bool uri_;
  bool uri_ref_;
  bool address_;
  bool uuid_;
  bool tuuid_;
  bool ip_with_prefixlen_;
  bool ipv4_with_prefixlen_;
  bool ipv6_with_prefixlen_;
  bool ip_prefix_;
  bool ipv4_prefix_;
  bool ipv6_prefix_;
  bool host_and_port_;
  int well_known_regex_;
} _StringRules_default_instance_;
class BytesRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BytesRules> _instance;
  bool ip_;
  bool ipv4_;
  bool ipv6_;
} _BytesRules_default_instance_;
class EnumRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EnumRules> _instance;
} _EnumRules_default_instance_;
class RepeatedRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RepeatedRules> _instance;
} _RepeatedRules_default_instance_;
class MapRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MapRules> _instance;
} _MapRules_default_instance_;
class AnyRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AnyRules> _instance;
} _AnyRules_default_instance_;
class DurationRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DurationRules> _instance;
  const PROTOBUF_NAMESPACE_ID::Duration* lt_;
  const PROTOBUF_NAMESPACE_ID::Duration* lte_;
  const PROTOBUF_NAMESPACE_ID::Duration* gt_;
  const PROTOBUF_NAMESPACE_ID::Duration* gte_;
} _DurationRules_default_instance_;
class TimestampRulesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TimestampRules> _instance;
  const PROTOBUF_NAMESPACE_ID::Timestamp* lt_;
  const PROTOBUF_NAMESPACE_ID::Timestamp* lte_;
  bool lt_now_;
  const PROTOBUF_NAMESPACE_ID::Timestamp* gt_;
  const PROTOBUF_NAMESPACE_ID::Timestamp* gte_;
  bool gt_now_;
} _TimestampRules_default_instance_;
class ViolationsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Violations> _instance;
} _Violations_default_instance_;
class ViolationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Violation> _instance;
} _Violation_default_instance_;
class FieldPathDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FieldPath> _instance;
} _FieldPath_default_instance_;
class FieldPathElementDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FieldPathElement> _instance;
  ::PROTOBUF_NAMESPACE_ID::uint64 index_;
  bool bool_key_;
  ::PROTOBUF_NAMESPACE_ID::int64 int_key_;
  ::PROTOBUF_NAMESPACE_ID::uint64 uint_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_key_;
} _FieldPathElement_default_instance_;
}  // namespace validate
}  // namespace buf
static void InitDefaultsscc_info_AnyRules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_AnyRules_default_instance_;
    new (ptr) ::buf::validate::AnyRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::AnyRules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AnyRules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AnyRules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_BoolRules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_BoolRules_default_instance_;
    new (ptr) ::buf::validate::BoolRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::BoolRules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BoolRules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_BoolRules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_BytesRules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_BytesRules_default_instance_;
    new (ptr) ::buf::validate::BytesRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::BytesRules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BytesRules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_BytesRules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_DoubleRules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_DoubleRules_default_instance_;
    new (ptr) ::buf::validate::DoubleRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::DoubleRules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DoubleRules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_DoubleRules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_DurationRules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_DurationRules_default_instance_;
    new (ptr) ::buf::validate::DurationRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::DurationRules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_DurationRules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_DurationRules_buf_2fvalidate_2fvalidate_2eproto}, {
      &scc_info_Duration_google_2fprotobuf_2fduration_2eproto.base,}};

static void InitDefaultsscc_info_EnumRules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_EnumRules_default_instance_;
    new (ptr) ::buf::validate::EnumRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::EnumRules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EnumRules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EnumRules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_FieldPath_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_FieldPath_default_instance_;
    new (ptr) ::buf::validate::FieldPath();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::FieldPath::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FieldPath_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_FieldPath_buf_2fvalidate_2fvalidate_2eproto}, {
      &scc_info_FieldPathElement_buf_2fvalidate_2fvalidate_2eproto.base,}};

static void InitDefaultsscc_info_FieldPathElement_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_FieldPathElement_default_instance_;
    new (ptr) ::buf::validate::FieldPathElement();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::FieldPathElement::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FieldPathElement_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_FieldPathElement_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_FieldRules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_FieldRules_default_instance_;
    new (ptr) ::buf::validate::FieldRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  {
    void* ptr = &::buf::validate::_RepeatedRules_default_instance_;
    new (ptr) ::buf::validate::RepeatedRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  {
    void* ptr = &::buf::validate::_MapRules_default_instance_;
    new (ptr) ::buf::validate::MapRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::FieldRules::InitAsDefaultInstance();
  ::buf::validate::RepeatedRules::InitAsDefaultInstance();
  ::buf::validate::MapRules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<20> scc_info_FieldRules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 20, 0, InitDefaultsscc_info_FieldRules_buf_2fvalidate_2fvalidate_2eproto}, {
      &scc_info_Rule_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_FloatRules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_DoubleRules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_Int32Rules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_Int64Rules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_UInt32Rules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_UInt64Rules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_SInt32Rules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_SInt64Rules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_Fixed32Rules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_Fixed64Rules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_SFixed32Rules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_SFixed64Rules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_BoolRules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_StringRules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_BytesRules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_EnumRules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_AnyRules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_DurationRules_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_TimestampRules_buf_2fvalidate_2fvalidate_2eproto.base,}};

static void InitDefaultsscc_info_Fixed32Rules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_Fixed32Rules_default_instance_;
    new (ptr) ::buf::validate::Fixed32Rules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::Fixed32Rules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Fixed32Rules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Fixed32Rules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_Fixed64Rules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_Fixed64Rules_default_instance_;
    new (ptr) ::buf::validate::Fixed64Rules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::Fixed64Rules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Fixed64Rules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Fixed64Rules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_FloatRules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_FloatRules_default_instance_;
    new (ptr) ::buf::validate::FloatRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::FloatRules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FloatRules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_FloatRules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_Int32Rules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_Int32Rules_default_instance_;
    new (ptr) ::buf::validate::Int32Rules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::Int32Rules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Int32Rules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Int32Rules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_Int64Rules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_Int64Rules_default_instance_;
    new (ptr) ::buf::validate::Int64Rules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::Int64Rules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Int64Rules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Int64Rules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_MessageOneofRule_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_MessageOneofRule_default_instance_;
    new (ptr) ::buf::validate::MessageOneofRule();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::MessageOneofRule::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MessageOneofRule_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_MessageOneofRule_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_MessageRules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_MessageRules_default_instance_;
    new (ptr) ::buf::validate::MessageRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::MessageRules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_MessageRules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_MessageRules_buf_2fvalidate_2fvalidate_2eproto}, {
      &scc_info_Rule_buf_2fvalidate_2fvalidate_2eproto.base,
      &scc_info_MessageOneofRule_buf_2fvalidate_2fvalidate_2eproto.base,}};

static void InitDefaultsscc_info_OneofRules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_OneofRules_default_instance_;
    new (ptr) ::buf::validate::OneofRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::OneofRules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_OneofRules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_OneofRules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_PredefinedRules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_PredefinedRules_default_instance_;
    new (ptr) ::buf::validate::PredefinedRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::PredefinedRules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PredefinedRules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_PredefinedRules_buf_2fvalidate_2fvalidate_2eproto}, {
      &scc_info_Rule_buf_2fvalidate_2fvalidate_2eproto.base,}};

static void InitDefaultsscc_info_Rule_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_Rule_default_instance_;
    new (ptr) ::buf::validate::Rule();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::Rule::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Rule_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Rule_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_SFixed32Rules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_SFixed32Rules_default_instance_;
    new (ptr) ::buf::validate::SFixed32Rules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::SFixed32Rules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SFixed32Rules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_SFixed32Rules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_SFixed64Rules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_SFixed64Rules_default_instance_;
    new (ptr) ::buf::validate::SFixed64Rules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::SFixed64Rules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SFixed64Rules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_SFixed64Rules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_SInt32Rules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_SInt32Rules_default_instance_;
    new (ptr) ::buf::validate::SInt32Rules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::SInt32Rules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SInt32Rules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_SInt32Rules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_SInt64Rules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_SInt64Rules_default_instance_;
    new (ptr) ::buf::validate::SInt64Rules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::SInt64Rules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SInt64Rules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_SInt64Rules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_StringRules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_StringRules_default_instance_;
    new (ptr) ::buf::validate::StringRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::StringRules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StringRules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StringRules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_TimestampRules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_TimestampRules_default_instance_;
    new (ptr) ::buf::validate::TimestampRules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::TimestampRules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_TimestampRules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_TimestampRules_buf_2fvalidate_2fvalidate_2eproto}, {
      &scc_info_Timestamp_google_2fprotobuf_2ftimestamp_2eproto.base,
      &scc_info_Duration_google_2fprotobuf_2fduration_2eproto.base,}};

static void InitDefaultsscc_info_UInt32Rules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_UInt32Rules_default_instance_;
    new (ptr) ::buf::validate::UInt32Rules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::UInt32Rules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UInt32Rules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_UInt32Rules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_UInt64Rules_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_UInt64Rules_default_instance_;
    new (ptr) ::buf::validate::UInt64Rules();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::UInt64Rules::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UInt64Rules_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_UInt64Rules_buf_2fvalidate_2fvalidate_2eproto}, {}};

static void InitDefaultsscc_info_Violation_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_Violation_default_instance_;
    new (ptr) ::buf::validate::Violation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::Violation::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Violation_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Violation_buf_2fvalidate_2fvalidate_2eproto}, {
      &scc_info_FieldPath_buf_2fvalidate_2fvalidate_2eproto.base,}};

static void InitDefaultsscc_info_Violations_buf_2fvalidate_2fvalidate_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::buf::validate::_Violations_default_instance_;
    new (ptr) ::buf::validate::Violations();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::buf::validate::Violations::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Violations_buf_2fvalidate_2fvalidate_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Violations_buf_2fvalidate_2fvalidate_2eproto}, {
      &scc_info_Violation_buf_2fvalidate_2fvalidate_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[31];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_buf_2fvalidate_2fvalidate_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_buf_2fvalidate_2fvalidate_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_buf_2fvalidate_2fvalidate_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::buf::validate::Rule, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Rule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::Rule, id_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Rule, message_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Rule, expression_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::buf::validate::MessageRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::MessageRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::MessageRules, disabled_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::MessageRules, cel_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::MessageRules, oneof_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::MessageOneofRule, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::MessageOneofRule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::MessageOneofRule, fields_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::MessageOneofRule, required_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::buf::validate::OneofRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::OneofRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::OneofRules, required_),
  0,
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldRules, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldRules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldRules, cel_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldRules, required_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldRules, ignore_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, float__),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, double__),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, int32_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, int64_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, uint32_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, uint64_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, sint32_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, sint64_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, fixed32_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, fixed64_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, sfixed32_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, sfixed64_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, bool__),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, string_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, bytes_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, enum__),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, repeated_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, map_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, any_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, duration_),
  offsetof(::buf::validate::FieldRulesDefaultTypeInternal, timestamp_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldRules, type_),
  ~0u,
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::buf::validate::PredefinedRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::PredefinedRules, cel_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, const__),
  offsetof(::buf::validate::FloatRulesDefaultTypeInternal, lt_),
  offsetof(::buf::validate::FloatRulesDefaultTypeInternal, lte_),
  offsetof(::buf::validate::FloatRulesDefaultTypeInternal, gt_),
  offsetof(::buf::validate::FloatRulesDefaultTypeInternal, gte_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, not_in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, finite_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, less_than_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, greater_than_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, const__),
  offsetof(::buf::validate::DoubleRulesDefaultTypeInternal, lt_),
  offsetof(::buf::validate::DoubleRulesDefaultTypeInternal, lte_),
  offsetof(::buf::validate::DoubleRulesDefaultTypeInternal, gt_),
  offsetof(::buf::validate::DoubleRulesDefaultTypeInternal, gte_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, not_in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, finite_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, less_than_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, greater_than_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, const__),
  offsetof(::buf::validate::Int32RulesDefaultTypeInternal, lt_),
  offsetof(::buf::validate::Int32RulesDefaultTypeInternal, lte_),
  offsetof(::buf::validate::Int32RulesDefaultTypeInternal, gt_),
  offsetof(::buf::validate::Int32RulesDefaultTypeInternal, gte_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, not_in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, less_than_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, greater_than_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, const__),
  offsetof(::buf::validate::Int64RulesDefaultTypeInternal, lt_),
  offsetof(::buf::validate::Int64RulesDefaultTypeInternal, lte_),
  offsetof(::buf::validate::Int64RulesDefaultTypeInternal, gt_),
  offsetof(::buf::validate::Int64RulesDefaultTypeInternal, gte_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, not_in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, less_than_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, greater_than_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, const__),
  offsetof(::buf::validate::UInt32RulesDefaultTypeInternal, lt_),
  offsetof(::buf::validate::UInt32RulesDefaultTypeInternal, lte_),
  offsetof(::buf::validate::UInt32RulesDefaultTypeInternal, gt_),
  offsetof(::buf::validate::UInt32RulesDefaultTypeInternal, gte_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, not_in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, less_than_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, greater_than_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, const__),
  offsetof(::buf::validate::UInt64RulesDefaultTypeInternal, lt_),
  offsetof(::buf::validate::UInt64RulesDefaultTypeInternal, lte_),
  offsetof(::buf::validate::UInt64RulesDefaultTypeInternal, gt_),
  offsetof(::buf::validate::UInt64RulesDefaultTypeInternal, gte_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, not_in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, less_than_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, greater_than_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, const__),
  offsetof(::buf::validate::SInt32RulesDefaultTypeInternal, lt_),
  offsetof(::buf::validate::SInt32RulesDefaultTypeInternal, lte_),
  offsetof(::buf::validate::SInt32RulesDefaultTypeInternal, gt_),
  offsetof(::buf::validate::SInt32RulesDefaultTypeInternal, gte_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, not_in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, less_than_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, greater_than_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, const__),
  offsetof(::buf::validate::SInt64RulesDefaultTypeInternal, lt_),
  offsetof(::buf::validate::SInt64RulesDefaultTypeInternal, lte_),
  offsetof(::buf::validate::SInt64RulesDefaultTypeInternal, gt_),
  offsetof(::buf::validate::SInt64RulesDefaultTypeInternal, gte_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, not_in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, less_than_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, greater_than_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, const__),
  offsetof(::buf::validate::Fixed32RulesDefaultTypeInternal, lt_),
  offsetof(::buf::validate::Fixed32RulesDefaultTypeInternal, lte_),
  offsetof(::buf::validate::Fixed32RulesDefaultTypeInternal, gt_),
  offsetof(::buf::validate::Fixed32RulesDefaultTypeInternal, gte_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, not_in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, less_than_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, greater_than_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, const__),
  offsetof(::buf::validate::Fixed64RulesDefaultTypeInternal, lt_),
  offsetof(::buf::validate::Fixed64RulesDefaultTypeInternal, lte_),
  offsetof(::buf::validate::Fixed64RulesDefaultTypeInternal, gt_),
  offsetof(::buf::validate::Fixed64RulesDefaultTypeInternal, gte_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, not_in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, less_than_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, greater_than_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, const__),
  offsetof(::buf::validate::SFixed32RulesDefaultTypeInternal, lt_),
  offsetof(::buf::validate::SFixed32RulesDefaultTypeInternal, lte_),
  offsetof(::buf::validate::SFixed32RulesDefaultTypeInternal, gt_),
  offsetof(::buf::validate::SFixed32RulesDefaultTypeInternal, gte_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, not_in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, less_than_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, greater_than_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, const__),
  offsetof(::buf::validate::SFixed64RulesDefaultTypeInternal, lt_),
  offsetof(::buf::validate::SFixed64RulesDefaultTypeInternal, lte_),
  offsetof(::buf::validate::SFixed64RulesDefaultTypeInternal, gt_),
  offsetof(::buf::validate::SFixed64RulesDefaultTypeInternal, gte_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, not_in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, less_than_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, greater_than_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::BoolRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BoolRules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BoolRules, _extensions_),
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::BoolRules, const__),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BoolRules, example_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, const__),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, len_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, min_len_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, max_len_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, len_bytes_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, min_bytes_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, max_bytes_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, pattern_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, prefix_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, suffix_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, contains_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, not_contains_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, not_in_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, email_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, hostname_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, ip_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, ipv4_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, ipv6_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, uri_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, uri_ref_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, address_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, uuid_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, tuuid_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, ip_with_prefixlen_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, ipv4_with_prefixlen_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, ipv6_with_prefixlen_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, ip_prefix_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, ipv4_prefix_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, ipv6_prefix_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, host_and_port_),
  offsetof(::buf::validate::StringRulesDefaultTypeInternal, well_known_regex_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, strict_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, well_known_),
  0,
  11,
  6,
  7,
  12,
  8,
  9,
  1,
  2,
  3,
  4,
  5,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  10,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, const__),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, len_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, min_len_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, max_len_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, pattern_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, prefix_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, suffix_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, contains_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, not_in_),
  offsetof(::buf::validate::BytesRulesDefaultTypeInternal, ip_),
  offsetof(::buf::validate::BytesRulesDefaultTypeInternal, ipv4_),
  offsetof(::buf::validate::BytesRulesDefaultTypeInternal, ipv6_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, well_known_),
  0,
  7,
  5,
  6,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _extensions_),
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, const__),
  PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, defined_only_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, not_in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, example_),
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _extensions_),
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, min_items_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, max_items_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, unique_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, items_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _extensions_),
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, min_pairs_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, max_pairs_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, keys_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, values_),
  2,
  3,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::buf::validate::AnyRules, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::AnyRules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::AnyRules, not_in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, const__),
  offsetof(::buf::validate::DurationRulesDefaultTypeInternal, lt_),
  offsetof(::buf::validate::DurationRulesDefaultTypeInternal, lte_),
  offsetof(::buf::validate::DurationRulesDefaultTypeInternal, gt_),
  offsetof(::buf::validate::DurationRulesDefaultTypeInternal, gte_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, not_in_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, less_than_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, greater_than_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _extensions_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, const__),
  offsetof(::buf::validate::TimestampRulesDefaultTypeInternal, lt_),
  offsetof(::buf::validate::TimestampRulesDefaultTypeInternal, lte_),
  offsetof(::buf::validate::TimestampRulesDefaultTypeInternal, lt_now_),
  offsetof(::buf::validate::TimestampRulesDefaultTypeInternal, gt_),
  offsetof(::buf::validate::TimestampRulesDefaultTypeInternal, gte_),
  offsetof(::buf::validate::TimestampRulesDefaultTypeInternal, gt_now_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, within_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, example_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, less_than_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, greater_than_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  1,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::buf::validate::Violations, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::Violations, violations_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Violation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Violation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::Violation, field_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Violation, rule_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Violation, rule_id_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Violation, message_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::Violation, for_key_),
  2,
  3,
  0,
  1,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldPath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldPath, elements_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldPathElement, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldPathElement, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldPathElement, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldPathElement, field_number_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldPathElement, field_name_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldPathElement, field_type_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldPathElement, key_type_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldPathElement, value_type_),
  offsetof(::buf::validate::FieldPathElementDefaultTypeInternal, index_),
  offsetof(::buf::validate::FieldPathElementDefaultTypeInternal, bool_key_),
  offsetof(::buf::validate::FieldPathElementDefaultTypeInternal, int_key_),
  offsetof(::buf::validate::FieldPathElementDefaultTypeInternal, uint_key_),
  offsetof(::buf::validate::FieldPathElementDefaultTypeInternal, string_key_),
  PROTOBUF_FIELD_OFFSET(::buf::validate::FieldPathElement, subscript_),
  1,
  0,
  3,
  4,
  2,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::buf::validate::Rule)},
  { 11, 19, sizeof(::buf::validate::MessageRules)},
  { 22, 29, sizeof(::buf::validate::MessageOneofRule)},
  { 31, 37, sizeof(::buf::validate::OneofRules)},
  { 38, 68, sizeof(::buf::validate::FieldRules)},
  { 92, -1, sizeof(::buf::validate::PredefinedRules)},
  { 98, 114, sizeof(::buf::validate::FloatRules)},
  { 123, 139, sizeof(::buf::validate::DoubleRules)},
  { 148, 163, sizeof(::buf::validate::Int32Rules)},
  { 171, 186, sizeof(::buf::validate::Int64Rules)},
  { 194, 209, sizeof(::buf::validate::UInt32Rules)},
  { 217, 232, sizeof(::buf::validate::UInt64Rules)},
  { 240, 255, sizeof(::buf::validate::SInt32Rules)},
  { 263, 278, sizeof(::buf::validate::SInt64Rules)},
  { 286, 301, sizeof(::buf::validate::Fixed32Rules)},
  { 309, 324, sizeof(::buf::validate::Fixed64Rules)},
  { 332, 347, sizeof(::buf::validate::SFixed32Rules)},
  { 355, 370, sizeof(::buf::validate::SFixed64Rules)},
  { 378, 385, sizeof(::buf::validate::BoolRules)},
  { 387, 427, sizeof(::buf::validate::StringRules)},
  { 461, 481, sizeof(::buf::validate::BytesRules)},
  { 495, 505, sizeof(::buf::validate::EnumRules)},
  { 510, 519, sizeof(::buf::validate::RepeatedRules)},
  { 523, 532, sizeof(::buf::validate::MapRules)},
  { 536, -1, sizeof(::buf::validate::AnyRules)},
  { 543, 558, sizeof(::buf::validate::DurationRules)},
  { 566, 582, sizeof(::buf::validate::TimestampRules)},
  { 591, -1, sizeof(::buf::validate::Violations)},
  { 597, 607, sizeof(::buf::validate::Violation)},
  { 612, -1, sizeof(::buf::validate::FieldPath)},
  { 618, 634, sizeof(::buf::validate::FieldPathElement)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_Rule_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_MessageRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_MessageOneofRule_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_OneofRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_FieldRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_PredefinedRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_FloatRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_DoubleRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_Int32Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_Int64Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_UInt32Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_UInt64Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_SInt32Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_SInt64Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_Fixed32Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_Fixed64Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_SFixed32Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_SFixed64Rules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_BoolRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_StringRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_BytesRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_EnumRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_RepeatedRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_MapRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_AnyRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_DurationRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_TimestampRules_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_Violations_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_Violation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_FieldPath_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::buf::validate::_FieldPathElement_default_instance_),
};

const char descriptor_table_protodef_buf_2fvalidate_2fvalidate_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\033buf/validate/validate.proto\022\014buf.valid"
  "ate\032 google/protobuf/descriptor.proto\032\036g"
  "oogle/protobuf/duration.proto\032\037google/pr"
  "otobuf/timestamp.proto\"P\n\004Rule\022\016\n\002id\030\001 \001"
  "(\tR\002id\022\030\n\007message\030\002 \001(\tR\007message\022\036\n\nexpr"
  "ession\030\003 \001(\tR\nexpression\"\206\001\n\014MessageRule"
  "s\022\032\n\010disabled\030\001 \001(\010R\010disabled\022$\n\003cel\030\003 \003"
  "(\0132\022.buf.validate.RuleR\003cel\0224\n\005oneof\030\004 \003"
  "(\0132\036.buf.validate.MessageOneofRuleR\005oneo"
  "f\"F\n\020MessageOneofRule\022\026\n\006fields\030\001 \003(\tR\006f"
  "ields\022\032\n\010required\030\002 \001(\010R\010required\"(\n\nOne"
  "ofRules\022\032\n\010required\030\001 \001(\010R\010required\"\375\t\n\n"
  "FieldRules\022$\n\003cel\030\027 \003(\0132\022.buf.validate.R"
  "uleR\003cel\022\032\n\010required\030\031 \001(\010R\010required\022,\n\006"
  "ignore\030\033 \001(\0162\024.buf.validate.IgnoreR\006igno"
  "re\0220\n\005float\030\001 \001(\0132\030.buf.validate.FloatRu"
  "lesH\000R\005float\0223\n\006double\030\002 \001(\0132\031.buf.valid"
  "ate.DoubleRulesH\000R\006double\0220\n\005int32\030\003 \001(\013"
  "2\030.buf.validate.Int32RulesH\000R\005int32\0220\n\005i"
  "nt64\030\004 \001(\0132\030.buf.validate.Int64RulesH\000R\005"
  "int64\0223\n\006uint32\030\005 \001(\0132\031.buf.validate.UIn"
  "t32RulesH\000R\006uint32\0223\n\006uint64\030\006 \001(\0132\031.buf"
  ".validate.UInt64RulesH\000R\006uint64\0223\n\006sint3"
  "2\030\007 \001(\0132\031.buf.validate.SInt32RulesH\000R\006si"
  "nt32\0223\n\006sint64\030\010 \001(\0132\031.buf.validate.SInt"
  "64RulesH\000R\006sint64\0226\n\007fixed32\030\t \001(\0132\032.buf"
  ".validate.Fixed32RulesH\000R\007fixed32\0226\n\007fix"
  "ed64\030\n \001(\0132\032.buf.validate.Fixed64RulesH\000"
  "R\007fixed64\0229\n\010sfixed32\030\013 \001(\0132\033.buf.valida"
  "te.SFixed32RulesH\000R\010sfixed32\0229\n\010sfixed64"
  "\030\014 \001(\0132\033.buf.validate.SFixed64RulesH\000R\010s"
  "fixed64\022-\n\004bool\030\r \001(\0132\027.buf.validate.Boo"
  "lRulesH\000R\004bool\0223\n\006string\030\016 \001(\0132\031.buf.val"
  "idate.StringRulesH\000R\006string\0220\n\005bytes\030\017 \001"
  "(\0132\030.buf.validate.BytesRulesH\000R\005bytes\022-\n"
  "\004enum\030\020 \001(\0132\027.buf.validate.EnumRulesH\000R\004"
  "enum\0229\n\010repeated\030\022 \001(\0132\033.buf.validate.Re"
  "peatedRulesH\000R\010repeated\022*\n\003map\030\023 \001(\0132\026.b"
  "uf.validate.MapRulesH\000R\003map\022*\n\003any\030\024 \001(\013"
  "2\026.buf.validate.AnyRulesH\000R\003any\0229\n\010durat"
  "ion\030\025 \001(\0132\033.buf.validate.DurationRulesH\000"
  "R\010duration\022<\n\ttimestamp\030\026 \001(\0132\034.buf.vali"
  "date.TimestampRulesH\000R\ttimestampB\006\n\004type"
  "J\004\010\030\020\031J\004\010\032\020\033R\007skippedR\014ignore_empty\"X\n\017P"
  "redefinedRules\022$\n\003cel\030\001 \003(\0132\022.buf.valida"
  "te.RuleR\003celJ\004\010\030\020\031J\004\010\032\020\033R\023skippedignore_"
  "empty\"\220\030\n\nFloatRules\022\212\001\n\005const\030\001 \001(\002Bt\302H"
  "q\no\n\013float.const\032`this != getField(rules"
  ", \'const\') \? \'value must equal %s\'.forma"
  "t([getField(rules, \'const\')]) : \'\'R\005cons"
  "t\022\243\001\n\002lt\030\002 \001(\002B\220\001\302H\214\001\n\211\001\n\010float.lt\032}!has"
  "(rules.gte) && !has(rules.gt) && (this.i"
  "sNan() || this >= rules.lt)\? \'value must"
  " be less than %s\'.format([rules.lt]) : \'"
  "\'H\000R\002lt\022\264\001\n\003lte\030\003 \001(\002B\237\001\302H\233\001\n\230\001\n\tfloat.l"
  "te\032\212\001!has(rules.gte) && !has(rules.gt) &"
  "& (this.isNan() || this > rules.lte)\? \'v"
  "alue must be less than or equal to %s\'.f"
  "ormat([rules.lte]) : \'\'H\000R\003lte\022\363\007\n\002gt\030\004 "
  "\001(\002B\340\007\302H\334\007\n\215\001\n\010float.gt\032\200\001!has(rules.lt)"
  " && !has(rules.lte) && (this.isNan() || "
  "this <= rules.gt)\? \'value must be greate"
  "r than %s\'.format([rules.gt]) : \'\'\n\303\001\n\013f"
  "loat.gt_lt\032\263\001has(rules.lt) && rules.lt >"
  "= rules.gt && (this.isNan() || this >= r"
  "ules.lt || this <= rules.gt)\? \'value mus"
  "t be greater than %s and less than %s\'.f"
  "ormat([rules.gt, rules.lt]) : \'\'\n\315\001\n\025flo"
  "at.gt_lt_exclusive\032\263\001has(rules.lt) && ru"
  "les.lt < rules.gt && (this.isNan() || (r"
  "ules.lt <= this && this <= rules.gt))\? \'"
  "value must be greater than %s or less th"
  "an %s\'.format([rules.gt, rules.lt]) : \'\'"
  "\n\323\001\n\014float.gt_lte\032\302\001has(rules.lte) && ru"
  "les.lte >= rules.gt && (this.isNan() || "
  "this > rules.lte || this <= rules.gt)\? \'"
  "value must be greater than %s and less t"
  "han or equal to %s\'.format([rules.gt, ru"
  "les.lte]) : \'\'\n\335\001\n\026float.gt_lte_exclusiv"
  "e\032\302\001has(rules.lte) && rules.lte < rules."
  "gt && (this.isNan() || (rules.lte < this"
  " && this <= rules.gt))\? \'value must be g"
  "reater than %s or less than or equal to "
  "%s\'.format([rules.gt, rules.lte]) : \'\'H\001"
  "R\002gt\022\277\010\n\003gte\030\005 \001(\002B\252\010\302H\246\010\n\233\001\n\tfloat.gte\032"
  "\215\001!has(rules.lt) && !has(rules.lte) && ("
  "this.isNan() || this < rules.gte)\? \'valu"
  "e must be greater than or equal to %s\'.f"
  "ormat([rules.gte]) : \'\'\n\322\001\n\014float.gte_lt"
  "\032\301\001has(rules.lt) && rules.lt >= rules.gt"
  "e && (this.isNan() || this >= rules.lt |"
  "| this < rules.gte)\? \'value must be grea"
  "ter than or equal to %s and less than %s"
  "\'.format([rules.gte, rules.lt]) : \'\'\n\334\001\n"
  "\026float.gte_lt_exclusive\032\301\001has(rules.lt) "
  "&& rules.lt < rules.gte && (this.isNan()"
  " || (rules.lt <= this && this < rules.gt"
  "e))\? \'value must be greater than or equa"
  "l to %s or less than %s\'.format([rules.g"
  "te, rules.lt]) : \'\'\n\342\001\n\rfloat.gte_lte\032\320\001"
  "has(rules.lte) && rules.lte >= rules.gte"
  " && (this.isNan() || this > rules.lte ||"
  " this < rules.gte)\? \'value must be great"
  "er than or equal to %s and less than or "
  "equal to %s\'.format([rules.gte, rules.lt"
  "e]) : \'\'\n\354\001\n\027float.gte_lte_exclusive\032\320\001h"
  "as(rules.lte) && rules.lte < rules.gte &"
  "& (this.isNan() || (rules.lte < this && "
  "this < rules.gte))\? \'value must be great"
  "er than or equal to %s or less than or e"
  "qual to %s\'.format([rules.gte, rules.lte"
  "]) : \'\'H\001R\003gte\022\203\001\n\002in\030\006 \003(\002Bs\302Hp\nn\n\010floa"
  "t.in\032b!(this in getField(rules, \'in\')) \?"
  " \'value must be in list %s\'.format([getF"
  "ield(rules, \'in\')]) : \'\'R\002in\022}\n\006not_in\030\007"
  " \003(\002Bf\302Hc\na\n\014float.not_in\032Qthis in rules"
  ".not_in \? \'value must not be in list %s\'"
  ".format([rules.not_in]) : \'\'R\005notIn\022}\n\006f"
  "inite\030\010 \001(\010Be\302Hb\n`\n\014float.finite\032Prules."
  "finite \? (this.isNan() || this.isInf() \?"
  " \'value must be finite\' : \'\') : \'\'R\006fini"
  "te\0224\n\007example\030\t \003(\002B\032\302H\027\n\025\n\rfloat.exampl"
  "e\032\004trueR\007example*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_than"
  "B\016\n\014greater_than\"\242\030\n\013DoubleRules\022\213\001\n\005con"
  "st\030\001 \001(\001Bu\302Hr\np\n\014double.const\032`this != g"
  "etField(rules, \'const\') \? \'value must eq"
  "ual %s\'.format([getField(rules, \'const\')"
  "]) : \'\'R\005const\022\244\001\n\002lt\030\002 \001(\001B\221\001\302H\215\001\n\212\001\n\td"
  "ouble.lt\032}!has(rules.gte) && !has(rules."
  "gt) && (this.isNan() || this >= rules.lt"
  ")\? \'value must be less than %s\'.format(["
  "rules.lt]) : \'\'H\000R\002lt\022\265\001\n\003lte\030\003 \001(\001B\240\001\302H"
  "\234\001\n\231\001\n\ndouble.lte\032\212\001!has(rules.gte) && !"
  "has(rules.gt) && (this.isNan() || this >"
  " rules.lte)\? \'value must be less than or"
  " equal to %s\'.format([rules.lte]) : \'\'H\000"
  "R\003lte\022\370\007\n\002gt\030\004 \001(\001B\345\007\302H\341\007\n\216\001\n\tdouble.gt\032"
  "\200\001!has(rules.lt) && !has(rules.lte) && ("
  "this.isNan() || this <= rules.gt)\? \'valu"
  "e must be greater than %s\'.format([rules"
  ".gt]) : \'\'\n\304\001\n\014double.gt_lt\032\263\001has(rules."
  "lt) && rules.lt >= rules.gt && (this.isN"
  "an() || this >= rules.lt || this <= rule"
  "s.gt)\? \'value must be greater than %s an"
  "d less than %s\'.format([rules.gt, rules."
  "lt]) : \'\'\n\316\001\n\026double.gt_lt_exclusive\032\263\001h"
  "as(rules.lt) && rules.lt < rules.gt && ("
  "this.isNan() || (rules.lt <= this && thi"
  "s <= rules.gt))\? \'value must be greater "
  "than %s or less than %s\'.format([rules.g"
  "t, rules.lt]) : \'\'\n\324\001\n\rdouble.gt_lte\032\302\001h"
  "as(rules.lte) && rules.lte >= rules.gt &"
  "& (this.isNan() || this > rules.lte || t"
  "his <= rules.gt)\? \'value must be greater"
  " than %s and less than or equal to %s\'.f"
  "ormat([rules.gt, rules.lte]) : \'\'\n\336\001\n\027do"
  "uble.gt_lte_exclusive\032\302\001has(rules.lte) &"
  "& rules.lte < rules.gt && (this.isNan() "
  "|| (rules.lte < this && this <= rules.gt"
  "))\? \'value must be greater than %s or le"
  "ss than or equal to %s\'.format([rules.gt"
  ", rules.lte]) : \'\'H\001R\002gt\022\304\010\n\003gte\030\005 \001(\001B\257"
  "\010\302H\253\010\n\234\001\n\ndouble.gte\032\215\001!has(rules.lt) &&"
  " !has(rules.lte) && (this.isNan() || thi"
  "s < rules.gte)\? \'value must be greater t"
  "han or equal to %s\'.format([rules.gte]) "
  ": \'\'\n\323\001\n\rdouble.gte_lt\032\301\001has(rules.lt) &"
  "& rules.lt >= rules.gte && (this.isNan()"
  " || this >= rules.lt || this < rules.gte"
  ")\? \'value must be greater than or equal "
  "to %s and less than %s\'.format([rules.gt"
  "e, rules.lt]) : \'\'\n\335\001\n\027double.gte_lt_exc"
  "lusive\032\301\001has(rules.lt) && rules.lt < rul"
  "es.gte && (this.isNan() || (rules.lt <= "
  "this && this < rules.gte))\? \'value must "
  "be greater than or equal to %s or less t"
  "han %s\'.format([rules.gte, rules.lt]) : "
  "\'\'\n\343\001\n\016double.gte_lte\032\320\001has(rules.lte) &"
  "& rules.lte >= rules.gte && (this.isNan("
  ") || this > rules.lte || this < rules.gt"
  "e)\? \'value must be greater than or equal"
  " to %s and less than or equal to %s\'.for"
  "mat([rules.gte, rules.lte]) : \'\'\n\355\001\n\030dou"
  "ble.gte_lte_exclusive\032\320\001has(rules.lte) &"
  "& rules.lte < rules.gte && (this.isNan()"
  " || (rules.lte < this && this < rules.gt"
  "e))\? \'value must be greater than or equa"
  "l to %s or less than or equal to %s\'.for"
  "mat([rules.gte, rules.lte]) : \'\'H\001R\003gte\022"
  "\204\001\n\002in\030\006 \003(\001Bt\302Hq\no\n\tdouble.in\032b!(this i"
  "n getField(rules, \'in\')) \? \'value must b"
  "e in list %s\'.format([getField(rules, \'i"
  "n\')]) : \'\'R\002in\022~\n\006not_in\030\007 \003(\001Bg\302Hd\nb\n\rd"
  "ouble.not_in\032Qthis in rules.not_in \? \'va"
  "lue must not be in list %s\'.format([rule"
  "s.not_in]) : \'\'R\005notIn\022~\n\006finite\030\010 \001(\010Bf"
  "\302Hc\na\n\rdouble.finite\032Prules.finite \? (th"
  "is.isNan() || this.isInf() \? \'value must"
  " be finite\' : \'\') : \'\'R\006finite\0225\n\007exampl"
  "e\030\t \003(\001B\033\302H\030\n\026\n\016double.example\032\004trueR\007ex"
  "ample*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB\016\n\014greater"
  "_than\"\272\025\n\nInt32Rules\022\212\001\n\005const\030\001 \001(\005Bt\302H"
  "q\no\n\013int32.const\032`this != getField(rules"
  ", \'const\') \? \'value must equal %s\'.forma"
  "t([getField(rules, \'const\')]) : \'\'R\005cons"
  "t\022\216\001\n\002lt\030\002 \001(\005B|\302Hy\nw\n\010int32.lt\032k!has(ru"
  "les.gte) && !has(rules.gt) && this >= ru"
  "les.lt\? \'value must be less than %s\'.for"
  "mat([rules.lt]) : \'\'H\000R\002lt\022\241\001\n\003lte\030\003 \001(\005"
  "B\214\001\302H\210\001\n\205\001\n\tint32.lte\032x!has(rules.gte) &"
  "& !has(rules.gt) && this > rules.lte\? \'v"
  "alue must be less than or equal to %s\'.f"
  "ormat([rules.lte]) : \'\'H\000R\003lte\022\233\007\n\002gt\030\004 "
  "\001(\005B\210\007\302H\204\007\nz\n\010int32.gt\032n!has(rules.lt) &"
  "& !has(rules.lte) && this <= rules.gt\? \'"
  "value must be greater than %s\'.format([r"
  "ules.gt]) : \'\'\n\263\001\n\013int32.gt_lt\032\243\001has(rul"
  "es.lt) && rules.lt >= rules.gt && (this "
  ">= rules.lt || this <= rules.gt)\? \'value"
  " must be greater than %s and less than %"
  "s\'.format([rules.gt, rules.lt]) : \'\'\n\273\001\n"
  "\025int32.gt_lt_exclusive\032\241\001has(rules.lt) &"
  "& rules.lt < rules.gt && (rules.lt <= th"
  "is && this <= rules.gt)\? \'value must be "
  "greater than %s or less than %s\'.format("
  "[rules.gt, rules.lt]) : \'\'\n\303\001\n\014int32.gt_"
  "lte\032\262\001has(rules.lte) && rules.lte >= rul"
  "es.gt && (this > rules.lte || this <= ru"
  "les.gt)\? \'value must be greater than %s "
  "and less than or equal to %s\'.format([ru"
  "les.gt, rules.lte]) : \'\'\n\313\001\n\026int32.gt_lt"
  "e_exclusive\032\260\001has(rules.lte) && rules.lt"
  "e < rules.gt && (rules.lte < this && thi"
  "s <= rules.gt)\? \'value must be greater t"
  "han %s or less than or equal to %s\'.form"
  "at([rules.gt, rules.lte]) : \'\'H\001R\002gt\022\350\007\n"
  "\003gte\030\005 \001(\005B\323\007\302H\317\007\n\210\001\n\tint32.gte\032{!has(ru"
  "les.lt) && !has(rules.lte) && this < rul"
  "es.gte\? \'value must be greater than or e"
  "qual to %s\'.format([rules.gte]) : \'\'\n\302\001\n"
  "\014int32.gte_lt\032\261\001has(rules.lt) && rules.l"
  "t >= rules.gte && (this >= rules.lt || t"
  "his < rules.gte)\? \'value must be greater"
  " than or equal to %s and less than %s\'.f"
  "ormat([rules.gte, rules.lt]) : \'\'\n\312\001\n\026in"
  "t32.gte_lt_exclusive\032\257\001has(rules.lt) && "
  "rules.lt < rules.gte && (rules.lt <= thi"
  "s && this < rules.gte)\? \'value must be g"
  "reater than or equal to %s or less than "
  "%s\'.format([rules.gte, rules.lt]) : \'\'\n\322"
  "\001\n\rint32.gte_lte\032\300\001has(rules.lte) && rul"
  "es.lte >= rules.gte && (this > rules.lte"
  " || this < rules.gte)\? \'value must be gr"
  "eater than or equal to %s and less than "
  "or equal to %s\'.format([rules.gte, rules"
  ".lte]) : \'\'\n\332\001\n\027int32.gte_lte_exclusive\032"
  "\276\001has(rules.lte) && rules.lte < rules.gt"
  "e && (rules.lte < this && this < rules.g"
  "te)\? \'value must be greater than or equa"
  "l to %s or less than or equal to %s\'.for"
  "mat([rules.gte, rules.lte]) : \'\'H\001R\003gte\022"
  "\203\001\n\002in\030\006 \003(\005Bs\302Hp\nn\n\010int32.in\032b!(this in"
  " getField(rules, \'in\')) \? \'value must be"
  " in list %s\'.format([getField(rules, \'in"
  "\')]) : \'\'R\002in\022}\n\006not_in\030\007 \003(\005Bf\302Hc\na\n\014in"
  "t32.not_in\032Qthis in rules.not_in \? \'valu"
  "e must not be in list %s\'.format([rules."
  "not_in]) : \'\'R\005notIn\0224\n\007example\030\010 \003(\005B\032\302"
  "H\027\n\025\n\rint32.example\032\004trueR\007example*\t\010\350\007\020"
  "\200\200\200\200\002B\013\n\tless_thanB\016\n\014greater_than\"\272\025\n\nI"
  "nt64Rules\022\212\001\n\005const\030\001 \001(\003Bt\302Hq\no\n\013int64."
  "const\032`this != getField(rules, \'const\') "
  "\? \'value must equal %s\'.format([getField"
  "(rules, \'const\')]) : \'\'R\005const\022\216\001\n\002lt\030\002 "
  "\001(\003B|\302Hy\nw\n\010int64.lt\032k!has(rules.gte) &&"
  " !has(rules.gt) && this >= rules.lt\? \'va"
  "lue must be less than %s\'.format([rules."
  "lt]) : \'\'H\000R\002lt\022\241\001\n\003lte\030\003 \001(\003B\214\001\302H\210\001\n\205\001\n"
  "\tint64.lte\032x!has(rules.gte) && !has(rule"
  "s.gt) && this > rules.lte\? \'value must b"
  "e less than or equal to %s\'.format([rule"
  "s.lte]) : \'\'H\000R\003lte\022\233\007\n\002gt\030\004 \001(\003B\210\007\302H\204\007\n"
  "z\n\010int64.gt\032n!has(rules.lt) && !has(rule"
  "s.lte) && this <= rules.gt\? \'value must "
  "be greater than %s\'.format([rules.gt]) :"
  " \'\'\n\263\001\n\013int64.gt_lt\032\243\001has(rules.lt) && r"
  "ules.lt >= rules.gt && (this >= rules.lt"
  " || this <= rules.gt)\? \'value must be gr"
  "eater than %s and less than %s\'.format(["
  "rules.gt, rules.lt]) : \'\'\n\273\001\n\025int64.gt_l"
  "t_exclusive\032\241\001has(rules.lt) && rules.lt "
  "< rules.gt && (rules.lt <= this && this "
  "<= rules.gt)\? \'value must be greater tha"
  "n %s or less than %s\'.format([rules.gt, "
  "rules.lt]) : \'\'\n\303\001\n\014int64.gt_lte\032\262\001has(r"
  "ules.lte) && rules.lte >= rules.gt && (t"
  "his > rules.lte || this <= rules.gt)\? \'v"
  "alue must be greater than %s and less th"
  "an or equal to %s\'.format([rules.gt, rul"
  "es.lte]) : \'\'\n\313\001\n\026int64.gt_lte_exclusive"
  "\032\260\001has(rules.lte) && rules.lte < rules.g"
  "t && (rules.lte < this && this <= rules."
  "gt)\? \'value must be greater than %s or l"
  "ess than or equal to %s\'.format([rules.g"
  "t, rules.lte]) : \'\'H\001R\002gt\022\350\007\n\003gte\030\005 \001(\003B"
  "\323\007\302H\317\007\n\210\001\n\tint64.gte\032{!has(rules.lt) && "
  "!has(rules.lte) && this < rules.gte\? \'va"
  "lue must be greater than or equal to %s\'"
  ".format([rules.gte]) : \'\'\n\302\001\n\014int64.gte_"
  "lt\032\261\001has(rules.lt) && rules.lt >= rules."
  "gte && (this >= rules.lt || this < rules"
  ".gte)\? \'value must be greater than or eq"
  "ual to %s and less than %s\'.format([rule"
  "s.gte, rules.lt]) : \'\'\n\312\001\n\026int64.gte_lt_"
  "exclusive\032\257\001has(rules.lt) && rules.lt < "
  "rules.gte && (rules.lt <= this && this <"
  " rules.gte)\? \'value must be greater than"
  " or equal to %s or less than %s\'.format("
  "[rules.gte, rules.lt]) : \'\'\n\322\001\n\rint64.gt"
  "e_lte\032\300\001has(rules.lte) && rules.lte >= r"
  "ules.gte && (this > rules.lte || this < "
  "rules.gte)\? \'value must be greater than "
  "or equal to %s and less than or equal to"
  " %s\'.format([rules.gte, rules.lte]) : \'\'"
  "\n\332\001\n\027int64.gte_lte_exclusive\032\276\001has(rules"
  ".lte) && rules.lte < rules.gte && (rules"
  ".lte < this && this < rules.gte)\? \'value"
  " must be greater than or equal to %s or "
  "less than or equal to %s\'.format([rules."
  "gte, rules.lte]) : \'\'H\001R\003gte\022\203\001\n\002in\030\006 \003("
  "\003Bs\302Hp\nn\n\010int64.in\032b!(this in getField(r"
  "ules, \'in\')) \? \'value must be in list %s"
  "\'.format([getField(rules, \'in\')]) : \'\'R\002"
  "in\022}\n\006not_in\030\007 \003(\003Bf\302Hc\na\n\014int64.not_in\032"
  "Qthis in rules.not_in \? \'value must not "
  "be in list %s\'.format([rules.not_in]) : "
  "\'\'R\005notIn\0224\n\007example\030\t \003(\003B\032\302H\027\n\025\n\rint64"
  ".example\032\004trueR\007example*\t\010\350\007\020\200\200\200\200\002B\013\n\tle"
  "ss_thanB\016\n\014greater_than\"\313\025\n\013UInt32Rules\022"
  "\213\001\n\005const\030\001 \001(\rBu\302Hr\np\n\014uint32.const\032`th"
  "is != getField(rules, \'const\') \? \'value "
  "must equal %s\'.format([getField(rules, \'"
  "const\')]) : \'\'R\005const\022\217\001\n\002lt\030\002 \001(\rB}\302Hz\n"
  "x\n\tuint32.lt\032k!has(rules.gte) && !has(ru"
  "les.gt) && this >= rules.lt\? \'value must"
  " be less than %s\'.format([rules.lt]) : \'"
  "\'H\000R\002lt\022\242\001\n\003lte\030\003 \001(\rB\215\001\302H\211\001\n\206\001\n\nuint32."
  "lte\032x!has(rules.gte) && !has(rules.gt) &"
  "& this > rules.lte\? \'value must be less "
  "than or equal to %s\'.format([rules.lte])"
  " : \'\'H\000R\003lte\022\240\007\n\002gt\030\004 \001(\rB\215\007\302H\211\007\n{\n\tuint"
  "32.gt\032n!has(rules.lt) && !has(rules.lte)"
  " && this <= rules.gt\? \'value must be gre"
  "ater than %s\'.format([rules.gt]) : \'\'\n\264\001"
  "\n\014uint32.gt_lt\032\243\001has(rules.lt) && rules."
  "lt >= rules.gt && (this >= rules.lt || t"
  "his <= rules.gt)\? \'value must be greater"
  " than %s and less than %s\'.format([rules"
  ".gt, rules.lt]) : \'\'\n\274\001\n\026uint32.gt_lt_ex"
  "clusive\032\241\001has(rules.lt) && rules.lt < ru"
  "les.gt && (rules.lt <= this && this <= r"
  "ules.gt)\? \'value must be greater than %s"
  " or less than %s\'.format([rules.gt, rule"
  "s.lt]) : \'\'\n\304\001\n\ruint32.gt_lte\032\262\001has(rule"
  "s.lte) && rules.lte >= rules.gt && (this"
  " > rules.lte || this <= rules.gt)\? \'valu"
  "e must be greater than %s and less than "
  "or equal to %s\'.format([rules.gt, rules."
  "lte]) : \'\'\n\314\001\n\027uint32.gt_lte_exclusive\032\260"
  "\001has(rules.lte) && rules.lte < rules.gt "
  "&& (rules.lte < this && this <= rules.gt"
  ")\? \'value must be greater than %s or les"
  "s than or equal to %s\'.format([rules.gt,"
  " rules.lte]) : \'\'H\001R\002gt\022\355\007\n\003gte\030\005 \001(\rB\330\007"
  "\302H\324\007\n\211\001\n\nuint32.gte\032{!has(rules.lt) && !"
  "has(rules.lte) && this < rules.gte\? \'val"
  "ue must be greater than or equal to %s\'."
  "format([rules.gte]) : \'\'\n\303\001\n\ruint32.gte_"
  "lt\032\261\001has(rules.lt) && rules.lt >= rules."
  "gte && (this >= rules.lt || this < rules"
  ".gte)\? \'value must be greater than or eq"
  "ual to %s and less than %s\'.format([rule"
  "s.gte, rules.lt]) : \'\'\n\313\001\n\027uint32.gte_lt"
  "_exclusive\032\257\001has(rules.lt) && rules.lt <"
  " rules.gte && (rules.lt <= this && this "
  "< rules.gte)\? \'value must be greater tha"
  "n or equal to %s or less than %s\'.format"
  "([rules.gte, rules.lt]) : \'\'\n\323\001\n\016uint32."
  "gte_lte\032\300\001has(rules.lte) && rules.lte >="
  " rules.gte && (this > rules.lte || this "
  "< rules.gte)\? \'value must be greater tha"
  "n or equal to %s and less than or equal "
  "to %s\'.format([rules.gte, rules.lte]) : "
  "\'\'\n\333\001\n\030uint32.gte_lte_exclusive\032\276\001has(ru"
  "les.lte) && rules.lte < rules.gte && (ru"
  "les.lte < this && this < rules.gte)\? \'va"
  "lue must be greater than or equal to %s "
  "or less than or equal to %s\'.format([rul"
  "es.gte, rules.lte]) : \'\'H\001R\003gte\022\204\001\n\002in\030\006"
  " \003(\rBt\302Hq\no\n\tuint32.in\032b!(this in getFie"
  "ld(rules, \'in\')) \? \'value must be in lis"
  "t %s\'.format([getField(rules, \'in\')]) : "
  "\'\'R\002in\022~\n\006not_in\030\007 \003(\rBg\302Hd\nb\n\ruint32.no"
  "t_in\032Qthis in rules.not_in \? \'value must"
  " not be in list %s\'.format([rules.not_in"
  "]) : \'\'R\005notIn\0225\n\007example\030\010 \003(\rB\033\302H\030\n\026\n\016"
  "uint32.example\032\004trueR\007example*\t\010\350\007\020\200\200\200\200\002"
  "B\013\n\tless_thanB\016\n\014greater_than\"\313\025\n\013UInt64"
  "Rules\022\213\001\n\005const\030\001 \001(\004Bu\302Hr\np\n\014uint64.con"
  "st\032`this != getField(rules, \'const\') \? \'"
  "value must equal %s\'.format([getField(ru"
  "les, \'const\')]) : \'\'R\005const\022\217\001\n\002lt\030\002 \001(\004"
  "B}\302Hz\nx\n\tuint64.lt\032k!has(rules.gte) && !"
  "has(rules.gt) && this >= rules.lt\? \'valu"
  "e must be less than %s\'.format([rules.lt"
  "]) : \'\'H\000R\002lt\022\242\001\n\003lte\030\003 \001(\004B\215\001\302H\211\001\n\206\001\n\nu"
  "int64.lte\032x!has(rules.gte) && !has(rules"
  ".gt) && this > rules.lte\? \'value must be"
  " less than or equal to %s\'.format([rules"
  ".lte]) : \'\'H\000R\003lte\022\240\007\n\002gt\030\004 \001(\004B\215\007\302H\211\007\n{"
  "\n\tuint64.gt\032n!has(rules.lt) && !has(rule"
  "s.lte) && this <= rules.gt\? \'value must "
  "be greater than %s\'.format([rules.gt]) :"
  " \'\'\n\264\001\n\014uint64.gt_lt\032\243\001has(rules.lt) && "
  "rules.lt >= rules.gt && (this >= rules.l"
  "t || this <= rules.gt)\? \'value must be g"
  "reater than %s and less than %s\'.format("
  "[rules.gt, rules.lt]) : \'\'\n\274\001\n\026uint64.gt"
  "_lt_exclusive\032\241\001has(rules.lt) && rules.l"
  "t < rules.gt && (rules.lt <= this && thi"
  "s <= rules.gt)\? \'value must be greater t"
  "han %s or less than %s\'.format([rules.gt"
  ", rules.lt]) : \'\'\n\304\001\n\ruint64.gt_lte\032\262\001ha"
  "s(rules.lte) && rules.lte >= rules.gt &&"
  " (this > rules.lte || this <= rules.gt)\?"
  " \'value must be greater than %s and less"
  " than or equal to %s\'.format([rules.gt, "
  "rules.lte]) : \'\'\n\314\001\n\027uint64.gt_lte_exclu"
  "sive\032\260\001has(rules.lte) && rules.lte < rul"
  "es.gt && (rules.lte < this && this <= ru"
  "les.gt)\? \'value must be greater than %s "
  "or less than or equal to %s\'.format([rul"
  "es.gt, rules.lte]) : \'\'H\001R\002gt\022\355\007\n\003gte\030\005 "
  "\001(\004B\330\007\302H\324\007\n\211\001\n\nuint64.gte\032{!has(rules.lt"
  ") && !has(rules.lte) && this < rules.gte"
  "\? \'value must be greater than or equal t"
  "o %s\'.format([rules.gte]) : \'\'\n\303\001\n\ruint6"
  "4.gte_lt\032\261\001has(rules.lt) && rules.lt >= "
  "rules.gte && (this >= rules.lt || this <"
  " rules.gte)\? \'value must be greater than"
  " or equal to %s and less than %s\'.format"
  "([rules.gte, rules.lt]) : \'\'\n\313\001\n\027uint64."
  "gte_lt_exclusive\032\257\001has(rules.lt) && rule"
  "s.lt < rules.gte && (rules.lt <= this &&"
  " this < rules.gte)\? \'value must be great"
  "er than or equal to %s or less than %s\'."
  "format([rules.gte, rules.lt]) : \'\'\n\323\001\n\016u"
  "int64.gte_lte\032\300\001has(rules.lte) && rules."
  "lte >= rules.gte && (this > rules.lte ||"
  " this < rules.gte)\? \'value must be great"
  "er than or equal to %s and less than or "
  "equal to %s\'.format([rules.gte, rules.lt"
  "e]) : \'\'\n\333\001\n\030uint64.gte_lte_exclusive\032\276\001"
  "has(rules.lte) && rules.lte < rules.gte "
  "&& (rules.lte < this && this < rules.gte"
  ")\? \'value must be greater than or equal "
  "to %s or less than or equal to %s\'.forma"
  "t([rules.gte, rules.lte]) : \'\'H\001R\003gte\022\204\001"
  "\n\002in\030\006 \003(\004Bt\302Hq\no\n\tuint64.in\032b!(this in "
  "getField(rules, \'in\')) \? \'value must be "
  "in list %s\'.format([getField(rules, \'in\'"
  ")]) : \'\'R\002in\022~\n\006not_in\030\007 \003(\004Bg\302Hd\nb\n\ruin"
  "t64.not_in\032Qthis in rules.not_in \? \'valu"
  "e must not be in list %s\'.format([rules."
  "not_in]) : \'\'R\005notIn\0225\n\007example\030\010 \003(\004B\033\302"
  "H\030\n\026\n\016uint64.example\032\004trueR\007example*\t\010\350\007"
  "\020\200\200\200\200\002B\013\n\tless_thanB\016\n\014greater_than\"\313\025\n\013"
  "SInt32Rules\022\213\001\n\005const\030\001 \001(\021Bu\302Hr\np\n\014sint"
  "32.const\032`this != getField(rules, \'const"
  "\') \? \'value must equal %s\'.format([getFi"
  "eld(rules, \'const\')]) : \'\'R\005const\022\217\001\n\002lt"
  "\030\002 \001(\021B}\302Hz\nx\n\tsint32.lt\032k!has(rules.gte"
  ") && !has(rules.gt) && this >= rules.lt\?"
  " \'value must be less than %s\'.format([ru"
  "les.lt]) : \'\'H\000R\002lt\022\242\001\n\003lte\030\003 \001(\021B\215\001\302H\211\001"
  "\n\206\001\n\nsint32.lte\032x!has(rules.gte) && !has"
  "(rules.gt) && this > rules.lte\? \'value m"
  "ust be less than or equal to %s\'.format("
  "[rules.lte]) : \'\'H\000R\003lte\022\240\007\n\002gt\030\004 \001(\021B\215\007"
  "\302H\211\007\n{\n\tsint32.gt\032n!has(rules.lt) && !ha"
  "s(rules.lte) && this <= rules.gt\? \'value"
  " must be greater than %s\'.format([rules."
  "gt]) : \'\'\n\264\001\n\014sint32.gt_lt\032\243\001has(rules.l"
  "t) && rules.lt >= rules.gt && (this >= r"
  "ules.lt || this <= rules.gt)\? \'value mus"
  "t be greater than %s and less than %s\'.f"
  "ormat([rules.gt, rules.lt]) : \'\'\n\274\001\n\026sin"
  "t32.gt_lt_exclusive\032\241\001has(rules.lt) && r"
  "ules.lt < rules.gt && (rules.lt <= this "
  "&& this <= rules.gt)\? \'value must be gre"
  "ater than %s or less than %s\'.format([ru"
  "les.gt, rules.lt]) : \'\'\n\304\001\n\rsint32.gt_lt"
  "e\032\262\001has(rules.lte) && rules.lte >= rules"
  ".gt && (this > rules.lte || this <= rule"
  "s.gt)\? \'value must be greater than %s an"
  "d less than or equal to %s\'.format([rule"
  "s.gt, rules.lte]) : \'\'\n\314\001\n\027sint32.gt_lte"
  "_exclusive\032\260\001has(rules.lte) && rules.lte"
  " < rules.gt && (rules.lte < this && this"
  " <= rules.gt)\? \'value must be greater th"
  "an %s or less than or equal to %s\'.forma"
  "t([rules.gt, rules.lte]) : \'\'H\001R\002gt\022\355\007\n\003"
  "gte\030\005 \001(\021B\330\007\302H\324\007\n\211\001\n\nsint32.gte\032{!has(ru"
  "les.lt) && !has(rules.lte) && this < rul"
  "es.gte\? \'value must be greater than or e"
  "qual to %s\'.format([rules.gte]) : \'\'\n\303\001\n"
  "\rsint32.gte_lt\032\261\001has(rules.lt) && rules."
  "lt >= rules.gte && (this >= rules.lt || "
  "this < rules.gte)\? \'value must be greate"
  "r than or equal to %s and less than %s\'."
  "format([rules.gte, rules.lt]) : \'\'\n\313\001\n\027s"
  "int32.gte_lt_exclusive\032\257\001has(rules.lt) &"
  "& rules.lt < rules.gte && (rules.lt <= t"
  "his && this < rules.gte)\? \'value must be"
  " greater than or equal to %s or less tha"
  "n %s\'.format([rules.gte, rules.lt]) : \'\'"
  "\n\323\001\n\016sint32.gte_lte\032\300\001has(rules.lte) && "
  "rules.lte >= rules.gte && (this > rules."
  "lte || this < rules.gte)\? \'value must be"
  " greater than or equal to %s and less th"
  "an or equal to %s\'.format([rules.gte, ru"
  "les.lte]) : \'\'\n\333\001\n\030sint32.gte_lte_exclus"
  "ive\032\276\001has(rules.lte) && rules.lte < rule"
  "s.gte && (rules.lte < this && this < rul"
  "es.gte)\? \'value must be greater than or "
  "equal to %s or less than or equal to %s\'"
  ".format([rules.gte, rules.lte]) : \'\'H\001R\003"
  "gte\022\204\001\n\002in\030\006 \003(\021Bt\302Hq\no\n\tsint32.in\032b!(th"
  "is in getField(rules, \'in\')) \? \'value mu"
  "st be in list %s\'.format([getField(rules"
  ", \'in\')]) : \'\'R\002in\022~\n\006not_in\030\007 \003(\021Bg\302Hd\n"
  "b\n\rsint32.not_in\032Qthis in rules.not_in \?"
  " \'value must not be in list %s\'.format(["
  "rules.not_in]) : \'\'R\005notIn\0225\n\007example\030\010 "
  "\003(\021B\033\302H\030\n\026\n\016sint32.example\032\004trueR\007exampl"
  "e*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB\016\n\014greater_tha"
  "n\"\313\025\n\013SInt64Rules\022\213\001\n\005const\030\001 \001(\022Bu\302Hr\np"
  "\n\014sint64.const\032`this != getField(rules, "
  "\'const\') \? \'value must equal %s\'.format("
  "[getField(rules, \'const\')]) : \'\'R\005const\022"
  "\217\001\n\002lt\030\002 \001(\022B}\302Hz\nx\n\tsint64.lt\032k!has(rul"
  "es.gte) && !has(rules.gt) && this >= rul"
  "es.lt\? \'value must be less than %s\'.form"
  "at([rules.lt]) : \'\'H\000R\002lt\022\242\001\n\003lte\030\003 \001(\022B"
  "\215\001\302H\211\001\n\206\001\n\nsint64.lte\032x!has(rules.gte) &"
  "& !has(rules.gt) && this > rules.lte\? \'v"
  "alue must be less than or equal to %s\'.f"
  "ormat([rules.lte]) : \'\'H\000R\003lte\022\240\007\n\002gt\030\004 "
  "\001(\022B\215\007\302H\211\007\n{\n\tsint64.gt\032n!has(rules.lt) "
  "&& !has(rules.lte) && this <= rules.gt\? "
  "\'value must be greater than %s\'.format(["
  "rules.gt]) : \'\'\n\264\001\n\014sint64.gt_lt\032\243\001has(r"
  "ules.lt) && rules.lt >= rules.gt && (thi"
  "s >= rules.lt || this <= rules.gt)\? \'val"
  "ue must be greater than %s and less than"
  " %s\'.format([rules.gt, rules.lt]) : \'\'\n\274"
  "\001\n\026sint64.gt_lt_exclusive\032\241\001has(rules.lt"
  ") && rules.lt < rules.gt && (rules.lt <="
  " this && this <= rules.gt)\? \'value must "
  "be greater than %s or less than %s\'.form"
  "at([rules.gt, rules.lt]) : \'\'\n\304\001\n\rsint64"
  ".gt_lte\032\262\001has(rules.lte) && rules.lte >="
  " rules.gt && (this > rules.lte || this <"
  "= rules.gt)\? \'value must be greater than"
  " %s and less than or equal to %s\'.format"
  "([rules.gt, rules.lte]) : \'\'\n\314\001\n\027sint64."
  "gt_lte_exclusive\032\260\001has(rules.lte) && rul"
  "es.lte < rules.gt && (rules.lte < this &"
  "& this <= rules.gt)\? \'value must be grea"
  "ter than %s or less than or equal to %s\'"
  ".format([rules.gt, rules.lte]) : \'\'H\001R\002g"
  "t\022\355\007\n\003gte\030\005 \001(\022B\330\007\302H\324\007\n\211\001\n\nsint64.gte\032{!"
  "has(rules.lt) && !has(rules.lte) && this"
  " < rules.gte\? \'value must be greater tha"
  "n or equal to %s\'.format([rules.gte]) : "
  "\'\'\n\303\001\n\rsint64.gte_lt\032\261\001has(rules.lt) && "
  "rules.lt >= rules.gte && (this >= rules."
  "lt || this < rules.gte)\? \'value must be "
  "greater than or equal to %s and less tha"
  "n %s\'.format([rules.gte, rules.lt]) : \'\'"
  "\n\313\001\n\027sint64.gte_lt_exclusive\032\257\001has(rules"
  ".lt) && rules.lt < rules.gte && (rules.l"
  "t <= this && this < rules.gte)\? \'value m"
  "ust be greater than or equal to %s or le"
  "ss than %s\'.format([rules.gte, rules.lt]"
  ") : \'\'\n\323\001\n\016sint64.gte_lte\032\300\001has(rules.lt"
  "e) && rules.lte >= rules.gte && (this > "
  "rules.lte || this < rules.gte)\? \'value m"
  "ust be greater than or equal to %s and l"
  "ess than or equal to %s\'.format([rules.g"
  "te, rules.lte]) : \'\'\n\333\001\n\030sint64.gte_lte_"
  "exclusive\032\276\001has(rules.lte) && rules.lte "
  "< rules.gte && (rules.lte < this && this"
  " < rules.gte)\? \'value must be greater th"
  "an or equal to %s or less than or equal "
  "to %s\'.format([rules.gte, rules.lte]) : "
  "\'\'H\001R\003gte\022\204\001\n\002in\030\006 \003(\022Bt\302Hq\no\n\tsint64.in"
  "\032b!(this in getField(rules, \'in\')) \? \'va"
  "lue must be in list %s\'.format([getField"
  "(rules, \'in\')]) : \'\'R\002in\022~\n\006not_in\030\007 \003(\022"
  "Bg\302Hd\nb\n\rsint64.not_in\032Qthis in rules.no"
  "t_in \? \'value must not be in list %s\'.fo"
  "rmat([rules.not_in]) : \'\'R\005notIn\0225\n\007exam"
  "ple\030\010 \003(\022B\033\302H\030\n\026\n\016sint64.example\032\004trueR\007"
  "example*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB\016\n\014great"
  "er_than\"\334\025\n\014Fixed32Rules\022\214\001\n\005const\030\001 \001(\007"
  "Bv\302Hs\nq\n\rfixed32.const\032`this != getField"
  "(rules, \'const\') \? \'value must equal %s\'"
  ".format([getField(rules, \'const\')]) : \'\'"
  "R\005const\022\220\001\n\002lt\030\002 \001(\007B~\302H{\ny\n\nfixed32.lt\032"
  "k!has(rules.gte) && !has(rules.gt) && th"
  "is >= rules.lt\? \'value must be less than"
  " %s\'.format([rules.lt]) : \'\'H\000R\002lt\022\243\001\n\003l"
  "te\030\003 \001(\007B\216\001\302H\212\001\n\207\001\n\013fixed32.lte\032x!has(ru"
  "les.gte) && !has(rules.gt) && this > rul"
  "es.lte\? \'value must be less than or equa"
  "l to %s\'.format([rules.lte]) : \'\'H\000R\003lte"
  "\022\245\007\n\002gt\030\004 \001(\007B\222\007\302H\216\007\n|\n\nfixed32.gt\032n!has"
  "(rules.lt) && !has(rules.lte) && this <="
  " rules.gt\? \'value must be greater than %"
  "s\'.format([rules.gt]) : \'\'\n\265\001\n\rfixed32.g"
  "t_lt\032\243\001has(rules.lt) && rules.lt >= rule"
  "s.gt && (this >= rules.lt || this <= rul"
  "es.gt)\? \'value must be greater than %s a"
  "nd less than %s\'.format([rules.gt, rules"
  ".lt]) : \'\'\n\275\001\n\027fixed32.gt_lt_exclusive\032\241"
  "\001has(rules.lt) && rules.lt < rules.gt &&"
  " (rules.lt <= this && this <= rules.gt)\?"
  " \'value must be greater than %s or less "
  "than %s\'.format([rules.gt, rules.lt]) : "
  "\'\'\n\305\001\n\016fixed32.gt_lte\032\262\001has(rules.lte) &"
  "& rules.lte >= rules.gt && (this > rules"
  ".lte || this <= rules.gt)\? \'value must b"
  "e greater than %s and less than or equal"
  " to %s\'.format([rules.gt, rules.lte]) : "
  "\'\'\n\315\001\n\030fixed32.gt_lte_exclusive\032\260\001has(ru"
  "les.lte) && rules.lte < rules.gt && (rul"
  "es.lte < this && this <= rules.gt)\? \'val"
  "ue must be greater than %s or less than "
  "or equal to %s\'.format([rules.gt, rules."
  "lte]) : \'\'H\001R\002gt\022\362\007\n\003gte\030\005 \001(\007B\335\007\302H\331\007\n\212\001"
  "\n\013fixed32.gte\032{!has(rules.lt) && !has(ru"
  "les.lte) && this < rules.gte\? \'value mus"
  "t be greater than or equal to %s\'.format"
  "([rules.gte]) : \'\'\n\304\001\n\016fixed32.gte_lt\032\261\001"
  "has(rules.lt) && rules.lt >= rules.gte &"
  "& (this >= rules.lt || this < rules.gte)"
  "\? \'value must be greater than or equal t"
  "o %s and less than %s\'.format([rules.gte"
  ", rules.lt]) : \'\'\n\314\001\n\030fixed32.gte_lt_exc"
  "lusive\032\257\001has(rules.lt) && rules.lt < rul"
  "es.gte && (rules.lt <= this && this < ru"
  "les.gte)\? \'value must be greater than or"
  " equal to %s or less than %s\'.format([ru"
  "les.gte, rules.lt]) : \'\'\n\324\001\n\017fixed32.gte"
  "_lte\032\300\001has(rules.lte) && rules.lte >= ru"
  "les.gte && (this > rules.lte || this < r"
  "ules.gte)\? \'value must be greater than o"
  "r equal to %s and less than or equal to "
  "%s\'.format([rules.gte, rules.lte]) : \'\'\n"
  "\334\001\n\031fixed32.gte_lte_exclusive\032\276\001has(rule"
  "s.lte) && rules.lte < rules.gte && (rule"
  "s.lte < this && this < rules.gte)\? \'valu"
  "e must be greater than or equal to %s or"
  " less than or equal to %s\'.format([rules"
  ".gte, rules.lte]) : \'\'H\001R\003gte\022\205\001\n\002in\030\006 \003"
  "(\007Bu\302Hr\np\n\nfixed32.in\032b!(this in getFiel"
  "d(rules, \'in\')) \? \'value must be in list"
  " %s\'.format([getField(rules, \'in\')]) : \'"
  "\'R\002in\022\177\n\006not_in\030\007 \003(\007Bh\302He\nc\n\016fixed32.no"
  "t_in\032Qthis in rules.not_in \? \'value must"
  " not be in list %s\'.format([rules.not_in"
  "]) : \'\'R\005notIn\0226\n\007example\030\010 \003(\007B\034\302H\031\n\027\n\017"
  "fixed32.example\032\004trueR\007example*\t\010\350\007\020\200\200\200\200"
  "\002B\013\n\tless_thanB\016\n\014greater_than\"\334\025\n\014Fixed"
  "64Rules\022\214\001\n\005const\030\001 \001(\006Bv\302Hs\nq\n\rfixed64."
  "const\032`this != getField(rules, \'const\') "
  "\? \'value must equal %s\'.format([getField"
  "(rules, \'const\')]) : \'\'R\005const\022\220\001\n\002lt\030\002 "
  "\001(\006B~\302H{\ny\n\nfixed64.lt\032k!has(rules.gte) "
  "&& !has(rules.gt) && this >= rules.lt\? \'"
  "value must be less than %s\'.format([rule"
  "s.lt]) : \'\'H\000R\002lt\022\243\001\n\003lte\030\003 \001(\006B\216\001\302H\212\001\n\207"
  "\001\n\013fixed64.lte\032x!has(rules.gte) && !has("
  "rules.gt) && this > rules.lte\? \'value mu"
  "st be less than or equal to %s\'.format(["
  "rules.lte]) : \'\'H\000R\003lte\022\245\007\n\002gt\030\004 \001(\006B\222\007\302"
  "H\216\007\n|\n\nfixed64.gt\032n!has(rules.lt) && !ha"
  "s(rules.lte) && this <= rules.gt\? \'value"
  " must be greater than %s\'.format([rules."
  "gt]) : \'\'\n\265\001\n\rfixed64.gt_lt\032\243\001has(rules."
  "lt) && rules.lt >= rules.gt && (this >= "
  "rules.lt || this <= rules.gt)\? \'value mu"
  "st be greater than %s and less than %s\'."
  "format([rules.gt, rules.lt]) : \'\'\n\275\001\n\027fi"
  "xed64.gt_lt_exclusive\032\241\001has(rules.lt) &&"
  " rules.lt < rules.gt && (rules.lt <= thi"
  "s && this <= rules.gt)\? \'value must be g"
  "reater than %s or less than %s\'.format(["
  "rules.gt, rules.lt]) : \'\'\n\305\001\n\016fixed64.gt"
  "_lte\032\262\001has(rules.lte) && rules.lte >= ru"
  "les.gt && (this > rules.lte || this <= r"
  "ules.gt)\? \'value must be greater than %s"
  " and less than or equal to %s\'.format([r"
  "ules.gt, rules.lte]) : \'\'\n\315\001\n\030fixed64.gt"
  "_lte_exclusive\032\260\001has(rules.lte) && rules"
  ".lte < rules.gt && (rules.lte < this && "
  "this <= rules.gt)\? \'value must be greate"
  "r than %s or less than or equal to %s\'.f"
  "ormat([rules.gt, rules.lte]) : \'\'H\001R\002gt\022"
  "\362\007\n\003gte\030\005 \001(\006B\335\007\302H\331\007\n\212\001\n\013fixed64.gte\032{!h"
  "as(rules.lt) && !has(rules.lte) && this "
  "< rules.gte\? \'value must be greater than"
  " or equal to %s\'.format([rules.gte]) : \'"
  "\'\n\304\001\n\016fixed64.gte_lt\032\261\001has(rules.lt) && "
  "rules.lt >= rules.gte && (this >= rules."
  "lt || this < rules.gte)\? \'value must be "
  "greater than or equal to %s and less tha"
  "n %s\'.format([rules.gte, rules.lt]) : \'\'"
  "\n\314\001\n\030fixed64.gte_lt_exclusive\032\257\001has(rule"
  "s.lt) && rules.lt < rules.gte && (rules."
  "lt <= this && this < rules.gte)\? \'value "
  "must be greater than or equal to %s or l"
  "ess than %s\'.format([rules.gte, rules.lt"
  "]) : \'\'\n\324\001\n\017fixed64.gte_lte\032\300\001has(rules."
  "lte) && rules.lte >= rules.gte && (this "
  "> rules.lte || this < rules.gte)\? \'value"
  " must be greater than or equal to %s and"
  " less than or equal to %s\'.format([rules"
  ".gte, rules.lte]) : \'\'\n\334\001\n\031fixed64.gte_l"
  "te_exclusive\032\276\001has(rules.lte) && rules.l"
  "te < rules.gte && (rules.lte < this && t"
  "his < rules.gte)\? \'value must be greater"
  " than or equal to %s or less than or equ"
  "al to %s\'.format([rules.gte, rules.lte])"
  " : \'\'H\001R\003gte\022\205\001\n\002in\030\006 \003(\006Bu\302Hr\np\n\nfixed6"
  "4.in\032b!(this in getField(rules, \'in\')) \?"
  " \'value must be in list %s\'.format([getF"
  "ield(rules, \'in\')]) : \'\'R\002in\022\177\n\006not_in\030\007"
  " \003(\006Bh\302He\nc\n\016fixed64.not_in\032Qthis in rul"
  "es.not_in \? \'value must not be in list %"
  "s\'.format([rules.not_in]) : \'\'R\005notIn\0226\n"
  "\007example\030\010 \003(\006B\034\302H\031\n\027\n\017fixed64.example\032\004"
  "trueR\007example*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB\016\n"
  "\014greater_than\"\356\025\n\rSFixed32Rules\022\215\001\n\005cons"
  "t\030\001 \001(\017Bw\302Ht\nr\n\016sfixed32.const\032`this != "
  "getField(rules, \'const\') \? \'value must e"
  "qual %s\'.format([getField(rules, \'const\'"
  ")]) : \'\'R\005const\022\221\001\n\002lt\030\002 \001(\017B\177\302H|\nz\n\013sfi"
  "xed32.lt\032k!has(rules.gte) && !has(rules."
  "gt) && this >= rules.lt\? \'value must be "
  "less than %s\'.format([rules.lt]) : \'\'H\000R"
  "\002lt\022\244\001\n\003lte\030\003 \001(\017B\217\001\302H\213\001\n\210\001\n\014sfixed32.lt"
  "e\032x!has(rules.gte) && !has(rules.gt) && "
  "this > rules.lte\? \'value must be less th"
  "an or equal to %s\'.format([rules.lte]) :"
  " \'\'H\000R\003lte\022\252\007\n\002gt\030\004 \001(\017B\227\007\302H\223\007\n}\n\013sfixed"
  "32.gt\032n!has(rules.lt) && !has(rules.lte)"
  " && this <= rules.gt\? \'value must be gre"
  "ater than %s\'.format([rules.gt]) : \'\'\n\266\001"
  "\n\016sfixed32.gt_lt\032\243\001has(rules.lt) && rule"
  "s.lt >= rules.gt && (this >= rules.lt ||"
  " this <= rules.gt)\? \'value must be great"
  "er than %s and less than %s\'.format([rul"
  "es.gt, rules.lt]) : \'\'\n\276\001\n\030sfixed32.gt_l"
  "t_exclusive\032\241\001has(rules.lt) && rules.lt "
  "< rules.gt && (rules.lt <= this && this "
  "<= rules.gt)\? \'value must be greater tha"
  "n %s or less than %s\'.format([rules.gt, "
  "rules.lt]) : \'\'\n\306\001\n\017sfixed32.gt_lte\032\262\001ha"
  "s(rules.lte) && rules.lte >= rules.gt &&"
  " (this > rules.lte || this <= rules.gt)\?"
  " \'value must be greater than %s and less"
  " than or equal to %s\'.format([rules.gt, "
  "rules.lte]) : \'\'\n\316\001\n\031sfixed32.gt_lte_exc"
  "lusive\032\260\001has(rules.lte) && rules.lte < r"
  "ules.gt && (rules.lte < this && this <= "
  "rules.gt)\? \'value must be greater than %"
  "s or less than or equal to %s\'.format([r"
  "ules.gt, rules.lte]) : \'\'H\001R\002gt\022\367\007\n\003gte\030"
  "\005 \001(\017B\342\007\302H\336\007\n\213\001\n\014sfixed32.gte\032{!has(rule"
  "s.lt) && !has(rules.lte) && this < rules"
  ".gte\? \'value must be greater than or equ"
  "al to %s\'.format([rules.gte]) : \'\'\n\305\001\n\017s"
  "fixed32.gte_lt\032\261\001has(rules.lt) && rules."
  "lt >= rules.gte && (this >= rules.lt || "
  "this < rules.gte)\? \'value must be greate"
  "r than or equal to %s and less than %s\'."
  "format([rules.gte, rules.lt]) : \'\'\n\315\001\n\031s"
  "fixed32.gte_lt_exclusive\032\257\001has(rules.lt)"
  " && rules.lt < rules.gte && (rules.lt <="
  " this && this < rules.gte)\? \'value must "
  "be greater than or equal to %s or less t"
  "han %s\'.format([rules.gte, rules.lt]) : "
  "\'\'\n\325\001\n\020sfixed32.gte_lte\032\300\001has(rules.lte)"
  " && rules.lte >= rules.gte && (this > ru"
  "les.lte || this < rules.gte)\? \'value mus"
  "t be greater than or equal to %s and les"
  "s than or equal to %s\'.format([rules.gte"
  ", rules.lte]) : \'\'\n\335\001\n\032sfixed32.gte_lte_"
  "exclusive\032\276\001has(rules.lte) && rules.lte "
  "< rules.gte && (rules.lte < this && this"
  " < rules.gte)\? \'value must be greater th"
  "an or equal to %s or less than or equal "
  "to %s\'.format([rules.gte, rules.lte]) : "
  "\'\'H\001R\003gte\022\206\001\n\002in\030\006 \003(\017Bv\302Hs\nq\n\013sfixed32."
  "in\032b!(this in getField(rules, \'in\')) \? \'"
  "value must be in list %s\'.format([getFie"
  "ld(rules, \'in\')]) : \'\'R\002in\022\200\001\n\006not_in\030\007 "
  "\003(\017Bi\302Hf\nd\n\017sfixed32.not_in\032Qthis in rul"
  "es.not_in \? \'value must not be in list %"
  "s\'.format([rules.not_in]) : \'\'R\005notIn\0227\n"
  "\007example\030\010 \003(\017B\035\302H\032\n\030\n\020sfixed32.example\032"
  "\004trueR\007example*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB\016"
  "\n\014greater_than\"\356\025\n\rSFixed64Rules\022\215\001\n\005con"
  "st\030\001 \001(\020Bw\302Ht\nr\n\016sfixed64.const\032`this !="
  " getField(rules, \'const\') \? \'value must "
  "equal %s\'.format([getField(rules, \'const"
  "\')]) : \'\'R\005const\022\221\001\n\002lt\030\002 \001(\020B\177\302H|\nz\n\013sf"
  "ixed64.lt\032k!has(rules.gte) && !has(rules"
  ".gt) && this >= rules.lt\? \'value must be"
  " less than %s\'.format([rules.lt]) : \'\'H\000"
  "R\002lt\022\244\001\n\003lte\030\003 \001(\020B\217\001\302H\213\001\n\210\001\n\014sfixed64.l"
  "te\032x!has(rules.gte) && !has(rules.gt) &&"
  " this > rules.lte\? \'value must be less t"
  "han or equal to %s\'.format([rules.lte]) "
  ": \'\'H\000R\003lte\022\252\007\n\002gt\030\004 \001(\020B\227\007\302H\223\007\n}\n\013sfixe"
  "d64.gt\032n!has(rules.lt) && !has(rules.lte"
  ") && this <= rules.gt\? \'value must be gr"
  "eater than %s\'.format([rules.gt]) : \'\'\n\266"
  "\001\n\016sfixed64.gt_lt\032\243\001has(rules.lt) && rul"
  "es.lt >= rules.gt && (this >= rules.lt |"
  "| this <= rules.gt)\? \'value must be grea"
  "ter than %s and less than %s\'.format([ru"
  "les.gt, rules.lt]) : \'\'\n\276\001\n\030sfixed64.gt_"
  "lt_exclusive\032\241\001has(rules.lt) && rules.lt"
  " < rules.gt && (rules.lt <= this && this"
  " <= rules.gt)\? \'value must be greater th"
  "an %s or less than %s\'.format([rules.gt,"
  " rules.lt]) : \'\'\n\306\001\n\017sfixed64.gt_lte\032\262\001h"
  "as(rules.lte) && rules.lte >= rules.gt &"
  "& (this > rules.lte || this <= rules.gt)"
  "\? \'value must be greater than %s and les"
  "s than or equal to %s\'.format([rules.gt,"
  " rules.lte]) : \'\'\n\316\001\n\031sfixed64.gt_lte_ex"
  "clusive\032\260\001has(rules.lte) && rules.lte < "
  "rules.gt && (rules.lte < this && this <="
  " rules.gt)\? \'value must be greater than "
  "%s or less than or equal to %s\'.format(["
  "rules.gt, rules.lte]) : \'\'H\001R\002gt\022\367\007\n\003gte"
  "\030\005 \001(\020B\342\007\302H\336\007\n\213\001\n\014sfixed64.gte\032{!has(rul"
  "es.lt) && !has(rules.lte) && this < rule"
  "s.gte\? \'value must be greater than or eq"
  "ual to %s\'.format([rules.gte]) : \'\'\n\305\001\n\017"
  "sfixed64.gte_lt\032\261\001has(rules.lt) && rules"
  ".lt >= rules.gte && (this >= rules.lt ||"
  " this < rules.gte)\? \'value must be great"
  "er than or equal to %s and less than %s\'"
  ".format([rules.gte, rules.lt]) : \'\'\n\315\001\n\031"
  "sfixed64.gte_lt_exclusive\032\257\001has(rules.lt"
  ") && rules.lt < rules.gte && (rules.lt <"
  "= this && this < rules.gte)\? \'value must"
  " be greater than or equal to %s or less "
  "than %s\'.format([rules.gte, rules.lt]) :"
  " \'\'\n\325\001\n\020sfixed64.gte_lte\032\300\001has(rules.lte"
  ") && rules.lte >= rules.gte && (this > r"
  "ules.lte || this < rules.gte)\? \'value mu"
  "st be greater than or equal to %s and le"
  "ss than or equal to %s\'.format([rules.gt"
  "e, rules.lte]) : \'\'\n\335\001\n\032sfixed64.gte_lte"
  "_exclusive\032\276\001has(rules.lte) && rules.lte"
  " < rules.gte && (rules.lte < this && thi"
  "s < rules.gte)\? \'value must be greater t"
  "han or equal to %s or less than or equal"
  " to %s\'.format([rules.gte, rules.lte]) :"
  " \'\'H\001R\003gte\022\206\001\n\002in\030\006 \003(\020Bv\302Hs\nq\n\013sfixed64"
  ".in\032b!(this in getField(rules, \'in\')) \? "
  "\'value must be in list %s\'.format([getFi"
  "eld(rules, \'in\')]) : \'\'R\002in\022\200\001\n\006not_in\030\007"
  " \003(\020Bi\302Hf\nd\n\017sfixed64.not_in\032Qthis in ru"
  "les.not_in \? \'value must not be in list "
  "%s\'.format([rules.not_in]) : \'\'R\005notIn\0227"
  "\n\007example\030\010 \003(\020B\035\302H\032\n\030\n\020sfixed64.example"
  "\032\004trueR\007example*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB"
  "\016\n\014greater_than\"\327\001\n\tBoolRules\022\211\001\n\005const\030"
  "\001 \001(\010Bs\302Hp\nn\n\nbool.const\032`this != getFie"
  "ld(rules, \'const\') \? \'value must equal %"
  "s\'.format([getField(rules, \'const\')]) : "
  "\'\'R\005const\0223\n\007example\030\002 \003(\010B\031\302H\026\n\024\n\014bool."
  "example\032\004trueR\007example*\t\010\350\007\020\200\200\200\200\002\"\3219\n\013St"
  "ringRules\022\215\001\n\005const\030\001 \001(\tBw\302Ht\nr\n\014string"
  ".const\032bthis != getField(rules, \'const\')"
  " \? \'value must equal `%s`\'.format([getFi"
  "eld(rules, \'const\')]) : \'\'R\005const\022\203\001\n\003le"
  "n\030\023 \001(\004Bq\302Hn\nl\n\nstring.len\032^uint(this.si"
  "ze()) != rules.len \? \'value length must "
  "be %s characters\'.format([rules.len]) : "
  "\'\'R\003len\022\241\001\n\007min_len\030\002 \001(\004B\207\001\302H\203\001\n\200\001\n\016str"
  "ing.min_len\032nuint(this.size()) < rules.m"
  "in_len \? \'value length must be at least "
  "%s characters\'.format([rules.min_len]) :"
  " \'\'R\006minLen\022\237\001\n\007max_len\030\003 \001(\004B\205\001\302H\201\001\n\177\n\016"
  "string.max_len\032muint(this.size()) > rule"
  "s.max_len \? \'value length must be at mos"
  "t %s characters\'.format([rules.max_len])"
  " : \'\'R\006maxLen\022\245\001\n\tlen_bytes\030\024 \001(\004B\207\001\302H\203\001"
  "\n\200\001\n\020string.len_bytes\032luint(bytes(this)."
  "size()) != rules.len_bytes \? \'value leng"
  "th must be %s bytes\'.format([rules.len_b"
  "ytes]) : \'\'R\010lenBytes\022\255\001\n\tmin_bytes\030\004 \001("
  "\004B\217\001\302H\213\001\n\210\001\n\020string.min_bytes\032tuint(byte"
  "s(this).size()) < rules.min_bytes \? \'val"
  "ue length must be at least %s bytes\'.for"
  "mat([rules.min_bytes]) : \'\'R\010minBytes\022\254\001"
  "\n\tmax_bytes\030\005 \001(\004B\216\001\302H\212\001\n\207\001\n\020string.max_"
  "bytes\032suint(bytes(this).size()) > rules."
  "max_bytes \? \'value length must be at mos"
  "t %s bytes\'.format([rules.max_bytes]) : "
  "\'\'R\010maxBytes\022\226\001\n\007pattern\030\006 \001(\tB|\302Hy\nw\n\016s"
  "tring.pattern\032e!this.matches(rules.patte"
  "rn) \? \'value does not match regex patter"
  "n `%s`\'.format([rules.pattern]) : \'\'R\007pa"
  "ttern\022\214\001\n\006prefix\030\007 \001(\tBt\302Hq\no\n\rstring.pr"
  "efix\032^!this.startsWith(rules.prefix) \? \'"
  "value does not have prefix `%s`\'.format("
  "[rules.prefix]) : \'\'R\006prefix\022\212\001\n\006suffix\030"
  "\010 \001(\tBr\302Ho\nm\n\rstring.suffix\032\\!this.endsW"
  "ith(rules.suffix) \? \'value does not have"
  " suffix `%s`\'.format([rules.suffix]) : \'"
  "\'R\006suffix\022\232\001\n\010contains\030\t \001(\tB~\302H{\ny\n\017str"
  "ing.contains\032f!this.contains(rules.conta"
  "ins) \? \'value does not contain substring"
  " `%s`\'.format([rules.contains]) : \'\'R\010co"
  "ntains\022\245\001\n\014not_contains\030\027 \001(\tB\201\001\302H~\n|\n\023s"
  "tring.not_contains\032ethis.contains(rules."
  "not_contains) \? \'value contains substrin"
  "g `%s`\'.format([rules.not_contains]) : \'"
  "\'R\013notContains\022\204\001\n\002in\030\n \003(\tBt\302Hq\no\n\tstri"
  "ng.in\032b!(this in getField(rules, \'in\')) "
  "\? \'value must be in list %s\'.format([get"
  "Field(rules, \'in\')]) : \'\'R\002in\022~\n\006not_in\030"
  "\013 \003(\tBg\302Hd\nb\n\rstring.not_in\032Qthis in rul"
  "es.not_in \? \'value must not be in list %"
  "s\'.format([rules.not_in]) : \'\'R\005notIn\022\346\001"
  "\n\005email\030\014 \001(\010B\315\001\302H\311\001\na\n\014string.email\022#va"
  "lue must be a valid email address\032,!rule"
  "s.email || this == \'\' || this.isEmail()\n"
  "d\n\022string.email_empty\0222value is empty, w"
  "hich is not a valid email address\032\032!rule"
  "s.email || this != \'\'H\000R\005email\022\361\001\n\010hostn"
  "ame\030\r \001(\010B\322\001\302H\316\001\ne\n\017string.hostname\022\036val"
  "ue must be a valid hostname\0322!rules.host"
  "name || this == \'\' || this.isHostname()\n"
  "e\n\025string.hostname_empty\022-value is empty"
  ", which is not a valid hostname\032\035!rules."
  "hostname || this != \'\'H\000R\010hostname\022\313\001\n\002i"
  "p\030\016 \001(\010B\270\001\302H\264\001\nU\n\tstring.ip\022 value must "
  "be a valid IP address\032&!rules.ip || this"
  " == \'\' || this.isIp()\n[\n\017string.ip_empty"
  "\022/value is empty, which is not a valid I"
  "P address\032\027!rules.ip || this != \'\'H\000R\002ip"
  "\022\334\001\n\004ipv4\030\017 \001(\010B\305\001\302H\301\001\n\\\n\013string.ipv4\022\"v"
  "alue must be a valid IPv4 address\032)!rule"
  "s.ipv4 || this == \'\' || this.isIp(4)\na\n\021"
  "string.ipv4_empty\0221value is empty, which"
  " is not a valid IPv4 address\032\031!rules.ipv"
  "4 || this != \'\'H\000R\004ipv4\022\334\001\n\004ipv6\030\020 \001(\010B\305"
  "\001\302H\301\001\n\\\n\013string.ipv6\022\"value must be a va"
  "lid IPv6 address\032)!rules.ipv6 || this =="
  " \'\' || this.isIp(6)\na\n\021string.ipv6_empty"
  "\0221value is empty, which is not a valid I"
  "Pv6 address\032\031!rules.ipv6 || this != \'\'H\000"
  "R\004ipv6\022\304\001\n\003uri\030\021 \001(\010B\257\001\302H\253\001\nQ\n\nstring.ur"
  "i\022\031value must be a valid URI\032(!rules.uri"
  " || this == \'\' || this.isUri()\nV\n\020string"
  ".uri_empty\022(value is empty, which is not"
  " a valid URI\032\030!rules.uri || this != \'\'H\000"
  "R\003uri\022x\n\007uri_ref\030\022 \001(\010B]\302HZ\nX\n\016string.ur"
  "i_ref\022#value must be a valid URI Referen"
  "ce\032!!rules.uri_ref || this.isUriRef()H\000R"
  "\006uriRef\022\231\002\n\007address\030\025 \001(\010B\374\001\302H\370\001\n\201\001\n\016str"
  "ing.address\022-value must be a valid hostn"
  "ame, or ip address\032@!rules.address || th"
  "is == \'\' || this.isHostname() || this.is"
  "Ip()\nr\n\024string.address_empty\022<value is e"
  "mpty, which is not a valid hostname, or "
  "ip address\032\034!rules.address || this != \'\'"
  "H\000R\007address\022\236\002\n\004uuid\030\026 \001(\010B\207\002\302H\203\002\n\245\001\n\013st"
  "ring.uuid\022\032value must be a valid UUID\032z!"
  "rules.uuid || this == \'\' || this.matches"
  "(\'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-f"
  "A-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\'"
  ")\nY\n\021string.uuid_empty\022)value is empty, "
  "which is not a valid UUID\032\031!rules.uuid |"
  "| this != \'\'H\000R\004uuid\022\367\001\n\005tuuid\030! \001(\010B\336\001\302"
  "H\332\001\ns\n\014string.tuuid\022\"value must be a val"
  "id trimmed UUID\032\?!rules.tuuid || this =="
  " \'\' || this.matches(\'^[0-9a-fA-F]{32}$\')"
  "\nc\n\022string.tuuid_empty\0221value is empty, "
  "which is not a valid trimmed UUID\032\032!rule"
  "s.tuuid || this != \'\'H\000R\005tuuid\022\247\002\n\021ip_wi"
  "th_prefixlen\030\032 \001(\010B\370\001\302H\364\001\nx\n\030string.ip_w"
  "ith_prefixlen\022\037value must be a valid IP "
  "prefix\032;!rules.ip_with_prefixlen || this"
  " == \'\' || this.isIpPrefix()\nx\n\036string.ip"
  "_with_prefixlen_empty\022.value is empty, w"
  "hich is not a valid IP prefix\032&!rules.ip"
  "_with_prefixlen || this != \'\'H\000R\017ipWithP"
  "refixlen\022\342\002\n\023ipv4_with_prefixlen\030\033 \001(\010B\257"
  "\002\302H\253\002\n\223\001\n\032string.ipv4_with_prefixlen\0225va"
  "lue must be a valid IPv4 address with pr"
  "efix length\032>!rules.ipv4_with_prefixlen "
  "|| this == \'\' || this.isIpPrefix(4)\n\222\001\n "
  "string.ipv4_with_prefixlen_empty\022Dvalue "
  "is empty, which is not a valid IPv4 addr"
  "ess with prefix length\032(!rules.ipv4_with"
  "_prefixlen || this != \'\'H\000R\021ipv4WithPref"
  "ixlen\022\342\002\n\023ipv6_with_prefixlen\030\034 \001(\010B\257\002\302H"
  "\253\002\n\223\001\n\032string.ipv6_with_prefixlen\0225value"
  " must be a valid IPv6 address with prefi"
  "x length\032>!rules.ipv6_with_prefixlen || "
  "this == \'\' || this.isIpPrefix(6)\n\222\001\n str"
  "ing.ipv6_with_prefixlen_empty\022Dvalue is "
  "empty, which is not a valid IPv6 address"
  " with prefix length\032(!rules.ipv6_with_pr"
  "efixlen || this != \'\'H\000R\021ipv6WithPrefixl"
  "en\022\374\001\n\tip_prefix\030\035 \001(\010B\334\001\302H\330\001\nl\n\020string."
  "ip_prefix\022\037value must be a valid IP pref"
  "ix\0327!rules.ip_prefix || this == \'\' || th"
  "is.isIpPrefix(true)\nh\n\026string.ip_prefix_"
  "empty\022.value is empty, which is not a va"
  "lid IP prefix\032\036!rules.ip_prefix || this "
  "!= \'\'H\000R\010ipPrefix\022\217\002\n\013ipv4_prefix\030\036 \001(\010B"
  "\353\001\302H\347\001\nu\n\022string.ipv4_prefix\022!value must"
  " be a valid IPv4 prefix\032<!rules.ipv4_pre"
  "fix || this == \'\' || this.isIpPrefix(4, "
  "true)\nn\n\030string.ipv4_prefix_empty\0220value"
  " is empty, which is not a valid IPv4 pre"
  "fix\032 !rules.ipv4_prefix || this != \'\'H\000R"
  "\nipv4Prefix\022\217\002\n\013ipv6_prefix\030\037 \001(\010B\353\001\302H\347\001"
  "\nu\n\022string.ipv6_prefix\022!value must be a "
  "valid IPv6 prefix\032<!rules.ipv6_prefix ||"
  " this == \'\' || this.isIpPrefix(6, true)\n"
  "n\n\030string.ipv6_prefix_empty\0220value is em"
  "pty, which is not a valid IPv6 prefix\032 !"
  "rules.ipv6_prefix || this != \'\'H\000R\nipv6P"
  "refix\022\302\002\n\rhost_and_port\030  \001(\010B\233\002\302H\227\002\n\231\001\n"
  "\024string.host_and_port\022Avalue must be a v"
  "alid host (hostname or IP address) and p"
  "ort pair\032>!rules.host_and_port || this ="
  "= \'\' || this.isHostAndPort(true)\ny\n\032stri"
  "ng.host_and_port_empty\0227value is empty, "
  "which is not a valid host and port pair\032"
  "\"!rules.host_and_port || this != \'\'H\000R\013h"
  "ostAndPort\022\270\005\n\020well_known_regex\030\030 \001(\0162\030."
  "buf.validate.KnownRegexB\361\004\302H\355\004\n\360\001\n#strin"
  "g.well_known_regex.header_name\022&value mu"
  "st be a valid HTTP header name\032\240\001rules.w"
  "ell_known_regex != 1 || this == \'\' || th"
  "is.matches(!has(rules.strict) || rules.s"
  "trict \?\'^:\?[0-9a-zA-Z!#$%&\\\'*+-.^_|~\\x60"
  "]+$\' :\'^[^\\u0000\\u000A\\u000D]+$\')\n\215\001\n)st"
  "ring.well_known_regex.header_name_empty\022"
  "5value is empty, which is not a valid HT"
  "TP header name\032)rules.well_known_regex !"
  "= 1 || this != \'\'\n\347\001\n$string.well_known_"
  "regex.header_value\022\'value must be a vali"
  "d HTTP header value\032\225\001rules.well_known_r"
  "egex != 2 || this.matches(!has(rules.str"
  "ict) || rules.strict \?\'^[^\\u0000-\\u0008\\"
  "u000A-\\u001F\\u007F]*$\' :\'^[^\\u0000\\u000A"
  "\\u000D]*$\')H\000R\016wellKnownRegex\022\026\n\006strict\030"
  "\031 \001(\010R\006strict\0225\n\007example\030\" \003(\tB\033\302H\030\n\026\n\016s"
  "tring.example\032\004trueR\007example*\t\010\350\007\020\200\200\200\200\002B"
  "\014\n\nwell_known\"\316\021\n\nBytesRules\022\207\001\n\005const\030\001"
  " \001(\014Bq\302Hn\nl\n\013bytes.const\032]this != getFie"
  "ld(rules, \'const\') \? \'value must be %x\'."
  "format([getField(rules, \'const\')]) : \'\'R"
  "\005const\022}\n\003len\030\r \001(\004Bk\302Hh\nf\n\tbytes.len\032Yu"
  "int(this.size()) != rules.len \? \'value l"
  "ength must be %s bytes\'.format([rules.le"
  "n]) : \'\'R\003len\022\230\001\n\007min_len\030\002 \001(\004B\177\302H|\nz\n\r"
  "bytes.min_len\032iuint(this.size()) < rules"
  ".min_len \? \'value length must be at leas"
  "t %s bytes\'.format([rules.min_len]) : \'\'"
  "R\006minLen\022\220\001\n\007max_len\030\003 \001(\004Bw\302Ht\nr\n\rbytes"
  ".max_len\032auint(this.size()) > rules.max_"
  "len \? \'value must be at most %s bytes\'.f"
  "ormat([rules.max_len]) : \'\'R\006maxLen\022\231\001\n\007"
  "pattern\030\004 \001(\tB\177\302H|\nz\n\rbytes.pattern\032i!st"
  "ring(this).matches(rules.pattern) \? \'val"
  "ue must match regex pattern `%s`\'.format"
  "([rules.pattern]) : \'\'R\007pattern\022\211\001\n\006pref"
  "ix\030\005 \001(\014Bq\302Hn\nl\n\014bytes.prefix\032\\!this.sta"
  "rtsWith(rules.prefix) \? \'value does not "
  "have prefix %x\'.format([rules.prefix]) :"
  " \'\'R\006prefix\022\207\001\n\006suffix\030\006 \001(\014Bo\302Hl\nj\n\014byt"
  "es.suffix\032Z!this.endsWith(rules.suffix) "
  "\? \'value does not have suffix %x\'.format"
  "([rules.suffix]) : \'\'R\006suffix\022\215\001\n\010contai"
  "ns\030\007 \001(\014Bq\302Hn\nl\n\016bytes.contains\032Z!this.c"
  "ontains(rules.contains) \? \'value does no"
  "t contain %x\'.format([rules.contains]) :"
  " \'\'R\010contains\022\253\001\n\002in\030\010 \003(\014B\232\001\302H\226\001\n\223\001\n\010by"
  "tes.in\032\206\001getField(rules, \'in\').size() > "
  "0 && !(this in getField(rules, \'in\')) \? "
  "\'value must be in list %s\'.format([getFi"
  "eld(rules, \'in\')]) : \'\'R\002in\022}\n\006not_in\030\t "
  "\003(\014Bf\302Hc\na\n\014bytes.not_in\032Qthis in rules."
  "not_in \? \'value must not be in list %s\'."
  "format([rules.not_in]) : \'\'R\005notIn\022\357\001\n\002i"
  "p\030\n \001(\010B\334\001\302H\330\001\nt\n\010bytes.ip\022 value must b"
  "e a valid IP address\032F!rules.ip || this."
  "size() == 0 || this.size() == 4 || this."
  "size() == 16\n`\n\016bytes.ip_empty\022/value is"
  " empty, which is not a valid IP address\032"
  "\035!rules.ip || this.size() != 0H\000R\002ip\022\352\001\n"
  "\004ipv4\030\013 \001(\010B\323\001\302H\317\001\ne\n\nbytes.ipv4\022\"value "
  "must be a valid IPv4 address\0323!rules.ipv"
  "4 || this.size() == 0 || this.size() == "
  "4\nf\n\020bytes.ipv4_empty\0221value is empty, w"
  "hich is not a valid IPv4 address\032\037!rules"
  ".ipv4 || this.size() != 0H\000R\004ipv4\022\353\001\n\004ip"
  "v6\030\014 \001(\010B\324\001\302H\320\001\nf\n\nbytes.ipv6\022\"value mus"
  "t be a valid IPv6 address\0324!rules.ipv6 |"
  "| this.size() == 0 || this.size() == 16\n"
  "f\n\020bytes.ipv6_empty\0221value is empty, whi"
  "ch is not a valid IPv6 address\032\037!rules.i"
  "pv6 || this.size() != 0H\000R\004ipv6\0224\n\007examp"
  "le\030\016 \003(\014B\032\302H\027\n\025\n\rbytes.example\032\004trueR\007ex"
  "ample*\t\010\350\007\020\200\200\200\200\002B\014\n\nwell_known\"\375\003\n\tEnumR"
  "ules\022\211\001\n\005const\030\001 \001(\005Bs\302Hp\nn\n\nenum.const\032"
  "`this != getField(rules, \'const\') \? \'val"
  "ue must equal %s\'.format([getField(rules"
  ", \'const\')]) : \'\'R\005const\022!\n\014defined_only"
  "\030\002 \001(\010R\013definedOnly\022\202\001\n\002in\030\003 \003(\005Br\302Ho\nm\n"
  "\007enum.in\032b!(this in getField(rules, \'in\'"
  ")) \? \'value must be in list %s\'.format(["
  "getField(rules, \'in\')]) : \'\'R\002in\022|\n\006not_"
  "in\030\004 \003(\005Be\302Hb\n`\n\013enum.not_in\032Qthis in ru"
  "les.not_in \? \'value must not be in list "
  "%s\'.format([rules.not_in]) : \'\'R\005notIn\0223"
  "\n\007example\030\005 \003(\005B\031\302H\026\n\024\n\014enum.example\032\004tr"
  "ueR\007example*\t\010\350\007\020\200\200\200\200\002\"\236\004\n\rRepeatedRules"
  "\022\250\001\n\tmin_items\030\001 \001(\004B\212\001\302H\206\001\n\203\001\n\022repeated"
  ".min_items\032muint(this.size()) < rules.mi"
  "n_items \? \'value must contain at least %"
  "d item(s)\'.format([rules.min_items]) : \'"
  "\'R\010minItems\022\254\001\n\tmax_items\030\002 \001(\004B\216\001\302H\212\001\n\207"
  "\001\n\022repeated.max_items\032quint(this.size())"
  " > rules.max_items \? \'value must contain"
  " no more than %s item(s)\'.format([rules."
  "max_items]) : \'\'R\010maxItems\022x\n\006unique\030\003 \001"
  "(\010B`\302H]\n[\n\017repeated.unique\022(repeated val"
  "ue must contain unique items\032\036!rules.uni"
  "que || this.unique()R\006unique\022.\n\005items\030\004 "
  "\001(\0132\030.buf.validate.FieldRulesR\005items*\t\010\350"
  "\007\020\200\200\200\200\002\"\254\003\n\010MapRules\022\231\001\n\tmin_pairs\030\001 \001(\004"
  "B|\302Hy\nw\n\rmap.min_pairs\032fuint(this.size()"
  ") < rules.min_pairs \? \'map must be at le"
  "ast %d entries\'.format([rules.min_pairs]"
  ") : \'\'R\010minPairs\022\230\001\n\tmax_pairs\030\002 \001(\004B{\302H"
  "x\nv\n\rmap.max_pairs\032euint(this.size()) > "
  "rules.max_pairs \? \'map must be at most %"
  "d entries\'.format([rules.max_pairs]) : \'"
  "\'R\010maxPairs\022,\n\004keys\030\004 \001(\0132\030.buf.validate"
  ".FieldRulesR\004keys\0220\n\006values\030\005 \001(\0132\030.buf."
  "validate.FieldRulesR\006values*\t\010\350\007\020\200\200\200\200\002\"1"
  "\n\010AnyRules\022\016\n\002in\030\002 \003(\tR\002in\022\025\n\006not_in\030\003 \003"
  "(\tR\005notIn\"\306\027\n\rDurationRules\022\250\001\n\005const\030\002 "
  "\001(\0132\031.google.protobuf.DurationBw\302Ht\nr\n\016d"
  "uration.const\032`this != getField(rules, \'"
  "const\') \? \'value must equal %s\'.format(["
  "getField(rules, \'const\')]) : \'\'R\005const\022\254"
  "\001\n\002lt\030\003 \001(\0132\031.google.protobuf.DurationB\177"
  "\302H|\nz\n\013duration.lt\032k!has(rules.gte) && !"
  "has(rules.gt) && this >= rules.lt\? \'valu"
  "e must be less than %s\'.format([rules.lt"
  "]) : \'\'H\000R\002lt\022\277\001\n\003lte\030\004 \001(\0132\031.google.pro"
  "tobuf.DurationB\217\001\302H\213\001\n\210\001\n\014duration.lte\032x"
  "!has(rules.gte) && !has(rules.gt) && thi"
  "s > rules.lte\? \'value must be less than "
  "or equal to %s\'.format([rules.lte]) : \'\'"
  "H\000R\003lte\022\305\007\n\002gt\030\005 \001(\0132\031.google.protobuf.D"
  "urationB\227\007\302H\223\007\n}\n\013duration.gt\032n!has(rule"
  "s.lt) && !has(rules.lte) && this <= rule"
  "s.gt\? \'value must be greater than %s\'.fo"
  "rmat([rules.gt]) : \'\'\n\266\001\n\016duration.gt_lt"
  "\032\243\001has(rules.lt) && rules.lt >= rules.gt"
  " && (this >= rules.lt || this <= rules.g"
  "t)\? \'value must be greater than %s and l"
  "ess than %s\'.format([rules.gt, rules.lt]"
  ") : \'\'\n\276\001\n\030duration.gt_lt_exclusive\032\241\001ha"
  "s(rules.lt) && rules.lt < rules.gt && (r"
  "ules.lt <= this && this <= rules.gt)\? \'v"
  "alue must be greater than %s or less tha"
  "n %s\'.format([rules.gt, rules.lt]) : \'\'\n"
  "\306\001\n\017duration.gt_lte\032\262\001has(rules.lte) && "
  "rules.lte >= rules.gt && (this > rules.l"
  "te || this <= rules.gt)\? \'value must be "
  "greater than %s and less than or equal t"
  "o %s\'.format([rules.gt, rules.lte]) : \'\'"
  "\n\316\001\n\031duration.gt_lte_exclusive\032\260\001has(rul"
  "es.lte) && rules.lte < rules.gt && (rule"
  "s.lte < this && this <= rules.gt)\? \'valu"
  "e must be greater than %s or less than o"
  "r equal to %s\'.format([rules.gt, rules.l"
  "te]) : \'\'H\001R\002gt\022\222\010\n\003gte\030\006 \001(\0132\031.google.p"
  "rotobuf.DurationB\342\007\302H\336\007\n\213\001\n\014duration.gte"
  "\032{!has(rules.lt) && !has(rules.lte) && t"
  "his < rules.gte\? \'value must be greater "
  "than or equal to %s\'.format([rules.gte])"
  " : \'\'\n\305\001\n\017duration.gte_lt\032\261\001has(rules.lt"
  ") && rules.lt >= rules.gte && (this >= r"
  "ules.lt || this < rules.gte)\? \'value mus"
  "t be greater than or equal to %s and les"
  "s than %s\'.format([rules.gte, rules.lt])"
  " : \'\'\n\315\001\n\031duration.gte_lt_exclusive\032\257\001ha"
  "s(rules.lt) && rules.lt < rules.gte && ("
  "rules.lt <= this && this < rules.gte)\? \'"
  "value must be greater than or equal to %"
  "s or less than %s\'.format([rules.gte, ru"
  "les.lt]) : \'\'\n\325\001\n\020duration.gte_lte\032\300\001has"
  "(rules.lte) && rules.lte >= rules.gte &&"
  " (this > rules.lte || this < rules.gte)\?"
  " \'value must be greater than or equal to"
  " %s and less than or equal to %s\'.format"
  "([rules.gte, rules.lte]) : \'\'\n\335\001\n\032durati"
  "on.gte_lte_exclusive\032\276\001has(rules.lte) &&"
  " rules.lte < rules.gte && (rules.lte < t"
  "his && this < rules.gte)\? \'value must be"
  " greater than or equal to %s or less tha"
  "n or equal to %s\'.format([rules.gte, rul"
  "es.lte]) : \'\'H\001R\003gte\022\241\001\n\002in\030\007 \003(\0132\031.goog"
  "le.protobuf.DurationBv\302Hs\nq\n\013duration.in"
  "\032b!(this in getField(rules, \'in\')) \? \'va"
  "lue must be in list %s\'.format([getField"
  "(rules, \'in\')]) : \'\'R\002in\022\233\001\n\006not_in\030\010 \003("
  "\0132\031.google.protobuf.DurationBi\302Hf\nd\n\017dur"
  "ation.not_in\032Qthis in rules.not_in \? \'va"
  "lue must not be in list %s\'.format([rule"
  "s.not_in]) : \'\'R\005notIn\022R\n\007example\030\t \003(\0132"
  "\031.google.protobuf.DurationB\035\302H\032\n\030\n\020durat"
  "ion.example\032\004trueR\007example*\t\010\350\007\020\200\200\200\200\002B\013\n"
  "\tless_thanB\016\n\014greater_than\"\312\030\n\016Timestamp"
  "Rules\022\252\001\n\005const\030\002 \001(\0132\032.google.protobuf."
  "TimestampBx\302Hu\ns\n\017timestamp.const\032`this "
  "!= getField(rules, \'const\') \? \'value mus"
  "t equal %s\'.format([getField(rules, \'con"
  "st\')]) : \'\'R\005const\022\257\001\n\002lt\030\003 \001(\0132\032.google"
  ".protobuf.TimestampB\200\001\302H}\n{\n\014timestamp.l"
  "t\032k!has(rules.gte) && !has(rules.gt) && "
  "this >= rules.lt\? \'value must be less th"
  "an %s\'.format([rules.lt]) : \'\'H\000R\002lt\022\301\001\n"
  "\003lte\030\004 \001(\0132\032.google.protobuf.TimestampB\220"
  "\001\302H\214\001\n\211\001\n\rtimestamp.lte\032x!has(rules.gte)"
  " && !has(rules.gt) && this > rules.lte\? "
  "\'value must be less than or equal to %s\'"
  ".format([rules.lte]) : \'\'H\000R\003lte\022s\n\006lt_n"
  "ow\030\007 \001(\010BZ\302HW\nU\n\020timestamp.lt_now\032A(rule"
  "s.lt_now && this > now) \? \'value must be"
  " less than now\' : \'\'H\000R\005ltNow\022\313\007\n\002gt\030\005 \001"
  "(\0132\032.google.protobuf.TimestampB\234\007\302H\230\007\n~\n"
  "\014timestamp.gt\032n!has(rules.lt) && !has(ru"
  "les.lte) && this <= rules.gt\? \'value mus"
  "t be greater than %s\'.format([rules.gt])"
  " : \'\'\n\267\001\n\017timestamp.gt_lt\032\243\001has(rules.lt"
  ") && rules.lt >= rules.gt && (this >= ru"
  "les.lt || this <= rules.gt)\? \'value must"
  " be greater than %s and less than %s\'.fo"
  "rmat([rules.gt, rules.lt]) : \'\'\n\277\001\n\031time"
  "stamp.gt_lt_exclusive\032\241\001has(rules.lt) &&"
  " rules.lt < rules.gt && (rules.lt <= thi"
  "s && this <= rules.gt)\? \'value must be g"
  "reater than %s or less than %s\'.format(["
  "rules.gt, rules.lt]) : \'\'\n\307\001\n\020timestamp."
  "gt_lte\032\262\001has(rules.lte) && rules.lte >= "
  "rules.gt && (this > rules.lte || this <="
  " rules.gt)\? \'value must be greater than "
  "%s and less than or equal to %s\'.format("
  "[rules.gt, rules.lte]) : \'\'\n\317\001\n\032timestam"
  "p.gt_lte_exclusive\032\260\001has(rules.lte) && r"
  "ules.lte < rules.gt && (rules.lte < this"
  " && this <= rules.gt)\? \'value must be gr"
  "eater than %s or less than or equal to %"
  "s\'.format([rules.gt, rules.lte]) : \'\'H\001R"
  "\002gt\022\230\010\n\003gte\030\006 \001(\0132\032.google.protobuf.Time"
  "stampB\347\007\302H\343\007\n\214\001\n\rtimestamp.gte\032{!has(rul"
  "es.lt) && !has(rules.lte) && this < rule"
  "s.gte\? \'value must be greater than or eq"
  "ual to %s\'.format([rules.gte]) : \'\'\n\306\001\n\020"
  "timestamp.gte_lt\032\261\001has(rules.lt) && rule"
  "s.lt >= rules.gte && (this >= rules.lt |"
  "| this < rules.gte)\? \'value must be grea"
  "ter than or equal to %s and less than %s"
  "\'.format([rules.gte, rules.lt]) : \'\'\n\316\001\n"
  "\032timestamp.gte_lt_exclusive\032\257\001has(rules."
  "lt) && rules.lt < rules.gte && (rules.lt"
  " <= this && this < rules.gte)\? \'value mu"
  "st be greater than or equal to %s or les"
  "s than %s\'.format([rules.gte, rules.lt])"
  " : \'\'\n\326\001\n\021timestamp.gte_lte\032\300\001has(rules."
  "lte) && rules.lte >= rules.gte && (this "
  "> rules.lte || this < rules.gte)\? \'value"
  " must be greater than or equal to %s and"
  " less than or equal to %s\'.format([rules"
  ".gte, rules.lte]) : \'\'\n\336\001\n\033timestamp.gte"
  "_lte_exclusive\032\276\001has(rules.lte) && rules"
  ".lte < rules.gte && (rules.lte < this &&"
  " this < rules.gte)\? \'value must be great"
  "er than or equal to %s or less than or e"
  "qual to %s\'.format([rules.gte, rules.lte"
  "]) : \'\'H\001R\003gte\022v\n\006gt_now\030\010 \001(\010B]\302HZ\nX\n\020t"
  "imestamp.gt_now\032D(rules.gt_now && this <"
  " now) \? \'value must be greater than now\'"
  " : \'\'H\001R\005gtNow\022\300\001\n\006within\030\t \001(\0132\031.google"
  ".protobuf.DurationB\214\001\302H\210\001\n\205\001\n\020timestamp."
  "within\032qthis < now-rules.within || this "
  "> now+rules.within \? \'value must be with"
  "in %s of now\'.format([rules.within]) : \'"
  "\'R\006within\022T\n\007example\030\n \003(\0132\032.google.prot"
  "obuf.TimestampB\036\302H\033\n\031\n\021timestamp.example"
  "\032\004trueR\007example*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB"
  "\016\n\014greater_than\"E\n\nViolations\0227\n\nviolati"
  "ons\030\001 \003(\0132\027.buf.validate.ViolationR\nviol"
  "ations\"\305\001\n\tViolation\022-\n\005field\030\005 \001(\0132\027.bu"
  "f.validate.FieldPathR\005field\022+\n\004rule\030\006 \001("
  "\0132\027.buf.validate.FieldPathR\004rule\022\027\n\007rule"
  "_id\030\002 \001(\tR\006ruleId\022\030\n\007message\030\003 \001(\tR\007mess"
  "age\022\027\n\007for_key\030\004 \001(\010R\006forKeyJ\004\010\001\020\002R\nfiel"
  "d_path\"G\n\tFieldPath\022:\n\010elements\030\001 \003(\0132\036."
  "buf.validate.FieldPathElementR\010elements\""
  "\314\003\n\020FieldPathElement\022!\n\014field_number\030\001 \001"
  "(\005R\013fieldNumber\022\035\n\nfield_name\030\002 \001(\tR\tfie"
  "ldName\022I\n\nfield_type\030\003 \001(\0162*.google.prot"
  "obuf.FieldDescriptorProto.TypeR\tfieldTyp"
  "e\022E\n\010key_type\030\004 \001(\0162*.google.protobuf.Fi"
  "eldDescriptorProto.TypeR\007keyType\022I\n\nvalu"
  "e_type\030\005 \001(\0162*.google.protobuf.FieldDesc"
  "riptorProto.TypeR\tvalueType\022\026\n\005index\030\006 \001"
  "(\004H\000R\005index\022\033\n\010bool_key\030\007 \001(\010H\000R\007boolKey"
  "\022\031\n\007int_key\030\010 \001(\003H\000R\006intKey\022\033\n\010uint_key\030"
  "\t \001(\004H\000R\007uintKey\022\037\n\nstring_key\030\n \001(\tH\000R\t"
  "stringKeyB\013\n\tsubscript*\207\001\n\006Ignore\022\026\n\022IGN"
  "ORE_UNSPECIFIED\020\000\022\031\n\025IGNORE_IF_UNPOPULAT"
  "ED\020\001\022\033\n\027IGNORE_IF_DEFAULT_VALUE\020\002\022\021\n\rIGN"
  "ORE_ALWAYS\020\003*\032IGNORE_EMPTYIGNORE_DEFAULT"
  "*n\n\nKnownRegex\022\033\n\027KNOWN_REGEX_UNSPECIFIE"
  "D\020\000\022 \n\034KNOWN_REGEX_HTTP_HEADER_NAME\020\001\022!\n"
  "\035KNOWN_REGEX_HTTP_HEADER_VALUE\020\002:V\n\007mess"
  "age\022\037.google.protobuf.MessageOptions\030\207\t "
  "\001(\0132\032.buf.validate.MessageRulesR\007message"
  ":N\n\005oneof\022\035.google.protobuf.OneofOptions"
  "\030\207\t \001(\0132\030.buf.validate.OneofRulesR\005oneof"
  ":N\n\005field\022\035.google.protobuf.FieldOptions"
  "\030\207\t \001(\0132\030.buf.validate.FieldRulesR\005field"
  ":]\n\npredefined\022\035.google.protobuf.FieldOp"
  "tions\030\210\t \001(\0132\035.buf.validate.PredefinedRu"
  "lesR\npredefinedBn\n\022build.buf.validateB\rV"
  "alidateProtoP\001ZGbuf.build/gen/go/bufbuil"
  "d/protovalidate/protocolbuffers/go/buf/v"
  "alidate"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_buf_2fvalidate_2fvalidate_2eproto_deps[3] = {
  &::descriptor_table_google_2fprotobuf_2fdescriptor_2eproto,
  &::descriptor_table_google_2fprotobuf_2fduration_2eproto,
  &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_buf_2fvalidate_2fvalidate_2eproto_sccs[29] = {
  &scc_info_AnyRules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_BoolRules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_BytesRules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_DoubleRules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_DurationRules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_EnumRules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_FieldPath_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_FieldPathElement_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_FieldRules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_Fixed32Rules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_Fixed64Rules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_FloatRules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_Int32Rules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_Int64Rules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_MessageOneofRule_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_MessageRules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_OneofRules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_PredefinedRules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_Rule_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_SFixed32Rules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_SFixed64Rules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_SInt32Rules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_SInt64Rules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_StringRules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_TimestampRules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_UInt32Rules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_UInt64Rules_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_Violation_buf_2fvalidate_2fvalidate_2eproto.base,
  &scc_info_Violations_buf_2fvalidate_2fvalidate_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_buf_2fvalidate_2fvalidate_2eproto = {
  false, false, descriptor_table_protodef_buf_2fvalidate_2fvalidate_2eproto, "buf/validate/validate.proto", 54847,
  &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once, descriptor_table_buf_2fvalidate_2fvalidate_2eproto_sccs, descriptor_table_buf_2fvalidate_2fvalidate_2eproto_deps, 29, 3,
  schemas, file_default_instances, TableStruct_buf_2fvalidate_2fvalidate_2eproto::offsets,
  file_level_metadata_buf_2fvalidate_2fvalidate_2eproto, 31, file_level_enum_descriptors_buf_2fvalidate_2fvalidate_2eproto, file_level_service_descriptors_buf_2fvalidate_2fvalidate_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_buf_2fvalidate_2fvalidate_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_buf_2fvalidate_2fvalidate_2eproto)), true);
namespace buf {
namespace validate {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Ignore_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_buf_2fvalidate_2fvalidate_2eproto);
  return file_level_enum_descriptors_buf_2fvalidate_2fvalidate_2eproto[0];
}
bool Ignore_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KnownRegex_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_buf_2fvalidate_2fvalidate_2eproto);
  return file_level_enum_descriptors_buf_2fvalidate_2fvalidate_2eproto[1];
}
bool KnownRegex_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void Rule::InitAsDefaultInstance() {
}
class Rule::_Internal {
 public:
  using HasBits = decltype(std::declval<Rule>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_expression(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Rule::Rule(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Rule)
}
Rule::Rule(const Rule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_id()) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_id(),
      GetArena());
  }
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_message(),
      GetArena());
  }
  expression_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_expression()) {
    expression_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_expression(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.Rule)
}

void Rule::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Rule_buf_2fvalidate_2fvalidate_2eproto.base);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  expression_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

Rule::~Rule() {
  // @@protoc_insertion_point(destructor:buf.validate.Rule)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Rule::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  expression_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Rule::ArenaDtor(void* object) {
  Rule* _this = reinterpret_cast< Rule* >(object);
  (void)_this;
}
void Rule::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Rule::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Rule& Rule::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Rule_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void Rule::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Rule)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      expression_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Rule::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string id = 1[json_name = "id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.Rule.id");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string message = 2[json_name = "message"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.Rule.message");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string expression = 3[json_name = "expression"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_expression();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.Rule.expression");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Rule::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Rule)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string id = 1[json_name = "id"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.Rule.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional string message = 2[json_name = "message"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.Rule.message");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  // optional string expression = 3[json_name = "expression"];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_expression().data(), static_cast<int>(this->_internal_expression().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.Rule.expression");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_expression(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Rule)
  return target;
}

size_t Rule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Rule)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string id = 1[json_name = "id"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional string message = 2[json_name = "message"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional string expression = 3[json_name = "expression"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_expression());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Rule::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.Rule)
  GOOGLE_DCHECK_NE(&from, this);
  const Rule* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Rule>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.Rule)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.Rule)
    MergeFrom(*source);
  }
}

void Rule::MergeFrom(const Rule& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Rule)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_expression(from._internal_expression());
    }
  }
}

void Rule::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.Rule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Rule::CopyFrom(const Rule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Rule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Rule::IsInitialized() const {
  return true;
}

void Rule::InternalSwap(Rule* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  id_.Swap(&other->id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  message_.Swap(&other->message_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  expression_.Swap(&other->expression_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata Rule::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MessageRules::InitAsDefaultInstance() {
}
class MessageRules::_Internal {
 public:
  using HasBits = decltype(std::declval<MessageRules>()._has_bits_);
  static void set_has_disabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MessageRules::MessageRules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  cel_(arena),
  oneof_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.MessageRules)
}
MessageRules::MessageRules(const MessageRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      cel_(from.cel_),
      oneof_(from.oneof_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  disabled_ = from.disabled_;
  // @@protoc_insertion_point(copy_constructor:buf.validate.MessageRules)
}

void MessageRules::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MessageRules_buf_2fvalidate_2fvalidate_2eproto.base);
  disabled_ = false;
}

MessageRules::~MessageRules() {
  // @@protoc_insertion_point(destructor:buf.validate.MessageRules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MessageRules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void MessageRules::ArenaDtor(void* object) {
  MessageRules* _this = reinterpret_cast< MessageRules* >(object);
  (void)_this;
}
void MessageRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MessageRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MessageRules& MessageRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MessageRules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void MessageRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.MessageRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cel_.Clear();
  oneof_.Clear();
  disabled_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MessageRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool disabled = 1[json_name = "disabled"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_disabled(&has_bits);
          disabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .buf.validate.Rule cel = 3[json_name = "cel"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cel(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .buf.validate.MessageOneofRule oneof = 4[json_name = "oneof"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_oneof(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MessageRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.MessageRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool disabled = 1[json_name = "disabled"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_disabled(), target);
  }

  // repeated .buf.validate.Rule cel = 3[json_name = "cel"];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cel_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_cel(i), target, stream);
  }

  // repeated .buf.validate.MessageOneofRule oneof = 4[json_name = "oneof"];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_oneof_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_oneof(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.MessageRules)
  return target;
}

size_t MessageRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.MessageRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .buf.validate.Rule cel = 3[json_name = "cel"];
  total_size += 1UL * this->_internal_cel_size();
  for (const auto& msg : this->cel_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .buf.validate.MessageOneofRule oneof = 4[json_name = "oneof"];
  total_size += 1UL * this->_internal_oneof_size();
  for (const auto& msg : this->oneof_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool disabled = 1[json_name = "disabled"];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MessageRules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.MessageRules)
  GOOGLE_DCHECK_NE(&from, this);
  const MessageRules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MessageRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.MessageRules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.MessageRules)
    MergeFrom(*source);
  }
}

void MessageRules::MergeFrom(const MessageRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.MessageRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cel_.MergeFrom(from.cel_);
  oneof_.MergeFrom(from.oneof_);
  if (from._internal_has_disabled()) {
    _internal_set_disabled(from._internal_disabled());
  }
}

void MessageRules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.MessageRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MessageRules::CopyFrom(const MessageRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.MessageRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageRules::IsInitialized() const {
  return true;
}

void MessageRules::InternalSwap(MessageRules* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  cel_.InternalSwap(&other->cel_);
  oneof_.InternalSwap(&other->oneof_);
  swap(disabled_, other->disabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MessageRules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MessageOneofRule::InitAsDefaultInstance() {
}
class MessageOneofRule::_Internal {
 public:
  using HasBits = decltype(std::declval<MessageOneofRule>()._has_bits_);
  static void set_has_required(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MessageOneofRule::MessageOneofRule(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  fields_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.MessageOneofRule)
}
MessageOneofRule::MessageOneofRule(const MessageOneofRule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      fields_(from.fields_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  required_ = from.required_;
  // @@protoc_insertion_point(copy_constructor:buf.validate.MessageOneofRule)
}

void MessageOneofRule::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MessageOneofRule_buf_2fvalidate_2fvalidate_2eproto.base);
  required_ = false;
}

MessageOneofRule::~MessageOneofRule() {
  // @@protoc_insertion_point(destructor:buf.validate.MessageOneofRule)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MessageOneofRule::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void MessageOneofRule::ArenaDtor(void* object) {
  MessageOneofRule* _this = reinterpret_cast< MessageOneofRule* >(object);
  (void)_this;
}
void MessageOneofRule::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MessageOneofRule::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MessageOneofRule& MessageOneofRule::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MessageOneofRule_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void MessageOneofRule::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.MessageOneofRule)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fields_.Clear();
  required_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MessageOneofRule::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated string fields = 1[json_name = "fields"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_fields();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.MessageOneofRule.fields");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool required = 2[json_name = "required"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_required(&has_bits);
          required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MessageOneofRule::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.MessageOneofRule)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string fields = 1[json_name = "fields"];
  for (int i = 0, n = this->_internal_fields_size(); i < n; i++) {
    const auto& s = this->_internal_fields(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.MessageOneofRule.fields");
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool required = 2[json_name = "required"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_required(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.MessageOneofRule)
  return target;
}

size_t MessageOneofRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.MessageOneofRule)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string fields = 1[json_name = "fields"];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(fields_.size());
  for (int i = 0, n = fields_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      fields_.Get(i));
  }

  // optional bool required = 2[json_name = "required"];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MessageOneofRule::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.MessageOneofRule)
  GOOGLE_DCHECK_NE(&from, this);
  const MessageOneofRule* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MessageOneofRule>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.MessageOneofRule)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.MessageOneofRule)
    MergeFrom(*source);
  }
}

void MessageOneofRule::MergeFrom(const MessageOneofRule& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.MessageOneofRule)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  fields_.MergeFrom(from.fields_);
  if (from._internal_has_required()) {
    _internal_set_required(from._internal_required());
  }
}

void MessageOneofRule::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.MessageOneofRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MessageOneofRule::CopyFrom(const MessageOneofRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.MessageOneofRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageOneofRule::IsInitialized() const {
  return true;
}

void MessageOneofRule::InternalSwap(MessageOneofRule* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  fields_.InternalSwap(&other->fields_);
  swap(required_, other->required_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MessageOneofRule::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void OneofRules::InitAsDefaultInstance() {
}
class OneofRules::_Internal {
 public:
  using HasBits = decltype(std::declval<OneofRules>()._has_bits_);
  static void set_has_required(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OneofRules::OneofRules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.OneofRules)
}
OneofRules::OneofRules(const OneofRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  required_ = from.required_;
  // @@protoc_insertion_point(copy_constructor:buf.validate.OneofRules)
}

void OneofRules::SharedCtor() {
  required_ = false;
}

OneofRules::~OneofRules() {
  // @@protoc_insertion_point(destructor:buf.validate.OneofRules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void OneofRules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void OneofRules::ArenaDtor(void* object) {
  OneofRules* _this = reinterpret_cast< OneofRules* >(object);
  (void)_this;
}
void OneofRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OneofRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const OneofRules& OneofRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_OneofRules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void OneofRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.OneofRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  required_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OneofRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool required = 1[json_name = "required"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_required(&has_bits);
          required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* OneofRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.OneofRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool required = 1[json_name = "required"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_required(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.OneofRules)
  return target;
}

size_t OneofRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.OneofRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool required = 1[json_name = "required"];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OneofRules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.OneofRules)
  GOOGLE_DCHECK_NE(&from, this);
  const OneofRules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<OneofRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.OneofRules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.OneofRules)
    MergeFrom(*source);
  }
}

void OneofRules::MergeFrom(const OneofRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.OneofRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_required()) {
    _internal_set_required(from._internal_required());
  }
}

void OneofRules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.OneofRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OneofRules::CopyFrom(const OneofRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.OneofRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OneofRules::IsInitialized() const {
  return true;
}

void OneofRules::InternalSwap(OneofRules* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(required_, other->required_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OneofRules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void FieldRules::InitAsDefaultInstance() {
  ::buf::validate::_FieldRules_default_instance_.float__ = const_cast< ::buf::validate::FloatRules*>(
      ::buf::validate::FloatRules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.double__ = const_cast< ::buf::validate::DoubleRules*>(
      ::buf::validate::DoubleRules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.int32_ = const_cast< ::buf::validate::Int32Rules*>(
      ::buf::validate::Int32Rules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.int64_ = const_cast< ::buf::validate::Int64Rules*>(
      ::buf::validate::Int64Rules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.uint32_ = const_cast< ::buf::validate::UInt32Rules*>(
      ::buf::validate::UInt32Rules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.uint64_ = const_cast< ::buf::validate::UInt64Rules*>(
      ::buf::validate::UInt64Rules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.sint32_ = const_cast< ::buf::validate::SInt32Rules*>(
      ::buf::validate::SInt32Rules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.sint64_ = const_cast< ::buf::validate::SInt64Rules*>(
      ::buf::validate::SInt64Rules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.fixed32_ = const_cast< ::buf::validate::Fixed32Rules*>(
      ::buf::validate::Fixed32Rules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.fixed64_ = const_cast< ::buf::validate::Fixed64Rules*>(
      ::buf::validate::Fixed64Rules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.sfixed32_ = const_cast< ::buf::validate::SFixed32Rules*>(
      ::buf::validate::SFixed32Rules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.sfixed64_ = const_cast< ::buf::validate::SFixed64Rules*>(
      ::buf::validate::SFixed64Rules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.bool__ = const_cast< ::buf::validate::BoolRules*>(
      ::buf::validate::BoolRules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.string_ = const_cast< ::buf::validate::StringRules*>(
      ::buf::validate::StringRules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.bytes_ = const_cast< ::buf::validate::BytesRules*>(
      ::buf::validate::BytesRules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.enum__ = const_cast< ::buf::validate::EnumRules*>(
      ::buf::validate::EnumRules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.repeated_ = const_cast< ::buf::validate::RepeatedRules*>(
      ::buf::validate::RepeatedRules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.map_ = const_cast< ::buf::validate::MapRules*>(
      ::buf::validate::MapRules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.any_ = const_cast< ::buf::validate::AnyRules*>(
      ::buf::validate::AnyRules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.duration_ = const_cast< ::buf::validate::DurationRules*>(
      ::buf::validate::DurationRules::internal_default_instance());
  ::buf::validate::_FieldRules_default_instance_.timestamp_ = const_cast< ::buf::validate::TimestampRules*>(
      ::buf::validate::TimestampRules::internal_default_instance());
}
class FieldRules::_Internal {
 public:
  using HasBits = decltype(std::declval<FieldRules>()._has_bits_);
  static void set_has_required(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ignore(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::buf::validate::FloatRules& float_(const FieldRules* msg);
  static const ::buf::validate::DoubleRules& double_(const FieldRules* msg);
  static const ::buf::validate::Int32Rules& int32(const FieldRules* msg);
  static const ::buf::validate::Int64Rules& int64(const FieldRules* msg);
  static const ::buf::validate::UInt32Rules& uint32(const FieldRules* msg);
  static const ::buf::validate::UInt64Rules& uint64(const FieldRules* msg);
  static const ::buf::validate::SInt32Rules& sint32(const FieldRules* msg);
  static const ::buf::validate::SInt64Rules& sint64(const FieldRules* msg);
  static const ::buf::validate::Fixed32Rules& fixed32(const FieldRules* msg);
  static const ::buf::validate::Fixed64Rules& fixed64(const FieldRules* msg);
  static const ::buf::validate::SFixed32Rules& sfixed32(const FieldRules* msg);
  static const ::buf::validate::SFixed64Rules& sfixed64(const FieldRules* msg);
  static const ::buf::validate::BoolRules& bool_(const FieldRules* msg);
  static const ::buf::validate::StringRules& string(const FieldRules* msg);
  static const ::buf::validate::BytesRules& bytes(const FieldRules* msg);
  static const ::buf::validate::EnumRules& enum_(const FieldRules* msg);
  static const ::buf::validate::RepeatedRules& repeated(const FieldRules* msg);
  static const ::buf::validate::MapRules& map(const FieldRules* msg);
  static const ::buf::validate::AnyRules& any(const FieldRules* msg);
  static const ::buf::validate::DurationRules& duration(const FieldRules* msg);
  static const ::buf::validate::TimestampRules& timestamp(const FieldRules* msg);
};

const ::buf::validate::FloatRules&
FieldRules::_Internal::float_(const FieldRules* msg) {
  return *msg->type_.float__;
}
const ::buf::validate::DoubleRules&
FieldRules::_Internal::double_(const FieldRules* msg) {
  return *msg->type_.double__;
}
const ::buf::validate::Int32Rules&
FieldRules::_Internal::int32(const FieldRules* msg) {
  return *msg->type_.int32_;
}
const ::buf::validate::Int64Rules&
FieldRules::_Internal::int64(const FieldRules* msg) {
  return *msg->type_.int64_;
}
const ::buf::validate::UInt32Rules&
FieldRules::_Internal::uint32(const FieldRules* msg) {
  return *msg->type_.uint32_;
}
const ::buf::validate::UInt64Rules&
FieldRules::_Internal::uint64(const FieldRules* msg) {
  return *msg->type_.uint64_;
}
const ::buf::validate::SInt32Rules&
FieldRules::_Internal::sint32(const FieldRules* msg) {
  return *msg->type_.sint32_;
}
const ::buf::validate::SInt64Rules&
FieldRules::_Internal::sint64(const FieldRules* msg) {
  return *msg->type_.sint64_;
}
const ::buf::validate::Fixed32Rules&
FieldRules::_Internal::fixed32(const FieldRules* msg) {
  return *msg->type_.fixed32_;
}
const ::buf::validate::Fixed64Rules&
FieldRules::_Internal::fixed64(const FieldRules* msg) {
  return *msg->type_.fixed64_;
}
const ::buf::validate::SFixed32Rules&
FieldRules::_Internal::sfixed32(const FieldRules* msg) {
  return *msg->type_.sfixed32_;
}
const ::buf::validate::SFixed64Rules&
FieldRules::_Internal::sfixed64(const FieldRules* msg) {
  return *msg->type_.sfixed64_;
}
const ::buf::validate::BoolRules&
FieldRules::_Internal::bool_(const FieldRules* msg) {
  return *msg->type_.bool__;
}
const ::buf::validate::StringRules&
FieldRules::_Internal::string(const FieldRules* msg) {
  return *msg->type_.string_;
}
const ::buf::validate::BytesRules&
FieldRules::_Internal::bytes(const FieldRules* msg) {
  return *msg->type_.bytes_;
}
const ::buf::validate::EnumRules&
FieldRules::_Internal::enum_(const FieldRules* msg) {
  return *msg->type_.enum__;
}
const ::buf::validate::RepeatedRules&
FieldRules::_Internal::repeated(const FieldRules* msg) {
  return *msg->type_.repeated_;
}
const ::buf::validate::MapRules&
FieldRules::_Internal::map(const FieldRules* msg) {
  return *msg->type_.map_;
}
const ::buf::validate::AnyRules&
FieldRules::_Internal::any(const FieldRules* msg) {
  return *msg->type_.any_;
}
const ::buf::validate::DurationRules&
FieldRules::_Internal::duration(const FieldRules* msg) {
  return *msg->type_.duration_;
}
const ::buf::validate::TimestampRules&
FieldRules::_Internal::timestamp(const FieldRules* msg) {
  return *msg->type_.timestamp_;
}
void FieldRules::set_allocated_float_(::buf::validate::FloatRules* float_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (float_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(float_);
    if (message_arena != submessage_arena) {
      float_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, float_, submessage_arena);
    }
    set_has_float_();
    type_.float__ = float_;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.float)
}
void FieldRules::set_allocated_double_(::buf::validate::DoubleRules* double_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (double_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(double_);
    if (message_arena != submessage_arena) {
      double_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, double_, submessage_arena);
    }
    set_has_double_();
    type_.double__ = double_;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.double)
}
void FieldRules::set_allocated_int32(::buf::validate::Int32Rules* int32) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (int32) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(int32);
    if (message_arena != submessage_arena) {
      int32 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, int32, submessage_arena);
    }
    set_has_int32();
    type_.int32_ = int32;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.int32)
}
void FieldRules::set_allocated_int64(::buf::validate::Int64Rules* int64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (int64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(int64);
    if (message_arena != submessage_arena) {
      int64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, int64, submessage_arena);
    }
    set_has_int64();
    type_.int64_ = int64;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.int64)
}
void FieldRules::set_allocated_uint32(::buf::validate::UInt32Rules* uint32) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (uint32) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(uint32);
    if (message_arena != submessage_arena) {
      uint32 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uint32, submessage_arena);
    }
    set_has_uint32();
    type_.uint32_ = uint32;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.uint32)
}
void FieldRules::set_allocated_uint64(::buf::validate::UInt64Rules* uint64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (uint64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(uint64);
    if (message_arena != submessage_arena) {
      uint64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uint64, submessage_arena);
    }
    set_has_uint64();
    type_.uint64_ = uint64;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.uint64)
}
void FieldRules::set_allocated_sint32(::buf::validate::SInt32Rules* sint32) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (sint32) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sint32);
    if (message_arena != submessage_arena) {
      sint32 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sint32, submessage_arena);
    }
    set_has_sint32();
    type_.sint32_ = sint32;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.sint32)
}
void FieldRules::set_allocated_sint64(::buf::validate::SInt64Rules* sint64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (sint64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sint64);
    if (message_arena != submessage_arena) {
      sint64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sint64, submessage_arena);
    }
    set_has_sint64();
    type_.sint64_ = sint64;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.sint64)
}
void FieldRules::set_allocated_fixed32(::buf::validate::Fixed32Rules* fixed32) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (fixed32) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fixed32);
    if (message_arena != submessage_arena) {
      fixed32 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fixed32, submessage_arena);
    }
    set_has_fixed32();
    type_.fixed32_ = fixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.fixed32)
}
void FieldRules::set_allocated_fixed64(::buf::validate::Fixed64Rules* fixed64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (fixed64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fixed64);
    if (message_arena != submessage_arena) {
      fixed64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fixed64, submessage_arena);
    }
    set_has_fixed64();
    type_.fixed64_ = fixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.fixed64)
}
void FieldRules::set_allocated_sfixed32(::buf::validate::SFixed32Rules* sfixed32) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (sfixed32) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sfixed32);
    if (message_arena != submessage_arena) {
      sfixed32 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sfixed32, submessage_arena);
    }
    set_has_sfixed32();
    type_.sfixed32_ = sfixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.sfixed32)
}
void FieldRules::set_allocated_sfixed64(::buf::validate::SFixed64Rules* sfixed64) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (sfixed64) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sfixed64);
    if (message_arena != submessage_arena) {
      sfixed64 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sfixed64, submessage_arena);
    }
    set_has_sfixed64();
    type_.sfixed64_ = sfixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.sfixed64)
}
void FieldRules::set_allocated_bool_(::buf::validate::BoolRules* bool_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (bool_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bool_);
    if (message_arena != submessage_arena) {
      bool_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bool_, submessage_arena);
    }
    set_has_bool_();
    type_.bool__ = bool_;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.bool)
}
void FieldRules::set_allocated_string(::buf::validate::StringRules* string) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (string) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(string);
    if (message_arena != submessage_arena) {
      string = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, string, submessage_arena);
    }
    set_has_string();
    type_.string_ = string;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.string)
}
void FieldRules::set_allocated_bytes(::buf::validate::BytesRules* bytes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (bytes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bytes);
    if (message_arena != submessage_arena) {
      bytes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bytes, submessage_arena);
    }
    set_has_bytes();
    type_.bytes_ = bytes;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.bytes)
}
void FieldRules::set_allocated_enum_(::buf::validate::EnumRules* enum_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (enum_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(enum_);
    if (message_arena != submessage_arena) {
      enum_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enum_, submessage_arena);
    }
    set_has_enum_();
    type_.enum__ = enum_;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.enum)
}
void FieldRules::set_allocated_repeated(::buf::validate::RepeatedRules* repeated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (repeated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(repeated);
    if (message_arena != submessage_arena) {
      repeated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repeated, submessage_arena);
    }
    set_has_repeated();
    type_.repeated_ = repeated;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.repeated)
}
void FieldRules::set_allocated_map(::buf::validate::MapRules* map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(map);
    if (message_arena != submessage_arena) {
      map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    set_has_map();
    type_.map_ = map;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.map)
}
void FieldRules::set_allocated_any(::buf::validate::AnyRules* any) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (any) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(any);
    if (message_arena != submessage_arena) {
      any = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, any, submessage_arena);
    }
    set_has_any();
    type_.any_ = any;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.any)
}
void FieldRules::set_allocated_duration(::buf::validate::DurationRules* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(duration);
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    set_has_duration();
    type_.duration_ = duration;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.duration)
}
void FieldRules::set_allocated_timestamp(::buf::validate::TimestampRules* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_type();
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(timestamp);
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    set_has_timestamp();
    type_.timestamp_ = timestamp;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldRules.timestamp)
}
FieldRules::FieldRules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  cel_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.FieldRules)
}
FieldRules::FieldRules(const FieldRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      cel_(from.cel_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&required_, &from.required_,
    static_cast<size_t>(reinterpret_cast<char*>(&ignore_) -
    reinterpret_cast<char*>(&required_)) + sizeof(ignore_));
  clear_has_type();
  switch (from.type_case()) {
    case kFloat: {
      _internal_mutable_float_()->::buf::validate::FloatRules::MergeFrom(from._internal_float_());
      break;
    }
    case kDouble: {
      _internal_mutable_double_()->::buf::validate::DoubleRules::MergeFrom(from._internal_double_());
      break;
    }
    case kInt32: {
      _internal_mutable_int32()->::buf::validate::Int32Rules::MergeFrom(from._internal_int32());
      break;
    }
    case kInt64: {
      _internal_mutable_int64()->::buf::validate::Int64Rules::MergeFrom(from._internal_int64());
      break;
    }
    case kUint32: {
      _internal_mutable_uint32()->::buf::validate::UInt32Rules::MergeFrom(from._internal_uint32());
      break;
    }
    case kUint64: {
      _internal_mutable_uint64()->::buf::validate::UInt64Rules::MergeFrom(from._internal_uint64());
      break;
    }
    case kSint32: {
      _internal_mutable_sint32()->::buf::validate::SInt32Rules::MergeFrom(from._internal_sint32());
      break;
    }
    case kSint64: {
      _internal_mutable_sint64()->::buf::validate::SInt64Rules::MergeFrom(from._internal_sint64());
      break;
    }
    case kFixed32: {
      _internal_mutable_fixed32()->::buf::validate::Fixed32Rules::MergeFrom(from._internal_fixed32());
      break;
    }
    case kFixed64: {
      _internal_mutable_fixed64()->::buf::validate::Fixed64Rules::MergeFrom(from._internal_fixed64());
      break;
    }
    case kSfixed32: {
      _internal_mutable_sfixed32()->::buf::validate::SFixed32Rules::MergeFrom(from._internal_sfixed32());
      break;
    }
    case kSfixed64: {
      _internal_mutable_sfixed64()->::buf::validate::SFixed64Rules::MergeFrom(from._internal_sfixed64());
      break;
    }
    case kBool: {
      _internal_mutable_bool_()->::buf::validate::BoolRules::MergeFrom(from._internal_bool_());
      break;
    }
    case kString: {
      _internal_mutable_string()->::buf::validate::StringRules::MergeFrom(from._internal_string());
      break;
    }
    case kBytes: {
      _internal_mutable_bytes()->::buf::validate::BytesRules::MergeFrom(from._internal_bytes());
      break;
    }
    case kEnum: {
      _internal_mutable_enum_()->::buf::validate::EnumRules::MergeFrom(from._internal_enum_());
      break;
    }
    case kRepeated: {
      _internal_mutable_repeated()->::buf::validate::RepeatedRules::MergeFrom(from._internal_repeated());
      break;
    }
    case kMap: {
      _internal_mutable_map()->::buf::validate::MapRules::MergeFrom(from._internal_map());
      break;
    }
    case kAny: {
      _internal_mutable_any()->::buf::validate::AnyRules::MergeFrom(from._internal_any());
      break;
    }
    case kDuration: {
      _internal_mutable_duration()->::buf::validate::DurationRules::MergeFrom(from._internal_duration());
      break;
    }
    case kTimestamp: {
      _internal_mutable_timestamp()->::buf::validate::TimestampRules::MergeFrom(from._internal_timestamp());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.FieldRules)
}

void FieldRules::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FieldRules_buf_2fvalidate_2fvalidate_2eproto.base);
  ::memset(&required_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ignore_) -
      reinterpret_cast<char*>(&required_)) + sizeof(ignore_));
  clear_has_type();
}

FieldRules::~FieldRules() {
  // @@protoc_insertion_point(destructor:buf.validate.FieldRules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void FieldRules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_type()) {
    clear_type();
  }
}

void FieldRules::ArenaDtor(void* object) {
  FieldRules* _this = reinterpret_cast< FieldRules* >(object);
  (void)_this;
}
void FieldRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FieldRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FieldRules& FieldRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FieldRules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void FieldRules::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.FieldRules)
  switch (type_case()) {
    case kFloat: {
      if (GetArena() == nullptr) {
        delete type_.float__;
      }
      break;
    }
    case kDouble: {
      if (GetArena() == nullptr) {
        delete type_.double__;
      }
      break;
    }
    case kInt32: {
      if (GetArena() == nullptr) {
        delete type_.int32_;
      }
      break;
    }
    case kInt64: {
      if (GetArena() == nullptr) {
        delete type_.int64_;
      }
      break;
    }
    case kUint32: {
      if (GetArena() == nullptr) {
        delete type_.uint32_;
      }
      break;
    }
    case kUint64: {
      if (GetArena() == nullptr) {
        delete type_.uint64_;
      }
      break;
    }
    case kSint32: {
      if (GetArena() == nullptr) {
        delete type_.sint32_;
      }
      break;
    }
    case kSint64: {
      if (GetArena() == nullptr) {
        delete type_.sint64_;
      }
      break;
    }
    case kFixed32: {
      if (GetArena() == nullptr) {
        delete type_.fixed32_;
      }
      break;
    }
    case kFixed64: {
      if (GetArena() == nullptr) {
        delete type_.fixed64_;
      }
      break;
    }
    case kSfixed32: {
      if (GetArena() == nullptr) {
        delete type_.sfixed32_;
      }
      break;
    }
    case kSfixed64: {
      if (GetArena() == nullptr) {
        delete type_.sfixed64_;
      }
      break;
    }
    case kBool: {
      if (GetArena() == nullptr) {
        delete type_.bool__;
      }
      break;
    }
    case kString: {
      if (GetArena() == nullptr) {
        delete type_.string_;
      }
      break;
    }
    case kBytes: {
      if (GetArena() == nullptr) {
        delete type_.bytes_;
      }
      break;
    }
    case kEnum: {
      if (GetArena() == nullptr) {
        delete type_.enum__;
      }
      break;
    }
    case kRepeated: {
      if (GetArena() == nullptr) {
        delete type_.repeated_;
      }
      break;
    }
    case kMap: {
      if (GetArena() == nullptr) {
        delete type_.map_;
      }
      break;
    }
    case kAny: {
      if (GetArena() == nullptr) {
        delete type_.any_;
      }
      break;
    }
    case kDuration: {
      if (GetArena() == nullptr) {
        delete type_.duration_;
      }
      break;
    }
    case kTimestamp: {
      if (GetArena() == nullptr) {
        delete type_.timestamp_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void FieldRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.FieldRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cel_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&required_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ignore_) -
        reinterpret_cast<char*>(&required_)) + sizeof(ignore_));
  }
  clear_type();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FieldRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .buf.validate.FloatRules float = 1[json_name = "float"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_float_(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.DoubleRules double = 2[json_name = "double"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_double_(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.Int32Rules int32 = 3[json_name = "int32"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_int32(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.Int64Rules int64 = 4[json_name = "int64"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_int64(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.UInt32Rules uint32 = 5[json_name = "uint32"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_uint32(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.UInt64Rules uint64 = 6[json_name = "uint64"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_uint64(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.SInt32Rules sint32 = 7[json_name = "sint32"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_sint32(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.SInt64Rules sint64 = 8[json_name = "sint64"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_sint64(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.Fixed32Rules fixed32 = 9[json_name = "fixed32"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_fixed32(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.Fixed64Rules fixed64 = 10[json_name = "fixed64"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_fixed64(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.SFixed32Rules sfixed32 = 11[json_name = "sfixed32"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_sfixed32(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.SFixed64Rules sfixed64 = 12[json_name = "sfixed64"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_sfixed64(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.BoolRules bool = 13[json_name = "bool"];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_bool_(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.StringRules string = 14[json_name = "string"];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_string(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.BytesRules bytes = 15[json_name = "bytes"];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_bytes(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.EnumRules enum = 16[json_name = "enum"];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_enum_(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.RepeatedRules repeated = 18[json_name = "repeated"];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_repeated(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.MapRules map = 19[json_name = "map"];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_map(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.AnyRules any = 20[json_name = "any"];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_any(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.DurationRules duration = 21[json_name = "duration"];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_duration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.TimestampRules timestamp = 22[json_name = "timestamp"];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .buf.validate.Rule cel = 23[json_name = "cel"];
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 186)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_cel(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<186>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool required = 25[json_name = "required"];
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 200)) {
          _Internal::set_has_required(&has_bits);
          required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .buf.validate.Ignore ignore = 27[json_name = "ignore"];
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 216)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::buf::validate::Ignore_IsValid(val))) {
            _internal_set_ignore(static_cast<::buf::validate::Ignore>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(27, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FieldRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.FieldRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (type_case()) {
    case kFloat: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          1, _Internal::float_(this), target, stream);
      break;
    }
    case kDouble: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          2, _Internal::double_(this), target, stream);
      break;
    }
    case kInt32: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          3, _Internal::int32(this), target, stream);
      break;
    }
    case kInt64: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          4, _Internal::int64(this), target, stream);
      break;
    }
    case kUint32: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          5, _Internal::uint32(this), target, stream);
      break;
    }
    case kUint64: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          6, _Internal::uint64(this), target, stream);
      break;
    }
    case kSint32: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          7, _Internal::sint32(this), target, stream);
      break;
    }
    case kSint64: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          8, _Internal::sint64(this), target, stream);
      break;
    }
    case kFixed32: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          9, _Internal::fixed32(this), target, stream);
      break;
    }
    case kFixed64: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          10, _Internal::fixed64(this), target, stream);
      break;
    }
    case kSfixed32: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          11, _Internal::sfixed32(this), target, stream);
      break;
    }
    case kSfixed64: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          12, _Internal::sfixed64(this), target, stream);
      break;
    }
    case kBool: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          13, _Internal::bool_(this), target, stream);
      break;
    }
    case kString: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          14, _Internal::string(this), target, stream);
      break;
    }
    case kBytes: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          15, _Internal::bytes(this), target, stream);
      break;
    }
    case kEnum: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          16, _Internal::enum_(this), target, stream);
      break;
    }
    case kRepeated: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          18, _Internal::repeated(this), target, stream);
      break;
    }
    case kMap: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          19, _Internal::map(this), target, stream);
      break;
    }
    case kAny: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          20, _Internal::any(this), target, stream);
      break;
    }
    case kDuration: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          21, _Internal::duration(this), target, stream);
      break;
    }
    case kTimestamp: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          22, _Internal::timestamp(this), target, stream);
      break;
    }
    default: ;
  }
  // repeated .buf.validate.Rule cel = 23[json_name = "cel"];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cel_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, this->_internal_cel(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool required = 25[json_name = "required"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(25, this->_internal_required(), target);
  }

  // optional .buf.validate.Ignore ignore = 27[json_name = "ignore"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      27, this->_internal_ignore(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.FieldRules)
  return target;
}

size_t FieldRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.FieldRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .buf.validate.Rule cel = 23[json_name = "cel"];
  total_size += 2UL * this->_internal_cel_size();
  for (const auto& msg : this->cel_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool required = 25[json_name = "required"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 1;
    }

    // optional .buf.validate.Ignore ignore = 27[json_name = "ignore"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_ignore());
    }

  }
  switch (type_case()) {
    // .buf.validate.FloatRules float = 1[json_name = "float"];
    case kFloat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.float__);
      break;
    }
    // .buf.validate.DoubleRules double = 2[json_name = "double"];
    case kDouble: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.double__);
      break;
    }
    // .buf.validate.Int32Rules int32 = 3[json_name = "int32"];
    case kInt32: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.int32_);
      break;
    }
    // .buf.validate.Int64Rules int64 = 4[json_name = "int64"];
    case kInt64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.int64_);
      break;
    }
    // .buf.validate.UInt32Rules uint32 = 5[json_name = "uint32"];
    case kUint32: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.uint32_);
      break;
    }
    // .buf.validate.UInt64Rules uint64 = 6[json_name = "uint64"];
    case kUint64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.uint64_);
      break;
    }
    // .buf.validate.SInt32Rules sint32 = 7[json_name = "sint32"];
    case kSint32: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.sint32_);
      break;
    }
    // .buf.validate.SInt64Rules sint64 = 8[json_name = "sint64"];
    case kSint64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.sint64_);
      break;
    }
    // .buf.validate.Fixed32Rules fixed32 = 9[json_name = "fixed32"];
    case kFixed32: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.fixed32_);
      break;
    }
    // .buf.validate.Fixed64Rules fixed64 = 10[json_name = "fixed64"];
    case kFixed64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.fixed64_);
      break;
    }
    // .buf.validate.SFixed32Rules sfixed32 = 11[json_name = "sfixed32"];
    case kSfixed32: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.sfixed32_);
      break;
    }
    // .buf.validate.SFixed64Rules sfixed64 = 12[json_name = "sfixed64"];
    case kSfixed64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.sfixed64_);
      break;
    }
    // .buf.validate.BoolRules bool = 13[json_name = "bool"];
    case kBool: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.bool__);
      break;
    }
    // .buf.validate.StringRules string = 14[json_name = "string"];
    case kString: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.string_);
      break;
    }
    // .buf.validate.BytesRules bytes = 15[json_name = "bytes"];
    case kBytes: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.bytes_);
      break;
    }
    // .buf.validate.EnumRules enum = 16[json_name = "enum"];
    case kEnum: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.enum__);
      break;
    }
    // .buf.validate.RepeatedRules repeated = 18[json_name = "repeated"];
    case kRepeated: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.repeated_);
      break;
    }
    // .buf.validate.MapRules map = 19[json_name = "map"];
    case kMap: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.map_);
      break;
    }
    // .buf.validate.AnyRules any = 20[json_name = "any"];
    case kAny: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.any_);
      break;
    }
    // .buf.validate.DurationRules duration = 21[json_name = "duration"];
    case kDuration: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.duration_);
      break;
    }
    // .buf.validate.TimestampRules timestamp = 22[json_name = "timestamp"];
    case kTimestamp: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.timestamp_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FieldRules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.FieldRules)
  GOOGLE_DCHECK_NE(&from, this);
  const FieldRules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FieldRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.FieldRules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.FieldRules)
    MergeFrom(*source);
  }
}

void FieldRules::MergeFrom(const FieldRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.FieldRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cel_.MergeFrom(from.cel_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      required_ = from.required_;
    }
    if (cached_has_bits & 0x00000002u) {
      ignore_ = from.ignore_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.type_case()) {
    case kFloat: {
      _internal_mutable_float_()->::buf::validate::FloatRules::MergeFrom(from._internal_float_());
      break;
    }
    case kDouble: {
      _internal_mutable_double_()->::buf::validate::DoubleRules::MergeFrom(from._internal_double_());
      break;
    }
    case kInt32: {
      _internal_mutable_int32()->::buf::validate::Int32Rules::MergeFrom(from._internal_int32());
      break;
    }
    case kInt64: {
      _internal_mutable_int64()->::buf::validate::Int64Rules::MergeFrom(from._internal_int64());
      break;
    }
    case kUint32: {
      _internal_mutable_uint32()->::buf::validate::UInt32Rules::MergeFrom(from._internal_uint32());
      break;
    }
    case kUint64: {
      _internal_mutable_uint64()->::buf::validate::UInt64Rules::MergeFrom(from._internal_uint64());
      break;
    }
    case kSint32: {
      _internal_mutable_sint32()->::buf::validate::SInt32Rules::MergeFrom(from._internal_sint32());
      break;
    }
    case kSint64: {
      _internal_mutable_sint64()->::buf::validate::SInt64Rules::MergeFrom(from._internal_sint64());
      break;
    }
    case kFixed32: {
      _internal_mutable_fixed32()->::buf::validate::Fixed32Rules::MergeFrom(from._internal_fixed32());
      break;
    }
    case kFixed64: {
      _internal_mutable_fixed64()->::buf::validate::Fixed64Rules::MergeFrom(from._internal_fixed64());
      break;
    }
    case kSfixed32: {
      _internal_mutable_sfixed32()->::buf::validate::SFixed32Rules::MergeFrom(from._internal_sfixed32());
      break;
    }
    case kSfixed64: {
      _internal_mutable_sfixed64()->::buf::validate::SFixed64Rules::MergeFrom(from._internal_sfixed64());
      break;
    }
    case kBool: {
      _internal_mutable_bool_()->::buf::validate::BoolRules::MergeFrom(from._internal_bool_());
      break;
    }
    case kString: {
      _internal_mutable_string()->::buf::validate::StringRules::MergeFrom(from._internal_string());
      break;
    }
    case kBytes: {
      _internal_mutable_bytes()->::buf::validate::BytesRules::MergeFrom(from._internal_bytes());
      break;
    }
    case kEnum: {
      _internal_mutable_enum_()->::buf::validate::EnumRules::MergeFrom(from._internal_enum_());
      break;
    }
    case kRepeated: {
      _internal_mutable_repeated()->::buf::validate::RepeatedRules::MergeFrom(from._internal_repeated());
      break;
    }
    case kMap: {
      _internal_mutable_map()->::buf::validate::MapRules::MergeFrom(from._internal_map());
      break;
    }
    case kAny: {
      _internal_mutable_any()->::buf::validate::AnyRules::MergeFrom(from._internal_any());
      break;
    }
    case kDuration: {
      _internal_mutable_duration()->::buf::validate::DurationRules::MergeFrom(from._internal_duration());
      break;
    }
    case kTimestamp: {
      _internal_mutable_timestamp()->::buf::validate::TimestampRules::MergeFrom(from._internal_timestamp());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
}

void FieldRules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.FieldRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FieldRules::CopyFrom(const FieldRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.FieldRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FieldRules::IsInitialized() const {
  switch (type_case()) {
    case kFloat: {
      if (has_float_()) {
        if (!this->float_().IsInitialized()) return false;
      }
      break;
    }
    case kDouble: {
      if (has_double_()) {
        if (!this->double_().IsInitialized()) return false;
      }
      break;
    }
    case kInt32: {
      if (has_int32()) {
        if (!this->int32().IsInitialized()) return false;
      }
      break;
    }
    case kInt64: {
      if (has_int64()) {
        if (!this->int64().IsInitialized()) return false;
      }
      break;
    }
    case kUint32: {
      if (has_uint32()) {
        if (!this->uint32().IsInitialized()) return false;
      }
      break;
    }
    case kUint64: {
      if (has_uint64()) {
        if (!this->uint64().IsInitialized()) return false;
      }
      break;
    }
    case kSint32: {
      if (has_sint32()) {
        if (!this->sint32().IsInitialized()) return false;
      }
      break;
    }
    case kSint64: {
      if (has_sint64()) {
        if (!this->sint64().IsInitialized()) return false;
      }
      break;
    }
    case kFixed32: {
      if (has_fixed32()) {
        if (!this->fixed32().IsInitialized()) return false;
      }
      break;
    }
    case kFixed64: {
      if (has_fixed64()) {
        if (!this->fixed64().IsInitialized()) return false;
      }
      break;
    }
    case kSfixed32: {
      if (has_sfixed32()) {
        if (!this->sfixed32().IsInitialized()) return false;
      }
      break;
    }
    case kSfixed64: {
      if (has_sfixed64()) {
        if (!this->sfixed64().IsInitialized()) return false;
      }
      break;
    }
    case kBool: {
      if (has_bool_()) {
        if (!this->bool_().IsInitialized()) return false;
      }
      break;
    }
    case kString: {
      if (has_string()) {
        if (!this->string().IsInitialized()) return false;
      }
      break;
    }
    case kBytes: {
      if (has_bytes()) {
        if (!this->bytes().IsInitialized()) return false;
      }
      break;
    }
    case kEnum: {
      if (has_enum_()) {
        if (!this->enum_().IsInitialized()) return false;
      }
      break;
    }
    case kRepeated: {
      if (has_repeated()) {
        if (!this->repeated().IsInitialized()) return false;
      }
      break;
    }
    case kMap: {
      if (has_map()) {
        if (!this->map().IsInitialized()) return false;
      }
      break;
    }
    case kAny: {
      break;
    }
    case kDuration: {
      if (has_duration()) {
        if (!this->duration().IsInitialized()) return false;
      }
      break;
    }
    case kTimestamp: {
      if (has_timestamp()) {
        if (!this->timestamp().IsInitialized()) return false;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  return true;
}

void FieldRules::InternalSwap(FieldRules* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  cel_.InternalSwap(&other->cel_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FieldRules, ignore_)
      + sizeof(FieldRules::ignore_)
      - PROTOBUF_FIELD_OFFSET(FieldRules, required_)>(
          reinterpret_cast<char*>(&required_),
          reinterpret_cast<char*>(&other->required_));
  swap(type_, other->type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata FieldRules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void PredefinedRules::InitAsDefaultInstance() {
}
class PredefinedRules::_Internal {
 public:
};

PredefinedRules::PredefinedRules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  cel_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.PredefinedRules)
}
PredefinedRules::PredefinedRules(const PredefinedRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      cel_(from.cel_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:buf.validate.PredefinedRules)
}

void PredefinedRules::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PredefinedRules_buf_2fvalidate_2fvalidate_2eproto.base);
}

PredefinedRules::~PredefinedRules() {
  // @@protoc_insertion_point(destructor:buf.validate.PredefinedRules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void PredefinedRules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void PredefinedRules::ArenaDtor(void* object) {
  PredefinedRules* _this = reinterpret_cast< PredefinedRules* >(object);
  (void)_this;
}
void PredefinedRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PredefinedRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PredefinedRules& PredefinedRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PredefinedRules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void PredefinedRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.PredefinedRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cel_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PredefinedRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .buf.validate.Rule cel = 1[json_name = "cel"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cel(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PredefinedRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.PredefinedRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .buf.validate.Rule cel = 1[json_name = "cel"];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cel_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_cel(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.PredefinedRules)
  return target;
}

size_t PredefinedRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.PredefinedRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .buf.validate.Rule cel = 1[json_name = "cel"];
  total_size += 1UL * this->_internal_cel_size();
  for (const auto& msg : this->cel_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PredefinedRules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.PredefinedRules)
  GOOGLE_DCHECK_NE(&from, this);
  const PredefinedRules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PredefinedRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.PredefinedRules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.PredefinedRules)
    MergeFrom(*source);
  }
}

void PredefinedRules::MergeFrom(const PredefinedRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.PredefinedRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cel_.MergeFrom(from.cel_);
}

void PredefinedRules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.PredefinedRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PredefinedRules::CopyFrom(const PredefinedRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.PredefinedRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PredefinedRules::IsInitialized() const {
  return true;
}

void PredefinedRules::InternalSwap(PredefinedRules* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  cel_.InternalSwap(&other->cel_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PredefinedRules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void FloatRules::InitAsDefaultInstance() {
  ::buf::validate::_FloatRules_default_instance_.lt_ = 0;
  ::buf::validate::_FloatRules_default_instance_.lte_ = 0;
  ::buf::validate::_FloatRules_default_instance_.gt_ = 0;
  ::buf::validate::_FloatRules_default_instance_.gte_ = 0;
}
class FloatRules::_Internal {
 public:
  using HasBits = decltype(std::declval<FloatRules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_finite(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FloatRules::FloatRules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.FloatRules)
}
FloatRules::FloatRules(const FloatRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&finite_) -
    reinterpret_cast<char*>(&const__)) + sizeof(finite_));
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.FloatRules)
}

void FloatRules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&finite_) -
      reinterpret_cast<char*>(&const__)) + sizeof(finite_));
  clear_has_less_than();
  clear_has_greater_than();
}

FloatRules::~FloatRules() {
  // @@protoc_insertion_point(destructor:buf.validate.FloatRules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void FloatRules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}

void FloatRules::ArenaDtor(void* object) {
  FloatRules* _this = reinterpret_cast< FloatRules* >(object);
  (void)_this;
}
void FloatRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FloatRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FloatRules& FloatRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FloatRules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void FloatRules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.FloatRules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LESS_THAN_NOT_SET;
}

void FloatRules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.FloatRules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = GREATER_THAN_NOT_SET;
}


void FloatRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.FloatRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&finite_) -
        reinterpret_cast<char*>(&const__)) + sizeof(finite_));
  }
  clear_less_than();
  clear_greater_than();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FloatRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float lt = 2[json_name = "lt", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _internal_set_lt(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float lte = 3[json_name = "lte", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _internal_set_lte(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float gt = 4[json_name = "gt", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _internal_set_gt(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float gte = 5[json_name = "gte", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _internal_set_gte(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated float in = 6[json_name = "in", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<53>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated float not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<61>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool finite = 8[json_name = "finite", (.buf.validate.predefined) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_finite(&has_bits);
          finite_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated float example = 9[json_name = "example", (.buf.validate.predefined) = {
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_example(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<77>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_example(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FloatRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.FloatRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_lte(), target);
      break;
    }
    default: ;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_gte(), target);
      break;
    }
    default: ;
  }
  // repeated float in = 6[json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_in(i), target);
  }

  // repeated float not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_not_in(i), target);
  }

  // optional bool finite = 8[json_name = "finite", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_finite(), target);
  }

  // repeated float example = 9[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_example(i), target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.FloatRules)
  return target;
}

size_t FloatRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.FloatRules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float in = 6[json_name = "in", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated float not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  // repeated float example = 9[json_name = "example", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_example_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_example_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float const = 1[json_name = "const", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional bool finite = 8[json_name = "finite", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  switch (less_than_case()) {
    // float lt = 2[json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 1 + 4;
      break;
    }
    // float lte = 3[json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 1 + 4;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // float gt = 4[json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 1 + 4;
      break;
    }
    // float gte = 5[json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 1 + 4;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FloatRules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.FloatRules)
  GOOGLE_DCHECK_NE(&from, this);
  const FloatRules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FloatRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.FloatRules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.FloatRules)
    MergeFrom(*source);
  }
}

void FloatRules::MergeFrom(const FloatRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.FloatRules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      finite_ = from.finite_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
}

void FloatRules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.FloatRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FloatRules::CopyFrom(const FloatRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.FloatRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FloatRules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void FloatRules::InternalSwap(FloatRules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FloatRules, finite_)
      + sizeof(FloatRules::finite_)
      - PROTOBUF_FIELD_OFFSET(FloatRules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
  swap(less_than_, other->less_than_);
  swap(greater_than_, other->greater_than_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata FloatRules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void DoubleRules::InitAsDefaultInstance() {
  ::buf::validate::_DoubleRules_default_instance_.lt_ = 0;
  ::buf::validate::_DoubleRules_default_instance_.lte_ = 0;
  ::buf::validate::_DoubleRules_default_instance_.gt_ = 0;
  ::buf::validate::_DoubleRules_default_instance_.gte_ = 0;
}
class DoubleRules::_Internal {
 public:
  using HasBits = decltype(std::declval<DoubleRules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_finite(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DoubleRules::DoubleRules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.DoubleRules)
}
DoubleRules::DoubleRules(const DoubleRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&finite_) -
    reinterpret_cast<char*>(&const__)) + sizeof(finite_));
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.DoubleRules)
}

void DoubleRules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&finite_) -
      reinterpret_cast<char*>(&const__)) + sizeof(finite_));
  clear_has_less_than();
  clear_has_greater_than();
}

DoubleRules::~DoubleRules() {
  // @@protoc_insertion_point(destructor:buf.validate.DoubleRules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void DoubleRules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}

void DoubleRules::ArenaDtor(void* object) {
  DoubleRules* _this = reinterpret_cast< DoubleRules* >(object);
  (void)_this;
}
void DoubleRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DoubleRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DoubleRules& DoubleRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DoubleRules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void DoubleRules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.DoubleRules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LESS_THAN_NOT_SET;
}

void DoubleRules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.DoubleRules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = GREATER_THAN_NOT_SET;
}


void DoubleRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.DoubleRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&finite_) -
        reinterpret_cast<char*>(&const__)) + sizeof(finite_));
  }
  clear_less_than();
  clear_greater_than();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DoubleRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional double const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double lt = 2[json_name = "lt", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _internal_set_lt(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double lte = 3[json_name = "lte", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _internal_set_lte(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double gt = 4[json_name = "gt", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _internal_set_gt(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double gte = 5[json_name = "gte", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _internal_set_gte(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // repeated double in = 6[json_name = "in", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<49>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated double not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<57>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool finite = 8[json_name = "finite", (.buf.validate.predefined) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_finite(&has_bits);
          finite_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated double example = 9[json_name = "example", (.buf.validate.predefined) = {
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 73)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_example(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<73>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_example(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DoubleRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.DoubleRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_lte(), target);
      break;
    }
    default: ;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_gte(), target);
      break;
    }
    default: ;
  }
  // repeated double in = 6[json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_in(i), target);
  }

  // repeated double not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_not_in(i), target);
  }

  // optional bool finite = 8[json_name = "finite", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_finite(), target);
  }

  // repeated double example = 9[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(9, this->_internal_example(i), target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.DoubleRules)
  return target;
}

size_t DoubleRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.DoubleRules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double in = 6[json_name = "in", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated double not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  // repeated double example = 9[json_name = "example", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_example_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_example_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double const = 1[json_name = "const", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional bool finite = 8[json_name = "finite", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  switch (less_than_case()) {
    // double lt = 2[json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 1 + 8;
      break;
    }
    // double lte = 3[json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 1 + 8;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // double gt = 4[json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 1 + 8;
      break;
    }
    // double gte = 5[json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 1 + 8;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DoubleRules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.DoubleRules)
  GOOGLE_DCHECK_NE(&from, this);
  const DoubleRules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DoubleRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.DoubleRules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.DoubleRules)
    MergeFrom(*source);
  }
}

void DoubleRules::MergeFrom(const DoubleRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.DoubleRules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      finite_ = from.finite_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
}

void DoubleRules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.DoubleRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DoubleRules::CopyFrom(const DoubleRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.DoubleRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoubleRules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void DoubleRules::InternalSwap(DoubleRules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoubleRules, finite_)
      + sizeof(DoubleRules::finite_)
      - PROTOBUF_FIELD_OFFSET(DoubleRules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
  swap(less_than_, other->less_than_);
  swap(greater_than_, other->greater_than_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata DoubleRules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Int32Rules::InitAsDefaultInstance() {
  ::buf::validate::_Int32Rules_default_instance_.lt_ = 0;
  ::buf::validate::_Int32Rules_default_instance_.lte_ = 0;
  ::buf::validate::_Int32Rules_default_instance_.gt_ = 0;
  ::buf::validate::_Int32Rules_default_instance_.gte_ = 0;
}
class Int32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Int32Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Int32Rules::Int32Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Int32Rules)
}
Int32Rules::Int32Rules(const Int32Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  const__ = from.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.Int32Rules)
}

void Int32Rules::SharedCtor() {
  const__ = 0;
  clear_has_less_than();
  clear_has_greater_than();
}

Int32Rules::~Int32Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.Int32Rules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Int32Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}

void Int32Rules::ArenaDtor(void* object) {
  Int32Rules* _this = reinterpret_cast< Int32Rules* >(object);
  (void)_this;
}
void Int32Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Int32Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Int32Rules& Int32Rules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Int32Rules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void Int32Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Int32Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LESS_THAN_NOT_SET;
}

void Int32Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Int32Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = GREATER_THAN_NOT_SET;
}


void Int32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Int32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  const__ = 0;
  clear_less_than();
  clear_greater_than();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Int32Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _internal_set_lt(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _internal_set_lte(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _internal_set_gt(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _internal_set_gte(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 in = 6[json_name = "in", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 example = 8[json_name = "example", (.buf.validate.predefined) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_example(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_example(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Int32Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Int32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_lte(), target);
      break;
    }
    default: ;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_gte(), target);
      break;
    }
    default: ;
  }
  // repeated int32 in = 6[json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_in(i), target);
  }

  // repeated int32 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_not_in(i), target);
  }

  // repeated int32 example = 8[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_example(i), target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Int32Rules)
  return target;
}

size_t Int32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Int32Rules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 in = 6[json_name = "in", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated int32 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->not_in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  // repeated int32 example = 8[json_name = "example", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->example_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_example_size());
    total_size += data_size;
  }

  // optional int32 const = 1[json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // int32 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_lt());
      break;
    }
    // int32 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // int32 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_gt());
      break;
    }
    // int32 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Int32Rules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.Int32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const Int32Rules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Int32Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.Int32Rules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.Int32Rules)
    MergeFrom(*source);
  }
}

void Int32Rules::MergeFrom(const Int32Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Int32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  if (from._internal_has_const_()) {
    _internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
}

void Int32Rules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.Int32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Int32Rules::CopyFrom(const Int32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Int32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int32Rules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void Int32Rules::InternalSwap(Int32Rules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  swap(const__, other->const__);
  swap(less_than_, other->less_than_);
  swap(greater_than_, other->greater_than_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Int32Rules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Int64Rules::InitAsDefaultInstance() {
  ::buf::validate::_Int64Rules_default_instance_.lt_ = PROTOBUF_LONGLONG(0);
  ::buf::validate::_Int64Rules_default_instance_.lte_ = PROTOBUF_LONGLONG(0);
  ::buf::validate::_Int64Rules_default_instance_.gt_ = PROTOBUF_LONGLONG(0);
  ::buf::validate::_Int64Rules_default_instance_.gte_ = PROTOBUF_LONGLONG(0);
}
class Int64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Int64Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Int64Rules::Int64Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Int64Rules)
}
Int64Rules::Int64Rules(const Int64Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  const__ = from.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.Int64Rules)
}

void Int64Rules::SharedCtor() {
  const__ = PROTOBUF_LONGLONG(0);
  clear_has_less_than();
  clear_has_greater_than();
}

Int64Rules::~Int64Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.Int64Rules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Int64Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}

void Int64Rules::ArenaDtor(void* object) {
  Int64Rules* _this = reinterpret_cast< Int64Rules* >(object);
  (void)_this;
}
void Int64Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Int64Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Int64Rules& Int64Rules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Int64Rules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void Int64Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Int64Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LESS_THAN_NOT_SET;
}

void Int64Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Int64Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = GREATER_THAN_NOT_SET;
}


void Int64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Int64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  const__ = PROTOBUF_LONGLONG(0);
  clear_less_than();
  clear_greater_than();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Int64Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int64 const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int64 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _internal_set_lt(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int64 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _internal_set_lte(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int64 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _internal_set_gt(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int64 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _internal_set_gte(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int64 in = 6[json_name = "in", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int64 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int64 example = 9[json_name = "example", (.buf.validate.predefined) = {
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_example(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<72>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_example(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Int64Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Int64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_lte(), target);
      break;
    }
    default: ;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_gte(), target);
      break;
    }
    default: ;
  }
  // repeated int64 in = 6[json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_in(i), target);
  }

  // repeated int64 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(7, this->_internal_not_in(i), target);
  }

  // repeated int64 example = 9[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(9, this->_internal_example(i), target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Int64Rules)
  return target;
}

size_t Int64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Int64Rules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 in = 6[json_name = "in", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated int64 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->not_in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  // repeated int64 example = 9[json_name = "example", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->example_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_example_size());
    total_size += data_size;
  }

  // optional int64 const = 1[json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // int64 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_lt());
      break;
    }
    // int64 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // int64 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_gt());
      break;
    }
    // int64 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Int64Rules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.Int64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const Int64Rules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Int64Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.Int64Rules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.Int64Rules)
    MergeFrom(*source);
  }
}

void Int64Rules::MergeFrom(const Int64Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Int64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  if (from._internal_has_const_()) {
    _internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
}

void Int64Rules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.Int64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Int64Rules::CopyFrom(const Int64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Int64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Int64Rules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void Int64Rules::InternalSwap(Int64Rules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  swap(const__, other->const__);
  swap(less_than_, other->less_than_);
  swap(greater_than_, other->greater_than_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Int64Rules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UInt32Rules::InitAsDefaultInstance() {
  ::buf::validate::_UInt32Rules_default_instance_.lt_ = 0u;
  ::buf::validate::_UInt32Rules_default_instance_.lte_ = 0u;
  ::buf::validate::_UInt32Rules_default_instance_.gt_ = 0u;
  ::buf::validate::_UInt32Rules_default_instance_.gte_ = 0u;
}
class UInt32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<UInt32Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UInt32Rules::UInt32Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.UInt32Rules)
}
UInt32Rules::UInt32Rules(const UInt32Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  const__ = from.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.UInt32Rules)
}

void UInt32Rules::SharedCtor() {
  const__ = 0u;
  clear_has_less_than();
  clear_has_greater_than();
}

UInt32Rules::~UInt32Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.UInt32Rules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void UInt32Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}

void UInt32Rules::ArenaDtor(void* object) {
  UInt32Rules* _this = reinterpret_cast< UInt32Rules* >(object);
  (void)_this;
}
void UInt32Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UInt32Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UInt32Rules& UInt32Rules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UInt32Rules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void UInt32Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.UInt32Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LESS_THAN_NOT_SET;
}

void UInt32Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.UInt32Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = GREATER_THAN_NOT_SET;
}


void UInt32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.UInt32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  const__ = 0u;
  clear_less_than();
  clear_greater_than();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UInt32Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _internal_set_lt(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _internal_set_lte(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _internal_set_gt(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _internal_set_gte(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 in = 6[json_name = "in", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 example = 8[json_name = "example", (.buf.validate.predefined) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_example(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_example(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UInt32Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.UInt32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lte(), target);
      break;
    }
    default: ;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_gte(), target);
      break;
    }
    default: ;
  }
  // repeated uint32 in = 6[json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_in(i), target);
  }

  // repeated uint32 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_not_in(i), target);
  }

  // repeated uint32 example = 8[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_example(i), target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.UInt32Rules)
  return target;
}

size_t UInt32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.UInt32Rules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 in = 6[json_name = "in", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated uint32 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->not_in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  // repeated uint32 example = 8[json_name = "example", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->example_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_example_size());
    total_size += data_size;
  }

  // optional uint32 const = 1[json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // uint32 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lt());
      break;
    }
    // uint32 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // uint32 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_gt());
      break;
    }
    // uint32 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UInt32Rules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.UInt32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const UInt32Rules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UInt32Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.UInt32Rules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.UInt32Rules)
    MergeFrom(*source);
  }
}

void UInt32Rules::MergeFrom(const UInt32Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.UInt32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  if (from._internal_has_const_()) {
    _internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
}

void UInt32Rules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.UInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UInt32Rules::CopyFrom(const UInt32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.UInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UInt32Rules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void UInt32Rules::InternalSwap(UInt32Rules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  swap(const__, other->const__);
  swap(less_than_, other->less_than_);
  swap(greater_than_, other->greater_than_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata UInt32Rules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UInt64Rules::InitAsDefaultInstance() {
  ::buf::validate::_UInt64Rules_default_instance_.lt_ = PROTOBUF_ULONGLONG(0);
  ::buf::validate::_UInt64Rules_default_instance_.lte_ = PROTOBUF_ULONGLONG(0);
  ::buf::validate::_UInt64Rules_default_instance_.gt_ = PROTOBUF_ULONGLONG(0);
  ::buf::validate::_UInt64Rules_default_instance_.gte_ = PROTOBUF_ULONGLONG(0);
}
class UInt64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<UInt64Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UInt64Rules::UInt64Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.UInt64Rules)
}
UInt64Rules::UInt64Rules(const UInt64Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  const__ = from.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.UInt64Rules)
}

void UInt64Rules::SharedCtor() {
  const__ = PROTOBUF_ULONGLONG(0);
  clear_has_less_than();
  clear_has_greater_than();
}

UInt64Rules::~UInt64Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.UInt64Rules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void UInt64Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}

void UInt64Rules::ArenaDtor(void* object) {
  UInt64Rules* _this = reinterpret_cast< UInt64Rules* >(object);
  (void)_this;
}
void UInt64Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UInt64Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UInt64Rules& UInt64Rules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UInt64Rules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void UInt64Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.UInt64Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LESS_THAN_NOT_SET;
}

void UInt64Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.UInt64Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = GREATER_THAN_NOT_SET;
}


void UInt64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.UInt64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  const__ = PROTOBUF_ULONGLONG(0);
  clear_less_than();
  clear_greater_than();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UInt64Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _internal_set_lt(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _internal_set_lte(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _internal_set_gt(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _internal_set_gte(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint64 in = 6[json_name = "in", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint64 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint64 example = 8[json_name = "example", (.buf.validate.predefined) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_example(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_example(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UInt64Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.UInt64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_lte(), target);
      break;
    }
    default: ;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_gte(), target);
      break;
    }
    default: ;
  }
  // repeated uint64 in = 6[json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_in(i), target);
  }

  // repeated uint64 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(7, this->_internal_not_in(i), target);
  }

  // repeated uint64 example = 8[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(8, this->_internal_example(i), target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.UInt64Rules)
  return target;
}

size_t UInt64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.UInt64Rules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 in = 6[json_name = "in", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated uint64 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->not_in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  // repeated uint64 example = 8[json_name = "example", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->example_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_example_size());
    total_size += data_size;
  }

  // optional uint64 const = 1[json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // uint64 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_lt());
      break;
    }
    // uint64 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // uint64 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_gt());
      break;
    }
    // uint64 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UInt64Rules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.UInt64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const UInt64Rules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UInt64Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.UInt64Rules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.UInt64Rules)
    MergeFrom(*source);
  }
}

void UInt64Rules::MergeFrom(const UInt64Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.UInt64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  if (from._internal_has_const_()) {
    _internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
}

void UInt64Rules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.UInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UInt64Rules::CopyFrom(const UInt64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.UInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UInt64Rules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void UInt64Rules::InternalSwap(UInt64Rules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  swap(const__, other->const__);
  swap(less_than_, other->less_than_);
  swap(greater_than_, other->greater_than_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata UInt64Rules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SInt32Rules::InitAsDefaultInstance() {
  ::buf::validate::_SInt32Rules_default_instance_.lt_ = 0;
  ::buf::validate::_SInt32Rules_default_instance_.lte_ = 0;
  ::buf::validate::_SInt32Rules_default_instance_.gt_ = 0;
  ::buf::validate::_SInt32Rules_default_instance_.gte_ = 0;
}
class SInt32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SInt32Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SInt32Rules::SInt32Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.SInt32Rules)
}
SInt32Rules::SInt32Rules(const SInt32Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  const__ = from.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.SInt32Rules)
}

void SInt32Rules::SharedCtor() {
  const__ = 0;
  clear_has_less_than();
  clear_has_greater_than();
}

SInt32Rules::~SInt32Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.SInt32Rules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SInt32Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}

void SInt32Rules::ArenaDtor(void* object) {
  SInt32Rules* _this = reinterpret_cast< SInt32Rules* >(object);
  (void)_this;
}
void SInt32Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SInt32Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SInt32Rules& SInt32Rules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SInt32Rules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void SInt32Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SInt32Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LESS_THAN_NOT_SET;
}

void SInt32Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SInt32Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = GREATER_THAN_NOT_SET;
}


void SInt32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.SInt32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  const__ = 0;
  clear_less_than();
  clear_greater_than();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SInt32Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional sint32 const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // sint32 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _internal_set_lt(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // sint32 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _internal_set_lte(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // sint32 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _internal_set_gt(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // sint32 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _internal_set_gte(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sint32 in = 6[json_name = "in", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sint32 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sint32 example = 8[json_name = "example", (.buf.validate.predefined) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_example(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt32Parser(_internal_mutable_example(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SInt32Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.SInt32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sint32 const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(3, this->_internal_lte(), target);
      break;
    }
    default: ;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(5, this->_internal_gte(), target);
      break;
    }
    default: ;
  }
  // repeated sint32 in = 6[json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(6, this->_internal_in(i), target);
  }

  // repeated sint32 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(7, this->_internal_not_in(i), target);
  }

  // repeated sint32 example = 8[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(8, this->_internal_example(i), target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.SInt32Rules)
  return target;
}

size_t SInt32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.SInt32Rules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sint32 in = 6[json_name = "in", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      SInt32Size(this->in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated sint32 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      SInt32Size(this->not_in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  // repeated sint32 example = 8[json_name = "example", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      SInt32Size(this->example_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_example_size());
    total_size += data_size;
  }

  // optional sint32 const = 1[json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // sint32 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->_internal_lt());
      break;
    }
    // sint32 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // sint32 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->_internal_gt());
      break;
    }
    // sint32 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SInt32Rules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.SInt32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const SInt32Rules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SInt32Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.SInt32Rules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.SInt32Rules)
    MergeFrom(*source);
  }
}

void SInt32Rules::MergeFrom(const SInt32Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.SInt32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  if (from._internal_has_const_()) {
    _internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
}

void SInt32Rules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.SInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SInt32Rules::CopyFrom(const SInt32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.SInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SInt32Rules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void SInt32Rules::InternalSwap(SInt32Rules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  swap(const__, other->const__);
  swap(less_than_, other->less_than_);
  swap(greater_than_, other->greater_than_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SInt32Rules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SInt64Rules::InitAsDefaultInstance() {
  ::buf::validate::_SInt64Rules_default_instance_.lt_ = PROTOBUF_LONGLONG(0);
  ::buf::validate::_SInt64Rules_default_instance_.lte_ = PROTOBUF_LONGLONG(0);
  ::buf::validate::_SInt64Rules_default_instance_.gt_ = PROTOBUF_LONGLONG(0);
  ::buf::validate::_SInt64Rules_default_instance_.gte_ = PROTOBUF_LONGLONG(0);
}
class SInt64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SInt64Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SInt64Rules::SInt64Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.SInt64Rules)
}
SInt64Rules::SInt64Rules(const SInt64Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  const__ = from.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.SInt64Rules)
}

void SInt64Rules::SharedCtor() {
  const__ = PROTOBUF_LONGLONG(0);
  clear_has_less_than();
  clear_has_greater_than();
}

SInt64Rules::~SInt64Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.SInt64Rules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SInt64Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}

void SInt64Rules::ArenaDtor(void* object) {
  SInt64Rules* _this = reinterpret_cast< SInt64Rules* >(object);
  (void)_this;
}
void SInt64Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SInt64Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SInt64Rules& SInt64Rules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SInt64Rules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void SInt64Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SInt64Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LESS_THAN_NOT_SET;
}

void SInt64Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SInt64Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = GREATER_THAN_NOT_SET;
}


void SInt64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.SInt64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  const__ = PROTOBUF_LONGLONG(0);
  clear_less_than();
  clear_greater_than();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SInt64Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional sint64 const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // sint64 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _internal_set_lt(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // sint64 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _internal_set_lte(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // sint64 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _internal_set_gt(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // sint64 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _internal_set_gte(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sint64 in = 6[json_name = "in", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt64Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sint64 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt64Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sint64 example = 8[json_name = "example", (.buf.validate.predefined) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_example(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt64Parser(_internal_mutable_example(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SInt64Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.SInt64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sint64 const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(3, this->_internal_lte(), target);
      break;
    }
    default: ;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(5, this->_internal_gte(), target);
      break;
    }
    default: ;
  }
  // repeated sint64 in = 6[json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(6, this->_internal_in(i), target);
  }

  // repeated sint64 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(7, this->_internal_not_in(i), target);
  }

  // repeated sint64 example = 8[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(8, this->_internal_example(i), target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.SInt64Rules)
  return target;
}

size_t SInt64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.SInt64Rules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sint64 in = 6[json_name = "in", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      SInt64Size(this->in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated sint64 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      SInt64Size(this->not_in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  // repeated sint64 example = 8[json_name = "example", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      SInt64Size(this->example_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_example_size());
    total_size += data_size;
  }

  // optional sint64 const = 1[json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt64Size(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // sint64 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt64Size(
          this->_internal_lt());
      break;
    }
    // sint64 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt64Size(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // sint64 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt64Size(
          this->_internal_gt());
      break;
    }
    // sint64 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt64Size(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SInt64Rules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.SInt64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const SInt64Rules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SInt64Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.SInt64Rules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.SInt64Rules)
    MergeFrom(*source);
  }
}

void SInt64Rules::MergeFrom(const SInt64Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.SInt64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  if (from._internal_has_const_()) {
    _internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
}

void SInt64Rules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.SInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SInt64Rules::CopyFrom(const SInt64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.SInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SInt64Rules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void SInt64Rules::InternalSwap(SInt64Rules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  swap(const__, other->const__);
  swap(less_than_, other->less_than_);
  swap(greater_than_, other->greater_than_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SInt64Rules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Fixed32Rules::InitAsDefaultInstance() {
  ::buf::validate::_Fixed32Rules_default_instance_.lt_ = 0u;
  ::buf::validate::_Fixed32Rules_default_instance_.lte_ = 0u;
  ::buf::validate::_Fixed32Rules_default_instance_.gt_ = 0u;
  ::buf::validate::_Fixed32Rules_default_instance_.gte_ = 0u;
}
class Fixed32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Fixed32Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Fixed32Rules::Fixed32Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Fixed32Rules)
}
Fixed32Rules::Fixed32Rules(const Fixed32Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  const__ = from.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.Fixed32Rules)
}

void Fixed32Rules::SharedCtor() {
  const__ = 0u;
  clear_has_less_than();
  clear_has_greater_than();
}

Fixed32Rules::~Fixed32Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.Fixed32Rules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Fixed32Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}

void Fixed32Rules::ArenaDtor(void* object) {
  Fixed32Rules* _this = reinterpret_cast< Fixed32Rules* >(object);
  (void)_this;
}
void Fixed32Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Fixed32Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Fixed32Rules& Fixed32Rules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Fixed32Rules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void Fixed32Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Fixed32Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LESS_THAN_NOT_SET;
}

void Fixed32Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Fixed32Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = GREATER_THAN_NOT_SET;
}


void Fixed32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Fixed32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  const__ = 0u;
  clear_less_than();
  clear_greater_than();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Fixed32Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional fixed32 const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // fixed32 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _internal_set_lt(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // fixed32 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _internal_set_lte(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // fixed32 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _internal_set_gt(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // fixed32 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _internal_set_gte(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // repeated fixed32 in = 6[json_name = "in", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<53>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated fixed32 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<61>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated fixed32 example = 8[json_name = "example", (.buf.validate.predefined) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_example(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<69>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_example(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Fixed32Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Fixed32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed32 const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(3, this->_internal_lte(), target);
      break;
    }
    default: ;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(5, this->_internal_gte(), target);
      break;
    }
    default: ;
  }
  // repeated fixed32 in = 6[json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(6, this->_internal_in(i), target);
  }

  // repeated fixed32 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(7, this->_internal_not_in(i), target);
  }

  // repeated fixed32 example = 8[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(8, this->_internal_example(i), target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Fixed32Rules)
  return target;
}

size_t Fixed32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Fixed32Rules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 in = 6[json_name = "in", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated fixed32 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  // repeated fixed32 example = 8[json_name = "example", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_example_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_example_size());
    total_size += data_size;
  }

  // optional fixed32 const = 1[json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  switch (less_than_case()) {
    // fixed32 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 1 + 4;
      break;
    }
    // fixed32 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 1 + 4;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // fixed32 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 1 + 4;
      break;
    }
    // fixed32 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 1 + 4;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fixed32Rules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.Fixed32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const Fixed32Rules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Fixed32Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.Fixed32Rules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.Fixed32Rules)
    MergeFrom(*source);
  }
}

void Fixed32Rules::MergeFrom(const Fixed32Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Fixed32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  if (from._internal_has_const_()) {
    _internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
}

void Fixed32Rules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.Fixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Fixed32Rules::CopyFrom(const Fixed32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Fixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fixed32Rules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void Fixed32Rules::InternalSwap(Fixed32Rules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  swap(const__, other->const__);
  swap(less_than_, other->less_than_);
  swap(greater_than_, other->greater_than_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Fixed32Rules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Fixed64Rules::InitAsDefaultInstance() {
  ::buf::validate::_Fixed64Rules_default_instance_.lt_ = PROTOBUF_ULONGLONG(0);
  ::buf::validate::_Fixed64Rules_default_instance_.lte_ = PROTOBUF_ULONGLONG(0);
  ::buf::validate::_Fixed64Rules_default_instance_.gt_ = PROTOBUF_ULONGLONG(0);
  ::buf::validate::_Fixed64Rules_default_instance_.gte_ = PROTOBUF_ULONGLONG(0);
}
class Fixed64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Fixed64Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Fixed64Rules::Fixed64Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Fixed64Rules)
}
Fixed64Rules::Fixed64Rules(const Fixed64Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  const__ = from.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.Fixed64Rules)
}

void Fixed64Rules::SharedCtor() {
  const__ = PROTOBUF_ULONGLONG(0);
  clear_has_less_than();
  clear_has_greater_than();
}

Fixed64Rules::~Fixed64Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.Fixed64Rules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Fixed64Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}

void Fixed64Rules::ArenaDtor(void* object) {
  Fixed64Rules* _this = reinterpret_cast< Fixed64Rules* >(object);
  (void)_this;
}
void Fixed64Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Fixed64Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Fixed64Rules& Fixed64Rules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Fixed64Rules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void Fixed64Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Fixed64Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LESS_THAN_NOT_SET;
}

void Fixed64Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Fixed64Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = GREATER_THAN_NOT_SET;
}


void Fixed64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Fixed64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  const__ = PROTOBUF_ULONGLONG(0);
  clear_less_than();
  clear_greater_than();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Fixed64Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional fixed64 const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // fixed64 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _internal_set_lt(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // fixed64 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _internal_set_lte(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // fixed64 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _internal_set_gt(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // fixed64 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _internal_set_gte(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // repeated fixed64 in = 6[json_name = "in", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<49>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated fixed64 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<57>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated fixed64 example = 8[json_name = "example", (.buf.validate.predefined) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 65)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_example(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<65>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_example(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Fixed64Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Fixed64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(3, this->_internal_lte(), target);
      break;
    }
    default: ;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(5, this->_internal_gte(), target);
      break;
    }
    default: ;
  }
  // repeated fixed64 in = 6[json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(6, this->_internal_in(i), target);
  }

  // repeated fixed64 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(7, this->_internal_not_in(i), target);
  }

  // repeated fixed64 example = 8[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(8, this->_internal_example(i), target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Fixed64Rules)
  return target;
}

size_t Fixed64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Fixed64Rules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed64 in = 6[json_name = "in", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated fixed64 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  // repeated fixed64 example = 8[json_name = "example", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_example_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_example_size());
    total_size += data_size;
  }

  // optional fixed64 const = 1[json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  switch (less_than_case()) {
    // fixed64 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 1 + 8;
      break;
    }
    // fixed64 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 1 + 8;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // fixed64 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 1 + 8;
      break;
    }
    // fixed64 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 1 + 8;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fixed64Rules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.Fixed64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const Fixed64Rules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Fixed64Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.Fixed64Rules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.Fixed64Rules)
    MergeFrom(*source);
  }
}

void Fixed64Rules::MergeFrom(const Fixed64Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Fixed64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  if (from._internal_has_const_()) {
    _internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
}

void Fixed64Rules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.Fixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Fixed64Rules::CopyFrom(const Fixed64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Fixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fixed64Rules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void Fixed64Rules::InternalSwap(Fixed64Rules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  swap(const__, other->const__);
  swap(less_than_, other->less_than_);
  swap(greater_than_, other->greater_than_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Fixed64Rules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SFixed32Rules::InitAsDefaultInstance() {
  ::buf::validate::_SFixed32Rules_default_instance_.lt_ = 0;
  ::buf::validate::_SFixed32Rules_default_instance_.lte_ = 0;
  ::buf::validate::_SFixed32Rules_default_instance_.gt_ = 0;
  ::buf::validate::_SFixed32Rules_default_instance_.gte_ = 0;
}
class SFixed32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SFixed32Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SFixed32Rules::SFixed32Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.SFixed32Rules)
}
SFixed32Rules::SFixed32Rules(const SFixed32Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  const__ = from.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.SFixed32Rules)
}

void SFixed32Rules::SharedCtor() {
  const__ = 0;
  clear_has_less_than();
  clear_has_greater_than();
}

SFixed32Rules::~SFixed32Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.SFixed32Rules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SFixed32Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}

void SFixed32Rules::ArenaDtor(void* object) {
  SFixed32Rules* _this = reinterpret_cast< SFixed32Rules* >(object);
  (void)_this;
}
void SFixed32Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SFixed32Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SFixed32Rules& SFixed32Rules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SFixed32Rules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void SFixed32Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SFixed32Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LESS_THAN_NOT_SET;
}

void SFixed32Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SFixed32Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = GREATER_THAN_NOT_SET;
}


void SFixed32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.SFixed32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  const__ = 0;
  clear_less_than();
  clear_greater_than();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SFixed32Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional sfixed32 const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
        } else goto handle_unusual;
        continue;
      // sfixed32 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _internal_set_lt(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
        } else goto handle_unusual;
        continue;
      // sfixed32 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _internal_set_lte(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
        } else goto handle_unusual;
        continue;
      // sfixed32 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _internal_set_gt(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
        } else goto handle_unusual;
        continue;
      // sfixed32 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _internal_set_gte(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
        } else goto handle_unusual;
        continue;
      // repeated sfixed32 in = 6[json_name = "in", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<53>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSFixed32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sfixed32 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<61>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSFixed32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sfixed32 example = 8[json_name = "example", (.buf.validate.predefined) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_example(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<69>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSFixed32Parser(_internal_mutable_example(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SFixed32Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.SFixed32Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sfixed32 const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(3, this->_internal_lte(), target);
      break;
    }
    default: ;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(5, this->_internal_gte(), target);
      break;
    }
    default: ;
  }
  // repeated sfixed32 in = 6[json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(6, this->_internal_in(i), target);
  }

  // repeated sfixed32 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(7, this->_internal_not_in(i), target);
  }

  // repeated sfixed32 example = 8[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(8, this->_internal_example(i), target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.SFixed32Rules)
  return target;
}

size_t SFixed32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.SFixed32Rules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sfixed32 in = 6[json_name = "in", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated sfixed32 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  // repeated sfixed32 example = 8[json_name = "example", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_example_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_example_size());
    total_size += data_size;
  }

  // optional sfixed32 const = 1[json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  switch (less_than_case()) {
    // sfixed32 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 1 + 4;
      break;
    }
    // sfixed32 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 1 + 4;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // sfixed32 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 1 + 4;
      break;
    }
    // sfixed32 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 1 + 4;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SFixed32Rules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.SFixed32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const SFixed32Rules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SFixed32Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.SFixed32Rules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.SFixed32Rules)
    MergeFrom(*source);
  }
}

void SFixed32Rules::MergeFrom(const SFixed32Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.SFixed32Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  if (from._internal_has_const_()) {
    _internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
}

void SFixed32Rules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.SFixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SFixed32Rules::CopyFrom(const SFixed32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.SFixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SFixed32Rules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void SFixed32Rules::InternalSwap(SFixed32Rules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  swap(const__, other->const__);
  swap(less_than_, other->less_than_);
  swap(greater_than_, other->greater_than_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SFixed32Rules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SFixed64Rules::InitAsDefaultInstance() {
  ::buf::validate::_SFixed64Rules_default_instance_.lt_ = PROTOBUF_LONGLONG(0);
  ::buf::validate::_SFixed64Rules_default_instance_.lte_ = PROTOBUF_LONGLONG(0);
  ::buf::validate::_SFixed64Rules_default_instance_.gt_ = PROTOBUF_LONGLONG(0);
  ::buf::validate::_SFixed64Rules_default_instance_.gte_ = PROTOBUF_LONGLONG(0);
}
class SFixed64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SFixed64Rules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SFixed64Rules::SFixed64Rules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.SFixed64Rules)
}
SFixed64Rules::SFixed64Rules(const SFixed64Rules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  const__ = from.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.SFixed64Rules)
}

void SFixed64Rules::SharedCtor() {
  const__ = PROTOBUF_LONGLONG(0);
  clear_has_less_than();
  clear_has_greater_than();
}

SFixed64Rules::~SFixed64Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.SFixed64Rules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SFixed64Rules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}

void SFixed64Rules::ArenaDtor(void* object) {
  SFixed64Rules* _this = reinterpret_cast< SFixed64Rules* >(object);
  (void)_this;
}
void SFixed64Rules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SFixed64Rules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SFixed64Rules& SFixed64Rules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SFixed64Rules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void SFixed64Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SFixed64Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LESS_THAN_NOT_SET;
}

void SFixed64Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SFixed64Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = GREATER_THAN_NOT_SET;
}


void SFixed64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.SFixed64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  const__ = PROTOBUF_LONGLONG(0);
  clear_less_than();
  clear_greater_than();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SFixed64Rules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional sfixed64 const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
        } else goto handle_unusual;
        continue;
      // sfixed64 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _internal_set_lt(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
        } else goto handle_unusual;
        continue;
      // sfixed64 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _internal_set_lte(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
        } else goto handle_unusual;
        continue;
      // sfixed64 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _internal_set_gt(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
        } else goto handle_unusual;
        continue;
      // sfixed64 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _internal_set_gte(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr));
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
        } else goto handle_unusual;
        continue;
      // repeated sfixed64 in = 6[json_name = "in", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<49>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSFixed64Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sfixed64 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<57>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSFixed64Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated sfixed64 example = 8[json_name = "example", (.buf.validate.predefined) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 65)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_example(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<65>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSFixed64Parser(_internal_mutable_example(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SFixed64Rules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.SFixed64Rules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sfixed64 const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(3, this->_internal_lte(), target);
      break;
    }
    default: ;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(5, this->_internal_gte(), target);
      break;
    }
    default: ;
  }
  // repeated sfixed64 in = 6[json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(6, this->_internal_in(i), target);
  }

  // repeated sfixed64 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(7, this->_internal_not_in(i), target);
  }

  // repeated sfixed64 example = 8[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(8, this->_internal_example(i), target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.SFixed64Rules)
  return target;
}

size_t SFixed64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.SFixed64Rules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sfixed64 in = 6[json_name = "in", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated sfixed64 not_in = 7[json_name = "notIn", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_not_in_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  // repeated sfixed64 example = 8[json_name = "example", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_example_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_example_size());
    total_size += data_size;
  }

  // optional sfixed64 const = 1[json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  switch (less_than_case()) {
    // sfixed64 lt = 2[json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 1 + 8;
      break;
    }
    // sfixed64 lte = 3[json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 1 + 8;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // sfixed64 gt = 4[json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 1 + 8;
      break;
    }
    // sfixed64 gte = 5[json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 1 + 8;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SFixed64Rules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.SFixed64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  const SFixed64Rules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SFixed64Rules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.SFixed64Rules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.SFixed64Rules)
    MergeFrom(*source);
  }
}

void SFixed64Rules::MergeFrom(const SFixed64Rules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.SFixed64Rules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  if (from._internal_has_const_()) {
    _internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
}

void SFixed64Rules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.SFixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SFixed64Rules::CopyFrom(const SFixed64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.SFixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SFixed64Rules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void SFixed64Rules::InternalSwap(SFixed64Rules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  swap(const__, other->const__);
  swap(less_than_, other->less_than_);
  swap(greater_than_, other->greater_than_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SFixed64Rules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void BoolRules::InitAsDefaultInstance() {
}
class BoolRules::_Internal {
 public:
  using HasBits = decltype(std::declval<BoolRules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BoolRules::BoolRules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.BoolRules)
}
BoolRules::BoolRules(const BoolRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  const__ = from.const__;
  // @@protoc_insertion_point(copy_constructor:buf.validate.BoolRules)
}

void BoolRules::SharedCtor() {
  const__ = false;
}

BoolRules::~BoolRules() {
  // @@protoc_insertion_point(destructor:buf.validate.BoolRules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void BoolRules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void BoolRules::ArenaDtor(void* object) {
  BoolRules* _this = reinterpret_cast< BoolRules* >(object);
  (void)_this;
}
void BoolRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BoolRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BoolRules& BoolRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BoolRules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void BoolRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.BoolRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  example_.Clear();
  const__ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BoolRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bool example = 2[json_name = "example", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_example(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_example(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BoolRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.BoolRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_const_(), target);
  }

  // repeated bool example = 2[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_example(i), target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.BoolRules)
  return target;
}

size_t BoolRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.BoolRules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bool example = 2[json_name = "example", (.buf.validate.predefined) = {
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_example_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_example_size());
    total_size += data_size;
  }

  // optional bool const = 1[json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BoolRules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.BoolRules)
  GOOGLE_DCHECK_NE(&from, this);
  const BoolRules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BoolRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.BoolRules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.BoolRules)
    MergeFrom(*source);
  }
}

void BoolRules::MergeFrom(const BoolRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.BoolRules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  example_.MergeFrom(from.example_);
  if (from._internal_has_const_()) {
    _internal_set_const_(from._internal_const_());
  }
}

void BoolRules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.BoolRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BoolRules::CopyFrom(const BoolRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.BoolRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoolRules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void BoolRules::InternalSwap(BoolRules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  example_.InternalSwap(&other->example_);
  swap(const__, other->const__);
}

::PROTOBUF_NAMESPACE_ID::Metadata BoolRules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StringRules::InitAsDefaultInstance() {
  ::buf::validate::_StringRules_default_instance_.email_ = false;
  ::buf::validate::_StringRules_default_instance_.hostname_ = false;
  ::buf::validate::_StringRules_default_instance_.ip_ = false;
  ::buf::validate::_StringRules_default_instance_.ipv4_ = false;
  ::buf::validate::_StringRules_default_instance_.ipv6_ = false;
  ::buf::validate::_StringRules_default_instance_.uri_ = false;
  ::buf::validate::_StringRules_default_instance_.uri_ref_ = false;
  ::buf::validate::_StringRules_default_instance_.address_ = false;
  ::buf::validate::_StringRules_default_instance_.uuid_ = false;
  ::buf::validate::_StringRules_default_instance_.tuuid_ = false;
  ::buf::validate::_StringRules_default_instance_.ip_with_prefixlen_ = false;
  ::buf::validate::_StringRules_default_instance_.ipv4_with_prefixlen_ = false;
  ::buf::validate::_StringRules_default_instance_.ipv6_with_prefixlen_ = false;
  ::buf::validate::_StringRules_default_instance_.ip_prefix_ = false;
  ::buf::validate::_StringRules_default_instance_.ipv4_prefix_ = false;
  ::buf::validate::_StringRules_default_instance_.ipv6_prefix_ = false;
  ::buf::validate::_StringRules_default_instance_.host_and_port_ = false;
  ::buf::validate::_StringRules_default_instance_.well_known_regex_ = 0;
}
class StringRules::_Internal {
 public:
  using HasBits = decltype(std::declval<StringRules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_min_len(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_max_len(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_len_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_min_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_max_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_suffix(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contains(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_not_contains(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_strict(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

StringRules::StringRules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.StringRules)
}
StringRules::StringRules(const StringRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  const__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_const_()) {
    const__.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_const_(),
      GetArena());
  }
  pattern_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_pattern()) {
    pattern_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_pattern(),
      GetArena());
  }
  prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_prefix()) {
    prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_prefix(),
      GetArena());
  }
  suffix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_suffix()) {
    suffix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_suffix(),
      GetArena());
  }
  contains_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_contains()) {
    contains_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_contains(),
      GetArena());
  }
  not_contains_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_not_contains()) {
    not_contains_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_not_contains(),
      GetArena());
  }
  ::memcpy(&min_len_, &from.min_len_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_bytes_) -
    reinterpret_cast<char*>(&min_len_)) + sizeof(len_bytes_));
  clear_has_well_known();
  switch (from.well_known_case()) {
    case kEmail: {
      _internal_set_email(from._internal_email());
      break;
    }
    case kHostname: {
      _internal_set_hostname(from._internal_hostname());
      break;
    }
    case kIp: {
      _internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case kUri: {
      _internal_set_uri(from._internal_uri());
      break;
    }
    case kUriRef: {
      _internal_set_uri_ref(from._internal_uri_ref());
      break;
    }
    case kAddress: {
      _internal_set_address(from._internal_address());
      break;
    }
    case kUuid: {
      _internal_set_uuid(from._internal_uuid());
      break;
    }
    case kTuuid: {
      _internal_set_tuuid(from._internal_tuuid());
      break;
    }
    case kIpWithPrefixlen: {
      _internal_set_ip_with_prefixlen(from._internal_ip_with_prefixlen());
      break;
    }
    case kIpv4WithPrefixlen: {
      _internal_set_ipv4_with_prefixlen(from._internal_ipv4_with_prefixlen());
      break;
    }
    case kIpv6WithPrefixlen: {
      _internal_set_ipv6_with_prefixlen(from._internal_ipv6_with_prefixlen());
      break;
    }
    case kIpPrefix: {
      _internal_set_ip_prefix(from._internal_ip_prefix());
      break;
    }
    case kIpv4Prefix: {
      _internal_set_ipv4_prefix(from._internal_ipv4_prefix());
      break;
    }
    case kIpv6Prefix: {
      _internal_set_ipv6_prefix(from._internal_ipv6_prefix());
      break;
    }
    case kHostAndPort: {
      _internal_set_host_and_port(from._internal_host_and_port());
      break;
    }
    case kWellKnownRegex: {
      _internal_set_well_known_regex(from._internal_well_known_regex());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.StringRules)
}

void StringRules::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StringRules_buf_2fvalidate_2fvalidate_2eproto.base);
  const__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  pattern_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  suffix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  contains_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  not_contains_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&min_len_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_bytes_) -
      reinterpret_cast<char*>(&min_len_)) + sizeof(len_bytes_));
  clear_has_well_known();
}

StringRules::~StringRules() {
  // @@protoc_insertion_point(destructor:buf.validate.StringRules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StringRules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  const__.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  pattern_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  prefix_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  suffix_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  contains_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  not_contains_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (has_well_known()) {
    clear_well_known();
  }
}

void StringRules::ArenaDtor(void* object) {
  StringRules* _this = reinterpret_cast< StringRules* >(object);
  (void)_this;
}
void StringRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StringRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StringRules& StringRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StringRules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void StringRules::clear_well_known() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.StringRules)
  switch (well_known_case()) {
    case kEmail: {
      // No need to clear
      break;
    }
    case kHostname: {
      // No need to clear
      break;
    }
    case kIp: {
      // No need to clear
      break;
    }
    case kIpv4: {
      // No need to clear
      break;
    }
    case kIpv6: {
      // No need to clear
      break;
    }
    case kUri: {
      // No need to clear
      break;
    }
    case kUriRef: {
      // No need to clear
      break;
    }
    case kAddress: {
      // No need to clear
      break;
    }
    case kUuid: {
      // No need to clear
      break;
    }
    case kTuuid: {
      // No need to clear
      break;
    }
    case kIpWithPrefixlen: {
      // No need to clear
      break;
    }
    case kIpv4WithPrefixlen: {
      // No need to clear
      break;
    }
    case kIpv6WithPrefixlen: {
      // No need to clear
      break;
    }
    case kIpPrefix: {
      // No need to clear
      break;
    }
    case kIpv4Prefix: {
      // No need to clear
      break;
    }
    case kIpv6Prefix: {
      // No need to clear
      break;
    }
    case kHostAndPort: {
      // No need to clear
      break;
    }
    case kWellKnownRegex: {
      // No need to clear
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = WELL_KNOWN_NOT_SET;
}


void StringRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.StringRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      const__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      pattern_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      prefix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      suffix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      contains_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      not_contains_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&min_len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_len_) -
        reinterpret_cast<char*>(&min_len_)) + sizeof(max_len_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&min_bytes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_bytes_) -
        reinterpret_cast<char*>(&min_bytes_)) + sizeof(len_bytes_));
  }
  clear_well_known();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StringRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_const_();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.StringRules.const");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 min_len = 2[json_name = "minLen", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_min_len(&has_bits);
          min_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 max_len = 3[json_name = "maxLen", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_max_len(&has_bits);
          max_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 min_bytes = 4[json_name = "minBytes", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_min_bytes(&has_bits);
          min_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 max_bytes = 5[json_name = "maxBytes", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_max_bytes(&has_bits);
          max_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string pattern = 6[json_name = "pattern", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_pattern();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.StringRules.pattern");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string prefix = 7[json_name = "prefix", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_prefix();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.StringRules.prefix");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string suffix = 8[json_name = "suffix", (.buf.validate.predefined) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_suffix();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.StringRules.suffix");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string contains = 9[json_name = "contains", (.buf.validate.predefined) = {
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          auto str = _internal_mutable_contains();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.StringRules.contains");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string in = 10[json_name = "in", (.buf.validate.predefined) = {
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_in();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.StringRules.in");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string not_in = 11[json_name = "notIn", (.buf.validate.predefined) = {
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_not_in();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.StringRules.not_in");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else goto handle_unusual;
        continue;
      // bool email = 12[json_name = "email", (.buf.validate.predefined) = {
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _internal_set_email(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool hostname = 13[json_name = "hostname", (.buf.validate.predefined) = {
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _internal_set_hostname(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ip = 14[json_name = "ip", (.buf.validate.predefined) = {
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _internal_set_ip(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ipv4 = 15[json_name = "ipv4", (.buf.validate.predefined) = {
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _internal_set_ipv4(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ipv6 = 16[json_name = "ipv6", (.buf.validate.predefined) = {
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _internal_set_ipv6(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool uri = 17[json_name = "uri", (.buf.validate.predefined) = {
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _internal_set_uri(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool uri_ref = 18[json_name = "uriRef", (.buf.validate.predefined) = {
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _internal_set_uri_ref(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 19[json_name = "len", (.buf.validate.predefined) = {
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len_bytes = 20[json_name = "lenBytes", (.buf.validate.predefined) = {
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_len_bytes(&has_bits);
          len_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool address = 21[json_name = "address", (.buf.validate.predefined) = {
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          _internal_set_address(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool uuid = 22[json_name = "uuid", (.buf.validate.predefined) = {
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string not_contains = 23[json_name = "notContains", (.buf.validate.predefined) = {
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 186)) {
          auto str = _internal_mutable_not_contains();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.StringRules.not_contains");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .buf.validate.KnownRegex well_known_regex = 24[json_name = "wellKnownRegex", (.buf.validate.predefined) = {
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::buf::validate::KnownRegex_IsValid(val))) {
            _internal_set_well_known_regex(static_cast<::buf::validate::KnownRegex>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(24, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool strict = 25[json_name = "strict"];
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 200)) {
          _Internal::set_has_strict(&has_bits);
          strict_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ip_with_prefixlen = 26[json_name = "ipWithPrefixlen", (.buf.validate.predefined) = {
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 208)) {
          _internal_set_ip_with_prefixlen(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ipv4_with_prefixlen = 27[json_name = "ipv4WithPrefixlen", (.buf.validate.predefined) = {
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 216)) {
          _internal_set_ipv4_with_prefixlen(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ipv6_with_prefixlen = 28[json_name = "ipv6WithPrefixlen", (.buf.validate.predefined) = {
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          _internal_set_ipv6_with_prefixlen(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ip_prefix = 29[json_name = "ipPrefix", (.buf.validate.predefined) = {
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          _internal_set_ip_prefix(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ipv4_prefix = 30[json_name = "ipv4Prefix", (.buf.validate.predefined) = {
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 240)) {
          _internal_set_ipv4_prefix(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ipv6_prefix = 31[json_name = "ipv6Prefix", (.buf.validate.predefined) = {
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 248)) {
          _internal_set_ipv6_prefix(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool host_and_port = 32[json_name = "hostAndPort", (.buf.validate.predefined) = {
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 0)) {
          _internal_set_host_and_port(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool tuuid = 33[json_name = "tuuid", (.buf.validate.predefined) = {
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _internal_set_tuuid(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string example = 34[json_name = "example", (.buf.validate.predefined) = {
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_example();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.StringRules.example");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<274>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StringRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.StringRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_const_().data(), static_cast<int>(this->_internal_const_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.StringRules.const");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_const_(), target);
  }

  // optional uint64 min_len = 2[json_name = "minLen", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_min_len(), target);
  }

  // optional uint64 max_len = 3[json_name = "maxLen", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_max_len(), target);
  }

  // optional uint64 min_bytes = 4[json_name = "minBytes", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_min_bytes(), target);
  }

  // optional uint64 max_bytes = 5[json_name = "maxBytes", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_max_bytes(), target);
  }

  // optional string pattern = 6[json_name = "pattern", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pattern().data(), static_cast<int>(this->_internal_pattern().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.StringRules.pattern");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_pattern(), target);
  }

  // optional string prefix = 7[json_name = "prefix", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_prefix().data(), static_cast<int>(this->_internal_prefix().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.StringRules.prefix");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_prefix(), target);
  }

  // optional string suffix = 8[json_name = "suffix", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_suffix().data(), static_cast<int>(this->_internal_suffix().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.StringRules.suffix");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_suffix(), target);
  }

  // optional string contains = 9[json_name = "contains", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contains().data(), static_cast<int>(this->_internal_contains().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.StringRules.contains");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_contains(), target);
  }

  // repeated string in = 10[json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    const auto& s = this->_internal_in(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.StringRules.in");
    target = stream->WriteString(10, s, target);
  }

  // repeated string not_in = 11[json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    const auto& s = this->_internal_not_in(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.StringRules.not_in");
    target = stream->WriteString(11, s, target);
  }

  switch (well_known_case()) {
    case kEmail: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_email(), target);
      break;
    }
    case kHostname: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_hostname(), target);
      break;
    }
    case kIp: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_ip(), target);
      break;
    }
    case kIpv4: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_ipv4(), target);
      break;
    }
    case kIpv6: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_ipv6(), target);
      break;
    }
    case kUri: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_uri(), target);
      break;
    }
    case kUriRef: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(18, this->_internal_uri_ref(), target);
      break;
    }
    default: ;
  }
  // optional uint64 len = 19[json_name = "len", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(19, this->_internal_len(), target);
  }

  // optional uint64 len_bytes = 20[json_name = "lenBytes", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(20, this->_internal_len_bytes(), target);
  }

  switch (well_known_case()) {
    case kAddress: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(21, this->_internal_address(), target);
      break;
    }
    case kUuid: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(22, this->_internal_uuid(), target);
      break;
    }
    default: ;
  }
  // optional string not_contains = 23[json_name = "notContains", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_not_contains().data(), static_cast<int>(this->_internal_not_contains().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.StringRules.not_contains");
    target = stream->WriteStringMaybeAliased(
        23, this->_internal_not_contains(), target);
  }

  // .buf.validate.KnownRegex well_known_regex = 24[json_name = "wellKnownRegex", (.buf.validate.predefined) = {
  if (_internal_has_well_known_regex()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      24, this->_internal_well_known_regex(), target);
  }

  // optional bool strict = 25[json_name = "strict"];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(25, this->_internal_strict(), target);
  }

  switch (well_known_case()) {
    case kIpWithPrefixlen: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(26, this->_internal_ip_with_prefixlen(), target);
      break;
    }
    case kIpv4WithPrefixlen: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(27, this->_internal_ipv4_with_prefixlen(), target);
      break;
    }
    case kIpv6WithPrefixlen: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(28, this->_internal_ipv6_with_prefixlen(), target);
      break;
    }
    case kIpPrefix: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(29, this->_internal_ip_prefix(), target);
      break;
    }
    case kIpv4Prefix: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(30, this->_internal_ipv4_prefix(), target);
      break;
    }
    case kIpv6Prefix: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(31, this->_internal_ipv6_prefix(), target);
      break;
    }
    case kHostAndPort: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(32, this->_internal_host_and_port(), target);
      break;
    }
    case kTuuid: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(33, this->_internal_tuuid(), target);
      break;
    }
    default: ;
  }
  // repeated string example = 34[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    const auto& s = this->_internal_example(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.StringRules.example");
    target = stream->WriteString(34, s, target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.StringRules)
  return target;
}

size_t StringRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.StringRules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string in = 10[json_name = "in", (.buf.validate.predefined) = {
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(in_.size());
  for (int i = 0, n = in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      in_.Get(i));
  }

  // repeated string not_in = 11[json_name = "notIn", (.buf.validate.predefined) = {
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(not_in_.size());
  for (int i = 0, n = not_in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      not_in_.Get(i));
  }

  // repeated string example = 34[json_name = "example", (.buf.validate.predefined) = {
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(example_.size());
  for (int i = 0, n = example_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      example_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string const = 1[json_name = "const", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_const_());
    }

    // optional string pattern = 6[json_name = "pattern", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pattern());
    }

    // optional string prefix = 7[json_name = "prefix", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_prefix());
    }

    // optional string suffix = 8[json_name = "suffix", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_suffix());
    }

    // optional string contains = 9[json_name = "contains", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contains());
    }

    // optional string not_contains = 23[json_name = "notContains", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_not_contains());
    }

    // optional uint64 min_len = 2[json_name = "minLen", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_min_len());
    }

    // optional uint64 max_len = 3[json_name = "maxLen", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_max_len());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional uint64 min_bytes = 4[json_name = "minBytes", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_min_bytes());
    }

    // optional uint64 max_bytes = 5[json_name = "maxBytes", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_max_bytes());
    }

    // optional bool strict = 25[json_name = "strict"];
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 1;
    }

    // optional uint64 len = 19[json_name = "len", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_len());
    }

    // optional uint64 len_bytes = 20[json_name = "lenBytes", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_len_bytes());
    }

  }
  switch (well_known_case()) {
    // bool email = 12[json_name = "email", (.buf.validate.predefined) = {
    case kEmail: {
      total_size += 1 + 1;
      break;
    }
    // bool hostname = 13[json_name = "hostname", (.buf.validate.predefined) = {
    case kHostname: {
      total_size += 1 + 1;
      break;
    }
    // bool ip = 14[json_name = "ip", (.buf.validate.predefined) = {
    case kIp: {
      total_size += 1 + 1;
      break;
    }
    // bool ipv4 = 15[json_name = "ipv4", (.buf.validate.predefined) = {
    case kIpv4: {
      total_size += 1 + 1;
      break;
    }
    // bool ipv6 = 16[json_name = "ipv6", (.buf.validate.predefined) = {
    case kIpv6: {
      total_size += 2 + 1;
      break;
    }
    // bool uri = 17[json_name = "uri", (.buf.validate.predefined) = {
    case kUri: {
      total_size += 2 + 1;
      break;
    }
    // bool uri_ref = 18[json_name = "uriRef", (.buf.validate.predefined) = {
    case kUriRef: {
      total_size += 2 + 1;
      break;
    }
    // bool address = 21[json_name = "address", (.buf.validate.predefined) = {
    case kAddress: {
      total_size += 2 + 1;
      break;
    }
    // bool uuid = 22[json_name = "uuid", (.buf.validate.predefined) = {
    case kUuid: {
      total_size += 2 + 1;
      break;
    }
    // bool tuuid = 33[json_name = "tuuid", (.buf.validate.predefined) = {
    case kTuuid: {
      total_size += 2 + 1;
      break;
    }
    // bool ip_with_prefixlen = 26[json_name = "ipWithPrefixlen", (.buf.validate.predefined) = {
    case kIpWithPrefixlen: {
      total_size += 2 + 1;
      break;
    }
    // bool ipv4_with_prefixlen = 27[json_name = "ipv4WithPrefixlen", (.buf.validate.predefined) = {
    case kIpv4WithPrefixlen: {
      total_size += 2 + 1;
      break;
    }
    // bool ipv6_with_prefixlen = 28[json_name = "ipv6WithPrefixlen", (.buf.validate.predefined) = {
    case kIpv6WithPrefixlen: {
      total_size += 2 + 1;
      break;
    }
    // bool ip_prefix = 29[json_name = "ipPrefix", (.buf.validate.predefined) = {
    case kIpPrefix: {
      total_size += 2 + 1;
      break;
    }
    // bool ipv4_prefix = 30[json_name = "ipv4Prefix", (.buf.validate.predefined) = {
    case kIpv4Prefix: {
      total_size += 2 + 1;
      break;
    }
    // bool ipv6_prefix = 31[json_name = "ipv6Prefix", (.buf.validate.predefined) = {
    case kIpv6Prefix: {
      total_size += 2 + 1;
      break;
    }
    // bool host_and_port = 32[json_name = "hostAndPort", (.buf.validate.predefined) = {
    case kHostAndPort: {
      total_size += 2 + 1;
      break;
    }
    // .buf.validate.KnownRegex well_known_regex = 24[json_name = "wellKnownRegex", (.buf.validate.predefined) = {
    case kWellKnownRegex: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_well_known_regex());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StringRules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.StringRules)
  GOOGLE_DCHECK_NE(&from, this);
  const StringRules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StringRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.StringRules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.StringRules)
    MergeFrom(*source);
  }
}

void StringRules::MergeFrom(const StringRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.StringRules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_const_(from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_pattern(from._internal_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_prefix(from._internal_prefix());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_suffix(from._internal_suffix());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_contains(from._internal_contains());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_not_contains(from._internal_not_contains());
    }
    if (cached_has_bits & 0x00000040u) {
      min_len_ = from.min_len_;
    }
    if (cached_has_bits & 0x00000080u) {
      max_len_ = from.max_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      min_bytes_ = from.min_bytes_;
    }
    if (cached_has_bits & 0x00000200u) {
      max_bytes_ = from.max_bytes_;
    }
    if (cached_has_bits & 0x00000400u) {
      strict_ = from.strict_;
    }
    if (cached_has_bits & 0x00000800u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00001000u) {
      len_bytes_ = from.len_bytes_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.well_known_case()) {
    case kEmail: {
      _internal_set_email(from._internal_email());
      break;
    }
    case kHostname: {
      _internal_set_hostname(from._internal_hostname());
      break;
    }
    case kIp: {
      _internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case kUri: {
      _internal_set_uri(from._internal_uri());
      break;
    }
    case kUriRef: {
      _internal_set_uri_ref(from._internal_uri_ref());
      break;
    }
    case kAddress: {
      _internal_set_address(from._internal_address());
      break;
    }
    case kUuid: {
      _internal_set_uuid(from._internal_uuid());
      break;
    }
    case kTuuid: {
      _internal_set_tuuid(from._internal_tuuid());
      break;
    }
    case kIpWithPrefixlen: {
      _internal_set_ip_with_prefixlen(from._internal_ip_with_prefixlen());
      break;
    }
    case kIpv4WithPrefixlen: {
      _internal_set_ipv4_with_prefixlen(from._internal_ipv4_with_prefixlen());
      break;
    }
    case kIpv6WithPrefixlen: {
      _internal_set_ipv6_with_prefixlen(from._internal_ipv6_with_prefixlen());
      break;
    }
    case kIpPrefix: {
      _internal_set_ip_prefix(from._internal_ip_prefix());
      break;
    }
    case kIpv4Prefix: {
      _internal_set_ipv4_prefix(from._internal_ipv4_prefix());
      break;
    }
    case kIpv6Prefix: {
      _internal_set_ipv6_prefix(from._internal_ipv6_prefix());
      break;
    }
    case kHostAndPort: {
      _internal_set_host_and_port(from._internal_host_and_port());
      break;
    }
    case kWellKnownRegex: {
      _internal_set_well_known_regex(from._internal_well_known_regex());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
}

void StringRules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.StringRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StringRules::CopyFrom(const StringRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.StringRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringRules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void StringRules::InternalSwap(StringRules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  const__.Swap(&other->const__, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  pattern_.Swap(&other->pattern_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  prefix_.Swap(&other->prefix_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  suffix_.Swap(&other->suffix_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  contains_.Swap(&other->contains_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  not_contains_.Swap(&other->not_contains_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StringRules, len_bytes_)
      + sizeof(StringRules::len_bytes_)
      - PROTOBUF_FIELD_OFFSET(StringRules, min_len_)>(
          reinterpret_cast<char*>(&min_len_),
          reinterpret_cast<char*>(&other->min_len_));
  swap(well_known_, other->well_known_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata StringRules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void BytesRules::InitAsDefaultInstance() {
  ::buf::validate::_BytesRules_default_instance_.ip_ = false;
  ::buf::validate::_BytesRules_default_instance_.ipv4_ = false;
  ::buf::validate::_BytesRules_default_instance_.ipv6_ = false;
}
class BytesRules::_Internal {
 public:
  using HasBits = decltype(std::declval<BytesRules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_min_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_max_len(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_suffix(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contains(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

BytesRules::BytesRules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.BytesRules)
}
BytesRules::BytesRules(const BytesRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  const__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_const_()) {
    const__.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_const_(),
      GetArena());
  }
  pattern_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_pattern()) {
    pattern_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_pattern(),
      GetArena());
  }
  prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_prefix()) {
    prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_prefix(),
      GetArena());
  }
  suffix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_suffix()) {
    suffix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_suffix(),
      GetArena());
  }
  contains_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_contains()) {
    contains_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_contains(),
      GetArena());
  }
  ::memcpy(&min_len_, &from.min_len_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&min_len_)) + sizeof(len_));
  clear_has_well_known();
  switch (from.well_known_case()) {
    case kIp: {
      _internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.BytesRules)
}

void BytesRules::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BytesRules_buf_2fvalidate_2fvalidate_2eproto.base);
  const__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  pattern_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  suffix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  contains_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&min_len_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&len_) -
      reinterpret_cast<char*>(&min_len_)) + sizeof(len_));
  clear_has_well_known();
}

BytesRules::~BytesRules() {
  // @@protoc_insertion_point(destructor:buf.validate.BytesRules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void BytesRules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  const__.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  pattern_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  prefix_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  suffix_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  contains_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (has_well_known()) {
    clear_well_known();
  }
}

void BytesRules::ArenaDtor(void* object) {
  BytesRules* _this = reinterpret_cast< BytesRules* >(object);
  (void)_this;
}
void BytesRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BytesRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BytesRules& BytesRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BytesRules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void BytesRules::clear_well_known() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.BytesRules)
  switch (well_known_case()) {
    case kIp: {
      // No need to clear
      break;
    }
    case kIpv4: {
      // No need to clear
      break;
    }
    case kIpv6: {
      // No need to clear
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = WELL_KNOWN_NOT_SET;
}


void BytesRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.BytesRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      const__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      pattern_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      prefix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      suffix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      contains_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&min_len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&min_len_)) + sizeof(len_));
  }
  clear_well_known();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BytesRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_const_();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 min_len = 2[json_name = "minLen", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_min_len(&has_bits);
          min_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 max_len = 3[json_name = "maxLen", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_max_len(&has_bits);
          max_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string pattern = 4[json_name = "pattern", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_pattern();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.BytesRules.pattern");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes prefix = 5[json_name = "prefix", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_prefix();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes suffix = 6[json_name = "suffix", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_suffix();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes contains = 7[json_name = "contains", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_contains();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes in = 8[json_name = "in", (.buf.validate.predefined) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_in();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated bytes not_in = 9[json_name = "notIn", (.buf.validate.predefined) = {
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_not_in();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else goto handle_unusual;
        continue;
      // bool ip = 10[json_name = "ip", (.buf.validate.predefined) = {
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _internal_set_ip(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ipv4 = 11[json_name = "ipv4", (.buf.validate.predefined) = {
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _internal_set_ipv4(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ipv6 = 12[json_name = "ipv6", (.buf.validate.predefined) = {
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _internal_set_ipv6(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 len = 13[json_name = "len", (.buf.validate.predefined) = {
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes example = 14[json_name = "example", (.buf.validate.predefined) = {
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_example();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BytesRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.BytesRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_const_(), target);
  }

  // optional uint64 min_len = 2[json_name = "minLen", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_min_len(), target);
  }

  // optional uint64 max_len = 3[json_name = "maxLen", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_max_len(), target);
  }

  // optional string pattern = 4[json_name = "pattern", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pattern().data(), static_cast<int>(this->_internal_pattern().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.BytesRules.pattern");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_pattern(), target);
  }

  // optional bytes prefix = 5[json_name = "prefix", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_prefix(), target);
  }

  // optional bytes suffix = 6[json_name = "suffix", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_suffix(), target);
  }

  // optional bytes contains = 7[json_name = "contains", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_contains(), target);
  }

  // repeated bytes in = 8[json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    const auto& s = this->_internal_in(i);
    target = stream->WriteBytes(8, s, target);
  }

  // repeated bytes not_in = 9[json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    const auto& s = this->_internal_not_in(i);
    target = stream->WriteBytes(9, s, target);
  }

  switch (well_known_case()) {
    case kIp: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_ip(), target);
      break;
    }
    case kIpv4: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_ipv4(), target);
      break;
    }
    case kIpv6: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_ipv6(), target);
      break;
    }
    default: ;
  }
  // optional uint64 len = 13[json_name = "len", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(13, this->_internal_len(), target);
  }

  // repeated bytes example = 14[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    const auto& s = this->_internal_example(i);
    target = stream->WriteBytes(14, s, target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.BytesRules)
  return target;
}

size_t BytesRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.BytesRules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes in = 8[json_name = "in", (.buf.validate.predefined) = {
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(in_.size());
  for (int i = 0, n = in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      in_.Get(i));
  }

  // repeated bytes not_in = 9[json_name = "notIn", (.buf.validate.predefined) = {
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(not_in_.size());
  for (int i = 0, n = not_in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      not_in_.Get(i));
  }

  // repeated bytes example = 14[json_name = "example", (.buf.validate.predefined) = {
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(example_.size());
  for (int i = 0, n = example_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      example_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes const = 1[json_name = "const", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_const_());
    }

    // optional string pattern = 4[json_name = "pattern", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pattern());
    }

    // optional bytes prefix = 5[json_name = "prefix", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_prefix());
    }

    // optional bytes suffix = 6[json_name = "suffix", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_suffix());
    }

    // optional bytes contains = 7[json_name = "contains", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_contains());
    }

    // optional uint64 min_len = 2[json_name = "minLen", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_min_len());
    }

    // optional uint64 max_len = 3[json_name = "maxLen", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_max_len());
    }

    // optional uint64 len = 13[json_name = "len", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_len());
    }

  }
  switch (well_known_case()) {
    // bool ip = 10[json_name = "ip", (.buf.validate.predefined) = {
    case kIp: {
      total_size += 1 + 1;
      break;
    }
    // bool ipv4 = 11[json_name = "ipv4", (.buf.validate.predefined) = {
    case kIpv4: {
      total_size += 1 + 1;
      break;
    }
    // bool ipv6 = 12[json_name = "ipv6", (.buf.validate.predefined) = {
    case kIpv6: {
      total_size += 1 + 1;
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BytesRules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.BytesRules)
  GOOGLE_DCHECK_NE(&from, this);
  const BytesRules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BytesRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.BytesRules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.BytesRules)
    MergeFrom(*source);
  }
}

void BytesRules::MergeFrom(const BytesRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.BytesRules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_const_(from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_pattern(from._internal_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_prefix(from._internal_prefix());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_suffix(from._internal_suffix());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_contains(from._internal_contains());
    }
    if (cached_has_bits & 0x00000020u) {
      min_len_ = from.min_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      max_len_ = from.max_len_;
    }
    if (cached_has_bits & 0x00000080u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.well_known_case()) {
    case kIp: {
      _internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
}

void BytesRules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.BytesRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BytesRules::CopyFrom(const BytesRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.BytesRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BytesRules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void BytesRules::InternalSwap(BytesRules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  const__.Swap(&other->const__, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  pattern_.Swap(&other->pattern_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  prefix_.Swap(&other->prefix_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  suffix_.Swap(&other->suffix_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  contains_.Swap(&other->contains_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BytesRules, len_)
      + sizeof(BytesRules::len_)
      - PROTOBUF_FIELD_OFFSET(BytesRules, min_len_)>(
          reinterpret_cast<char*>(&min_len_),
          reinterpret_cast<char*>(&other->min_len_));
  swap(well_known_, other->well_known_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata BytesRules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void EnumRules::InitAsDefaultInstance() {
}
class EnumRules::_Internal {
 public:
  using HasBits = decltype(std::declval<EnumRules>()._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_defined_only(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

EnumRules::EnumRules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.EnumRules)
}
EnumRules::EnumRules(const EnumRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  ::memcpy(&const__, &from.const__,
    static_cast<size_t>(reinterpret_cast<char*>(&defined_only_) -
    reinterpret_cast<char*>(&const__)) + sizeof(defined_only_));
  // @@protoc_insertion_point(copy_constructor:buf.validate.EnumRules)
}

void EnumRules::SharedCtor() {
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&defined_only_) -
      reinterpret_cast<char*>(&const__)) + sizeof(defined_only_));
}

EnumRules::~EnumRules() {
  // @@protoc_insertion_point(destructor:buf.validate.EnumRules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EnumRules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EnumRules::ArenaDtor(void* object) {
  EnumRules* _this = reinterpret_cast< EnumRules* >(object);
  (void)_this;
}
void EnumRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EnumRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EnumRules& EnumRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EnumRules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void EnumRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.EnumRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&const__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&defined_only_) -
        reinterpret_cast<char*>(&const__)) + sizeof(defined_only_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EnumRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 const = 1[json_name = "const", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_const_(&has_bits);
          const__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool defined_only = 2[json_name = "definedOnly"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_defined_only(&has_bits);
          defined_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 in = 3[json_name = "in", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 not_in = 4[json_name = "notIn", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_not_in(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_not_in(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 example = 5[json_name = "example", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_example(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_example(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EnumRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.EnumRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 const = 1[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_const_(), target);
  }

  // optional bool defined_only = 2[json_name = "definedOnly"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_defined_only(), target);
  }

  // repeated int32 in = 3[json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_in(i), target);
  }

  // repeated int32 not_in = 4[json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_not_in(i), target);
  }

  // repeated int32 example = 5[json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_example(i), target);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.EnumRules)
  return target;
}

size_t EnumRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.EnumRules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 in = 3[json_name = "in", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_in_size());
    total_size += data_size;
  }

  // repeated int32 not_in = 4[json_name = "notIn", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->not_in_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_not_in_size());
    total_size += data_size;
  }

  // repeated int32 example = 5[json_name = "example", (.buf.validate.predefined) = {
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->example_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_example_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 const = 1[json_name = "const", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_const_());
    }

    // optional bool defined_only = 2[json_name = "definedOnly"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EnumRules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.EnumRules)
  GOOGLE_DCHECK_NE(&from, this);
  const EnumRules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EnumRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.EnumRules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.EnumRules)
    MergeFrom(*source);
  }
}

void EnumRules::MergeFrom(const EnumRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.EnumRules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      const__ = from.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      defined_only_ = from.defined_only_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EnumRules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.EnumRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EnumRules::CopyFrom(const EnumRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.EnumRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnumRules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void EnumRules::InternalSwap(EnumRules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnumRules, defined_only_)
      + sizeof(EnumRules::defined_only_)
      - PROTOBUF_FIELD_OFFSET(EnumRules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
}

::PROTOBUF_NAMESPACE_ID::Metadata EnumRules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RepeatedRules::InitAsDefaultInstance() {
  ::buf::validate::_RepeatedRules_default_instance_._instance.get_mutable()->items_ = const_cast< ::buf::validate::FieldRules*>(
      ::buf::validate::FieldRules::internal_default_instance());
}
class RepeatedRules::_Internal {
 public:
  using HasBits = decltype(std::declval<RepeatedRules>()._has_bits_);
  static void set_has_min_items(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_items(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_unique(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::buf::validate::FieldRules& items(const RepeatedRules* msg);
  static void set_has_items(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::buf::validate::FieldRules&
RepeatedRules::_Internal::items(const RepeatedRules* msg) {
  return *msg->items_;
}
RepeatedRules::RepeatedRules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.RepeatedRules)
}
RepeatedRules::RepeatedRules(const RepeatedRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  if (from._internal_has_items()) {
    items_ = new ::buf::validate::FieldRules(*from.items_);
  } else {
    items_ = nullptr;
  }
  ::memcpy(&min_items_, &from.min_items_,
    static_cast<size_t>(reinterpret_cast<char*>(&unique_) -
    reinterpret_cast<char*>(&min_items_)) + sizeof(unique_));
  // @@protoc_insertion_point(copy_constructor:buf.validate.RepeatedRules)
}

void RepeatedRules::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FieldRules_buf_2fvalidate_2fvalidate_2eproto.base);
  ::memset(&items_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&unique_) -
      reinterpret_cast<char*>(&items_)) + sizeof(unique_));
}

RepeatedRules::~RepeatedRules() {
  // @@protoc_insertion_point(destructor:buf.validate.RepeatedRules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void RepeatedRules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete items_;
}

void RepeatedRules::ArenaDtor(void* object) {
  RepeatedRules* _this = reinterpret_cast< RepeatedRules* >(object);
  (void)_this;
}
void RepeatedRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RepeatedRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RepeatedRules& RepeatedRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FieldRules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void RepeatedRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.RepeatedRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(items_ != nullptr);
    items_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&min_items_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&unique_) -
        reinterpret_cast<char*>(&min_items_)) + sizeof(unique_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RepeatedRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 min_items = 1[json_name = "minItems", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_min_items(&has_bits);
          min_items_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 max_items = 2[json_name = "maxItems", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_max_items(&has_bits);
          max_items_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool unique = 3[json_name = "unique", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_unique(&has_bits);
          unique_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .buf.validate.FieldRules items = 4[json_name = "items"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_items(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RepeatedRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.RepeatedRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 min_items = 1[json_name = "minItems", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_min_items(), target);
  }

  // optional uint64 max_items = 2[json_name = "maxItems", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_max_items(), target);
  }

  // optional bool unique = 3[json_name = "unique", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_unique(), target);
  }

  // optional .buf.validate.FieldRules items = 4[json_name = "items"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::items(this), target, stream);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.RepeatedRules)
  return target;
}

size_t RepeatedRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.RepeatedRules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .buf.validate.FieldRules items = 4[json_name = "items"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *items_);
    }

    // optional uint64 min_items = 1[json_name = "minItems", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_min_items());
    }

    // optional uint64 max_items = 2[json_name = "maxItems", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_max_items());
    }

    // optional bool unique = 3[json_name = "unique", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RepeatedRules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.RepeatedRules)
  GOOGLE_DCHECK_NE(&from, this);
  const RepeatedRules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RepeatedRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.RepeatedRules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.RepeatedRules)
    MergeFrom(*source);
  }
}

void RepeatedRules::MergeFrom(const RepeatedRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.RepeatedRules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_items()->::buf::validate::FieldRules::MergeFrom(from._internal_items());
    }
    if (cached_has_bits & 0x00000002u) {
      min_items_ = from.min_items_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_items_ = from.max_items_;
    }
    if (cached_has_bits & 0x00000008u) {
      unique_ = from.unique_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RepeatedRules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.RepeatedRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RepeatedRules::CopyFrom(const RepeatedRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.RepeatedRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepeatedRules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  if (_internal_has_items()) {
    if (!items_->IsInitialized()) return false;
  }
  return true;
}

void RepeatedRules::InternalSwap(RepeatedRules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RepeatedRules, unique_)
      + sizeof(RepeatedRules::unique_)
      - PROTOBUF_FIELD_OFFSET(RepeatedRules, items_)>(
          reinterpret_cast<char*>(&items_),
          reinterpret_cast<char*>(&other->items_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RepeatedRules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MapRules::InitAsDefaultInstance() {
  ::buf::validate::_MapRules_default_instance_._instance.get_mutable()->keys_ = const_cast< ::buf::validate::FieldRules*>(
      ::buf::validate::FieldRules::internal_default_instance());
  ::buf::validate::_MapRules_default_instance_._instance.get_mutable()->values_ = const_cast< ::buf::validate::FieldRules*>(
      ::buf::validate::FieldRules::internal_default_instance());
}
class MapRules::_Internal {
 public:
  using HasBits = decltype(std::declval<MapRules>()._has_bits_);
  static void set_has_min_pairs(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_pairs(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::buf::validate::FieldRules& keys(const MapRules* msg);
  static void set_has_keys(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::buf::validate::FieldRules& values(const MapRules* msg);
  static void set_has_values(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::buf::validate::FieldRules&
MapRules::_Internal::keys(const MapRules* msg) {
  return *msg->keys_;
}
const ::buf::validate::FieldRules&
MapRules::_Internal::values(const MapRules* msg) {
  return *msg->values_;
}
MapRules::MapRules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.MapRules)
}
MapRules::MapRules(const MapRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  if (from._internal_has_keys()) {
    keys_ = new ::buf::validate::FieldRules(*from.keys_);
  } else {
    keys_ = nullptr;
  }
  if (from._internal_has_values()) {
    values_ = new ::buf::validate::FieldRules(*from.values_);
  } else {
    values_ = nullptr;
  }
  ::memcpy(&min_pairs_, &from.min_pairs_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_pairs_) -
    reinterpret_cast<char*>(&min_pairs_)) + sizeof(max_pairs_));
  // @@protoc_insertion_point(copy_constructor:buf.validate.MapRules)
}

void MapRules::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FieldRules_buf_2fvalidate_2fvalidate_2eproto.base);
  ::memset(&keys_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_pairs_) -
      reinterpret_cast<char*>(&keys_)) + sizeof(max_pairs_));
}

MapRules::~MapRules() {
  // @@protoc_insertion_point(destructor:buf.validate.MapRules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MapRules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete keys_;
  if (this != internal_default_instance()) delete values_;
}

void MapRules::ArenaDtor(void* object) {
  MapRules* _this = reinterpret_cast< MapRules* >(object);
  (void)_this;
}
void MapRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MapRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MapRules& MapRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FieldRules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void MapRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.MapRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(keys_ != nullptr);
      keys_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(values_ != nullptr);
      values_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&min_pairs_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_pairs_) -
        reinterpret_cast<char*>(&min_pairs_)) + sizeof(max_pairs_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MapRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 min_pairs = 1[json_name = "minPairs", (.buf.validate.predefined) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_min_pairs(&has_bits);
          min_pairs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 max_pairs = 2[json_name = "maxPairs", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_max_pairs(&has_bits);
          max_pairs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .buf.validate.FieldRules keys = 4[json_name = "keys"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_keys(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .buf.validate.FieldRules values = 5[json_name = "values"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_values(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MapRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.MapRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 min_pairs = 1[json_name = "minPairs", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_min_pairs(), target);
  }

  // optional uint64 max_pairs = 2[json_name = "maxPairs", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_max_pairs(), target);
  }

  // optional .buf.validate.FieldRules keys = 4[json_name = "keys"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::keys(this), target, stream);
  }

  // optional .buf.validate.FieldRules values = 5[json_name = "values"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::values(this), target, stream);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.MapRules)
  return target;
}

size_t MapRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.MapRules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .buf.validate.FieldRules keys = 4[json_name = "keys"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *keys_);
    }

    // optional .buf.validate.FieldRules values = 5[json_name = "values"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *values_);
    }

    // optional uint64 min_pairs = 1[json_name = "minPairs", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_min_pairs());
    }

    // optional uint64 max_pairs = 2[json_name = "maxPairs", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_max_pairs());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MapRules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.MapRules)
  GOOGLE_DCHECK_NE(&from, this);
  const MapRules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MapRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.MapRules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.MapRules)
    MergeFrom(*source);
  }
}

void MapRules::MergeFrom(const MapRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.MapRules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_keys()->::buf::validate::FieldRules::MergeFrom(from._internal_keys());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_values()->::buf::validate::FieldRules::MergeFrom(from._internal_values());
    }
    if (cached_has_bits & 0x00000004u) {
      min_pairs_ = from.min_pairs_;
    }
    if (cached_has_bits & 0x00000008u) {
      max_pairs_ = from.max_pairs_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MapRules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.MapRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapRules::CopyFrom(const MapRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.MapRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapRules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  if (_internal_has_keys()) {
    if (!keys_->IsInitialized()) return false;
  }
  if (_internal_has_values()) {
    if (!values_->IsInitialized()) return false;
  }
  return true;
}

void MapRules::InternalSwap(MapRules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MapRules, max_pairs_)
      + sizeof(MapRules::max_pairs_)
      - PROTOBUF_FIELD_OFFSET(MapRules, keys_)>(
          reinterpret_cast<char*>(&keys_),
          reinterpret_cast<char*>(&other->keys_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MapRules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AnyRules::InitAsDefaultInstance() {
}
class AnyRules::_Internal {
 public:
};

AnyRules::AnyRules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  in_(arena),
  not_in_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.AnyRules)
}
AnyRules::AnyRules(const AnyRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      in_(from.in_),
      not_in_(from.not_in_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:buf.validate.AnyRules)
}

void AnyRules::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AnyRules_buf_2fvalidate_2fvalidate_2eproto.base);
}

AnyRules::~AnyRules() {
  // @@protoc_insertion_point(destructor:buf.validate.AnyRules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AnyRules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AnyRules::ArenaDtor(void* object) {
  AnyRules* _this = reinterpret_cast< AnyRules* >(object);
  (void)_this;
}
void AnyRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AnyRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AnyRules& AnyRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AnyRules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void AnyRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.AnyRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_.Clear();
  not_in_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnyRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated string in = 2[json_name = "in"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_in();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.AnyRules.in");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string not_in = 3[json_name = "notIn"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_not_in();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.AnyRules.not_in");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AnyRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.AnyRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string in = 2[json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; i++) {
    const auto& s = this->_internal_in(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.AnyRules.in");
    target = stream->WriteString(2, s, target);
  }

  // repeated string not_in = 3[json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; i++) {
    const auto& s = this->_internal_not_in(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.AnyRules.not_in");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.AnyRules)
  return target;
}

size_t AnyRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.AnyRules)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string in = 2[json_name = "in"];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(in_.size());
  for (int i = 0, n = in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      in_.Get(i));
  }

  // repeated string not_in = 3[json_name = "notIn"];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(not_in_.size());
  for (int i = 0, n = not_in_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      not_in_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AnyRules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.AnyRules)
  GOOGLE_DCHECK_NE(&from, this);
  const AnyRules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AnyRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.AnyRules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.AnyRules)
    MergeFrom(*source);
  }
}

void AnyRules::MergeFrom(const AnyRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.AnyRules)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
}

void AnyRules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.AnyRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AnyRules::CopyFrom(const AnyRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.AnyRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnyRules::IsInitialized() const {
  return true;
}

void AnyRules::InternalSwap(AnyRules* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AnyRules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void DurationRules::InitAsDefaultInstance() {
  ::buf::validate::_DurationRules_default_instance_._instance.get_mutable()->const__ = const_cast< PROTOBUF_NAMESPACE_ID::Duration*>(
      PROTOBUF_NAMESPACE_ID::Duration::internal_default_instance());
  ::buf::validate::_DurationRules_default_instance_.lt_ = const_cast< PROTOBUF_NAMESPACE_ID::Duration*>(
      PROTOBUF_NAMESPACE_ID::Duration::internal_default_instance());
  ::buf::validate::_DurationRules_default_instance_.lte_ = const_cast< PROTOBUF_NAMESPACE_ID::Duration*>(
      PROTOBUF_NAMESPACE_ID::Duration::internal_default_instance());
  ::buf::validate::_DurationRules_default_instance_.gt_ = const_cast< PROTOBUF_NAMESPACE_ID::Duration*>(
      PROTOBUF_NAMESPACE_ID::Duration::internal_default_instance());
  ::buf::validate::_DurationRules_default_instance_.gte_ = const_cast< PROTOBUF_NAMESPACE_ID::Duration*>(
      PROTOBUF_NAMESPACE_ID::Duration::internal_default_instance());
}
class DurationRules::_Internal {
 public:
  using HasBits = decltype(std::declval<DurationRules>()._has_bits_);
  static const PROTOBUF_NAMESPACE_ID::Duration& const_(const DurationRules* msg);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const PROTOBUF_NAMESPACE_ID::Duration& lt(const DurationRules* msg);
  static const PROTOBUF_NAMESPACE_ID::Duration& lte(const DurationRules* msg);
  static const PROTOBUF_NAMESPACE_ID::Duration& gt(const DurationRules* msg);
  static const PROTOBUF_NAMESPACE_ID::Duration& gte(const DurationRules* msg);
};

const PROTOBUF_NAMESPACE_ID::Duration&
DurationRules::_Internal::const_(const DurationRules* msg) {
  return *msg->const__;
}
const PROTOBUF_NAMESPACE_ID::Duration&
DurationRules::_Internal::lt(const DurationRules* msg) {
  return *msg->less_than_.lt_;
}
const PROTOBUF_NAMESPACE_ID::Duration&
DurationRules::_Internal::lte(const DurationRules* msg) {
  return *msg->less_than_.lte_;
}
const PROTOBUF_NAMESPACE_ID::Duration&
DurationRules::_Internal::gt(const DurationRules* msg) {
  return *msg->greater_than_.gt_;
}
const PROTOBUF_NAMESPACE_ID::Duration&
DurationRules::_Internal::gte(const DurationRules* msg) {
  return *msg->greater_than_.gte_;
}
void DurationRules::clear_const_() {
  if (const__ != nullptr) const__->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void DurationRules::set_allocated_lt(PROTOBUF_NAMESPACE_ID::Duration* lt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_less_than();
  if (lt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lt)->GetArena();
    if (message_arena != submessage_arena) {
      lt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lt, submessage_arena);
    }
    set_has_lt();
    less_than_.lt_ = lt;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.DurationRules.lt)
}
void DurationRules::clear_lt() {
  if (_internal_has_lt()) {
    if (GetArena() == nullptr) {
      delete less_than_.lt_;
    }
    clear_has_less_than();
  }
}
void DurationRules::set_allocated_lte(PROTOBUF_NAMESPACE_ID::Duration* lte) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_less_than();
  if (lte) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lte)->GetArena();
    if (message_arena != submessage_arena) {
      lte = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lte, submessage_arena);
    }
    set_has_lte();
    less_than_.lte_ = lte;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.DurationRules.lte)
}
void DurationRules::clear_lte() {
  if (_internal_has_lte()) {
    if (GetArena() == nullptr) {
      delete less_than_.lte_;
    }
    clear_has_less_than();
  }
}
void DurationRules::set_allocated_gt(PROTOBUF_NAMESPACE_ID::Duration* gt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_greater_than();
  if (gt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gt)->GetArena();
    if (message_arena != submessage_arena) {
      gt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gt, submessage_arena);
    }
    set_has_gt();
    greater_than_.gt_ = gt;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.DurationRules.gt)
}
void DurationRules::clear_gt() {
  if (_internal_has_gt()) {
    if (GetArena() == nullptr) {
      delete greater_than_.gt_;
    }
    clear_has_greater_than();
  }
}
void DurationRules::set_allocated_gte(PROTOBUF_NAMESPACE_ID::Duration* gte) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_greater_than();
  if (gte) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gte)->GetArena();
    if (message_arena != submessage_arena) {
      gte = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gte, submessage_arena);
    }
    set_has_gte();
    greater_than_.gte_ = gte;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.DurationRules.gte)
}
void DurationRules::clear_gte() {
  if (_internal_has_gte()) {
    if (GetArena() == nullptr) {
      delete greater_than_.gte_;
    }
    clear_has_greater_than();
  }
}
void DurationRules::clear_in() {
  in_.Clear();
}
void DurationRules::clear_not_in() {
  not_in_.Clear();
}
void DurationRules::clear_example() {
  example_.Clear();
}
DurationRules::DurationRules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  in_(arena),
  not_in_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.DurationRules)
}
DurationRules::DurationRules(const DurationRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      in_(from.in_),
      not_in_(from.not_in_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  if (from._internal_has_const_()) {
    const__ = new PROTOBUF_NAMESPACE_ID::Duration(*from.const__);
  } else {
    const__ = nullptr;
  }
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _internal_mutable_lt()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_mutable_lte()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_mutable_gt()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_mutable_gte()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.DurationRules)
}

void DurationRules::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DurationRules_buf_2fvalidate_2fvalidate_2eproto.base);
  const__ = nullptr;
  clear_has_less_than();
  clear_has_greater_than();
}

DurationRules::~DurationRules() {
  // @@protoc_insertion_point(destructor:buf.validate.DurationRules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void DurationRules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete const__;
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}

void DurationRules::ArenaDtor(void* object) {
  DurationRules* _this = reinterpret_cast< DurationRules* >(object);
  (void)_this;
}
void DurationRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DurationRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DurationRules& DurationRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DurationRules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void DurationRules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.DurationRules)
  switch (less_than_case()) {
    case kLt: {
      if (GetArena() == nullptr) {
        delete less_than_.lt_;
      }
      break;
    }
    case kLte: {
      if (GetArena() == nullptr) {
        delete less_than_.lte_;
      }
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LESS_THAN_NOT_SET;
}

void DurationRules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.DurationRules)
  switch (greater_than_case()) {
    case kGt: {
      if (GetArena() == nullptr) {
        delete greater_than_.gt_;
      }
      break;
    }
    case kGte: {
      if (GetArena() == nullptr) {
        delete greater_than_.gte_;
      }
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = GREATER_THAN_NOT_SET;
}


void DurationRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.DurationRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  in_.Clear();
  not_in_.Clear();
  example_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(const__ != nullptr);
    const__->Clear();
  }
  clear_less_than();
  clear_greater_than();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DurationRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .google.protobuf.Duration const = 2[json_name = "const", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_const_(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .google.protobuf.Duration lt = 3[json_name = "lt", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .google.protobuf.Duration lte = 4[json_name = "lte", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lte(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .google.protobuf.Duration gt = 5[json_name = "gt", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_gt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .google.protobuf.Duration gte = 6[json_name = "gte", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_gte(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .google.protobuf.Duration in = 7[json_name = "in", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_in(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .google.protobuf.Duration not_in = 8[json_name = "notIn", (.buf.validate.predefined) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_not_in(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .google.protobuf.Duration example = 9[json_name = "example", (.buf.validate.predefined) = {
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_example(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DurationRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.DurationRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .google.protobuf.Duration const = 2[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::const_(this), target, stream);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          3, _Internal::lt(this), target, stream);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          4, _Internal::lte(this), target, stream);
      break;
    }
    default: ;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          5, _Internal::gt(this), target, stream);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          6, _Internal::gte(this), target, stream);
      break;
    }
    default: ;
  }
  // repeated .google.protobuf.Duration in = 7[json_name = "in", (.buf.validate.predefined) = {
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_in_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_in(i), target, stream);
  }

  // repeated .google.protobuf.Duration not_in = 8[json_name = "notIn", (.buf.validate.predefined) = {
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_not_in_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_not_in(i), target, stream);
  }

  // repeated .google.protobuf.Duration example = 9[json_name = "example", (.buf.validate.predefined) = {
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_example_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, this->_internal_example(i), target, stream);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.DurationRules)
  return target;
}

size_t DurationRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.DurationRules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Duration in = 7[json_name = "in", (.buf.validate.predefined) = {
  total_size += 1UL * this->_internal_in_size();
  for (const auto& msg : this->in_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .google.protobuf.Duration not_in = 8[json_name = "notIn", (.buf.validate.predefined) = {
  total_size += 1UL * this->_internal_not_in_size();
  for (const auto& msg : this->not_in_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .google.protobuf.Duration example = 9[json_name = "example", (.buf.validate.predefined) = {
  total_size += 1UL * this->_internal_example_size();
  for (const auto& msg : this->example_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .google.protobuf.Duration const = 2[json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *const__);
  }

  switch (less_than_case()) {
    // .google.protobuf.Duration lt = 3[json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *less_than_.lt_);
      break;
    }
    // .google.protobuf.Duration lte = 4[json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *less_than_.lte_);
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // .google.protobuf.Duration gt = 5[json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *greater_than_.gt_);
      break;
    }
    // .google.protobuf.Duration gte = 6[json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *greater_than_.gte_);
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DurationRules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.DurationRules)
  GOOGLE_DCHECK_NE(&from, this);
  const DurationRules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DurationRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.DurationRules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.DurationRules)
    MergeFrom(*source);
  }
}

void DurationRules::MergeFrom(const DurationRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.DurationRules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  in_.MergeFrom(from.in_);
  not_in_.MergeFrom(from.not_in_);
  example_.MergeFrom(from.example_);
  if (from._internal_has_const_()) {
    _internal_mutable_const_()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _internal_mutable_lt()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_mutable_lte()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_mutable_gt()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_mutable_gte()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
}

void DurationRules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.DurationRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DurationRules::CopyFrom(const DurationRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.DurationRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DurationRules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void DurationRules::InternalSwap(DurationRules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  in_.InternalSwap(&other->in_);
  not_in_.InternalSwap(&other->not_in_);
  example_.InternalSwap(&other->example_);
  swap(const__, other->const__);
  swap(less_than_, other->less_than_);
  swap(greater_than_, other->greater_than_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata DurationRules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TimestampRules::InitAsDefaultInstance() {
  ::buf::validate::_TimestampRules_default_instance_._instance.get_mutable()->const__ = const_cast< PROTOBUF_NAMESPACE_ID::Timestamp*>(
      PROTOBUF_NAMESPACE_ID::Timestamp::internal_default_instance());
  ::buf::validate::_TimestampRules_default_instance_.lt_ = const_cast< PROTOBUF_NAMESPACE_ID::Timestamp*>(
      PROTOBUF_NAMESPACE_ID::Timestamp::internal_default_instance());
  ::buf::validate::_TimestampRules_default_instance_.lte_ = const_cast< PROTOBUF_NAMESPACE_ID::Timestamp*>(
      PROTOBUF_NAMESPACE_ID::Timestamp::internal_default_instance());
  ::buf::validate::_TimestampRules_default_instance_.lt_now_ = false;
  ::buf::validate::_TimestampRules_default_instance_.gt_ = const_cast< PROTOBUF_NAMESPACE_ID::Timestamp*>(
      PROTOBUF_NAMESPACE_ID::Timestamp::internal_default_instance());
  ::buf::validate::_TimestampRules_default_instance_.gte_ = const_cast< PROTOBUF_NAMESPACE_ID::Timestamp*>(
      PROTOBUF_NAMESPACE_ID::Timestamp::internal_default_instance());
  ::buf::validate::_TimestampRules_default_instance_.gt_now_ = false;
  ::buf::validate::_TimestampRules_default_instance_._instance.get_mutable()->within_ = const_cast< PROTOBUF_NAMESPACE_ID::Duration*>(
      PROTOBUF_NAMESPACE_ID::Duration::internal_default_instance());
}
class TimestampRules::_Internal {
 public:
  using HasBits = decltype(std::declval<TimestampRules>()._has_bits_);
  static const PROTOBUF_NAMESPACE_ID::Timestamp& const_(const TimestampRules* msg);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const PROTOBUF_NAMESPACE_ID::Timestamp& lt(const TimestampRules* msg);
  static const PROTOBUF_NAMESPACE_ID::Timestamp& lte(const TimestampRules* msg);
  static const PROTOBUF_NAMESPACE_ID::Timestamp& gt(const TimestampRules* msg);
  static const PROTOBUF_NAMESPACE_ID::Timestamp& gte(const TimestampRules* msg);
  static const PROTOBUF_NAMESPACE_ID::Duration& within(const TimestampRules* msg);
  static void set_has_within(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const PROTOBUF_NAMESPACE_ID::Timestamp&
TimestampRules::_Internal::const_(const TimestampRules* msg) {
  return *msg->const__;
}
const PROTOBUF_NAMESPACE_ID::Timestamp&
TimestampRules::_Internal::lt(const TimestampRules* msg) {
  return *msg->less_than_.lt_;
}
const PROTOBUF_NAMESPACE_ID::Timestamp&
TimestampRules::_Internal::lte(const TimestampRules* msg) {
  return *msg->less_than_.lte_;
}
const PROTOBUF_NAMESPACE_ID::Timestamp&
TimestampRules::_Internal::gt(const TimestampRules* msg) {
  return *msg->greater_than_.gt_;
}
const PROTOBUF_NAMESPACE_ID::Timestamp&
TimestampRules::_Internal::gte(const TimestampRules* msg) {
  return *msg->greater_than_.gte_;
}
const PROTOBUF_NAMESPACE_ID::Duration&
TimestampRules::_Internal::within(const TimestampRules* msg) {
  return *msg->within_;
}
void TimestampRules::clear_const_() {
  if (const__ != nullptr) const__->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void TimestampRules::set_allocated_lt(PROTOBUF_NAMESPACE_ID::Timestamp* lt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_less_than();
  if (lt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lt)->GetArena();
    if (message_arena != submessage_arena) {
      lt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lt, submessage_arena);
    }
    set_has_lt();
    less_than_.lt_ = lt;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.lt)
}
void TimestampRules::clear_lt() {
  if (_internal_has_lt()) {
    if (GetArena() == nullptr) {
      delete less_than_.lt_;
    }
    clear_has_less_than();
  }
}
void TimestampRules::set_allocated_lte(PROTOBUF_NAMESPACE_ID::Timestamp* lte) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_less_than();
  if (lte) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lte)->GetArena();
    if (message_arena != submessage_arena) {
      lte = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lte, submessage_arena);
    }
    set_has_lte();
    less_than_.lte_ = lte;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.lte)
}
void TimestampRules::clear_lte() {
  if (_internal_has_lte()) {
    if (GetArena() == nullptr) {
      delete less_than_.lte_;
    }
    clear_has_less_than();
  }
}
void TimestampRules::set_allocated_gt(PROTOBUF_NAMESPACE_ID::Timestamp* gt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_greater_than();
  if (gt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gt)->GetArena();
    if (message_arena != submessage_arena) {
      gt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gt, submessage_arena);
    }
    set_has_gt();
    greater_than_.gt_ = gt;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.gt)
}
void TimestampRules::clear_gt() {
  if (_internal_has_gt()) {
    if (GetArena() == nullptr) {
      delete greater_than_.gt_;
    }
    clear_has_greater_than();
  }
}
void TimestampRules::set_allocated_gte(PROTOBUF_NAMESPACE_ID::Timestamp* gte) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_greater_than();
  if (gte) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gte)->GetArena();
    if (message_arena != submessage_arena) {
      gte = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gte, submessage_arena);
    }
    set_has_gte();
    greater_than_.gte_ = gte;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.gte)
}
void TimestampRules::clear_gte() {
  if (_internal_has_gte()) {
    if (GetArena() == nullptr) {
      delete greater_than_.gte_;
    }
    clear_has_greater_than();
  }
}
void TimestampRules::clear_within() {
  if (within_ != nullptr) within_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void TimestampRules::clear_example() {
  example_.Clear();
}
TimestampRules::TimestampRules(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena),
  example_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.TimestampRules)
}
TimestampRules::TimestampRules(const TimestampRules& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      example_(from.example_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  if (from._internal_has_const_()) {
    const__ = new PROTOBUF_NAMESPACE_ID::Timestamp(*from.const__);
  } else {
    const__ = nullptr;
  }
  if (from._internal_has_within()) {
    within_ = new PROTOBUF_NAMESPACE_ID::Duration(*from.within_);
  } else {
    within_ = nullptr;
  }
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _internal_mutable_lt()->PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_mutable_lte()->PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(from._internal_lte());
      break;
    }
    case kLtNow: {
      _internal_set_lt_now(from._internal_lt_now());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_mutable_gt()->PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_mutable_gte()->PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(from._internal_gte());
      break;
    }
    case kGtNow: {
      _internal_set_gt_now(from._internal_gt_now());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.TimestampRules)
}

void TimestampRules::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TimestampRules_buf_2fvalidate_2fvalidate_2eproto.base);
  ::memset(&const__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&within_) -
      reinterpret_cast<char*>(&const__)) + sizeof(within_));
  clear_has_less_than();
  clear_has_greater_than();
}

TimestampRules::~TimestampRules() {
  // @@protoc_insertion_point(destructor:buf.validate.TimestampRules)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TimestampRules::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete const__;
  if (this != internal_default_instance()) delete within_;
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}

void TimestampRules::ArenaDtor(void* object) {
  TimestampRules* _this = reinterpret_cast< TimestampRules* >(object);
  (void)_this;
}
void TimestampRules::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TimestampRules::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TimestampRules& TimestampRules::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TimestampRules_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void TimestampRules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.TimestampRules)
  switch (less_than_case()) {
    case kLt: {
      if (GetArena() == nullptr) {
        delete less_than_.lt_;
      }
      break;
    }
    case kLte: {
      if (GetArena() == nullptr) {
        delete less_than_.lte_;
      }
      break;
    }
    case kLtNow: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = LESS_THAN_NOT_SET;
}

void TimestampRules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.TimestampRules)
  switch (greater_than_case()) {
    case kGt: {
      if (GetArena() == nullptr) {
        delete greater_than_.gt_;
      }
      break;
    }
    case kGte: {
      if (GetArena() == nullptr) {
        delete greater_than_.gte_;
      }
      break;
    }
    case kGtNow: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = GREATER_THAN_NOT_SET;
}


void TimestampRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.TimestampRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  example_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(const__ != nullptr);
      const__->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(within_ != nullptr);
      within_->Clear();
    }
  }
  clear_less_than();
  clear_greater_than();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TimestampRules::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .google.protobuf.Timestamp const = 2[json_name = "const", (.buf.validate.predefined) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_const_(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp lt = 3[json_name = "lt", (.buf.validate.predefined) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp lte = 4[json_name = "lte", (.buf.validate.predefined) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lte(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp gt = 5[json_name = "gt", (.buf.validate.predefined) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_gt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp gte = 6[json_name = "gte", (.buf.validate.predefined) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_gte(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool lt_now = 7[json_name = "ltNow", (.buf.validate.predefined) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _internal_set_lt_now(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool gt_now = 8[json_name = "gtNow", (.buf.validate.predefined) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _internal_set_gt_now(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .google.protobuf.Duration within = 9[json_name = "within", (.buf.validate.predefined) = {
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_within(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .google.protobuf.Timestamp example = 10[json_name = "example", (.buf.validate.predefined) = {
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_example(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8000u <= tag)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TimestampRules::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.TimestampRules)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .google.protobuf.Timestamp const = 2[json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::const_(this), target, stream);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          3, _Internal::lt(this), target, stream);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          4, _Internal::lte(this), target, stream);
      break;
    }
    default: ;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          5, _Internal::gt(this), target, stream);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          6, _Internal::gte(this), target, stream);
      break;
    }
    default: ;
  }
  // bool lt_now = 7[json_name = "ltNow", (.buf.validate.predefined) = {
  if (_internal_has_lt_now()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_lt_now(), target);
  }

  // bool gt_now = 8[json_name = "gtNow", (.buf.validate.predefined) = {
  if (_internal_has_gt_now()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_gt_now(), target);
  }

  // optional .google.protobuf.Duration within = 9[json_name = "within", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::within(this), target, stream);
  }

  // repeated .google.protobuf.Timestamp example = 10[json_name = "example", (.buf.validate.predefined) = {
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_example_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_example(i), target, stream);
  }

  // Extension range [1000, 536870912)
  target = _extensions_._InternalSerialize(
      1000, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.TimestampRules)
  return target;
}

size_t TimestampRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.TimestampRules)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Timestamp example = 10[json_name = "example", (.buf.validate.predefined) = {
  total_size += 1UL * this->_internal_example_size();
  for (const auto& msg : this->example_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .google.protobuf.Timestamp const = 2[json_name = "const", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *const__);
    }

    // optional .google.protobuf.Duration within = 9[json_name = "within", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *within_);
    }

  }
  switch (less_than_case()) {
    // .google.protobuf.Timestamp lt = 3[json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *less_than_.lt_);
      break;
    }
    // .google.protobuf.Timestamp lte = 4[json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *less_than_.lte_);
      break;
    }
    // bool lt_now = 7[json_name = "ltNow", (.buf.validate.predefined) = {
    case kLtNow: {
      total_size += 1 + 1;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // .google.protobuf.Timestamp gt = 5[json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *greater_than_.gt_);
      break;
    }
    // .google.protobuf.Timestamp gte = 6[json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *greater_than_.gte_);
      break;
    }
    // bool gt_now = 8[json_name = "gtNow", (.buf.validate.predefined) = {
    case kGtNow: {
      total_size += 1 + 1;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TimestampRules::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.TimestampRules)
  GOOGLE_DCHECK_NE(&from, this);
  const TimestampRules* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TimestampRules>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.TimestampRules)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.TimestampRules)
    MergeFrom(*source);
  }
}

void TimestampRules::MergeFrom(const TimestampRules& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.TimestampRules)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  example_.MergeFrom(from.example_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_const_()->PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_within()->PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_within());
    }
  }
  switch (from.less_than_case()) {
    case kLt: {
      _internal_mutable_lt()->PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(from._internal_lt());
      break;
    }
    case kLte: {
      _internal_mutable_lte()->PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(from._internal_lte());
      break;
    }
    case kLtNow: {
      _internal_set_lt_now(from._internal_lt_now());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _internal_mutable_gt()->PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(from._internal_gt());
      break;
    }
    case kGte: {
      _internal_mutable_gte()->PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(from._internal_gte());
      break;
    }
    case kGtNow: {
      _internal_set_gt_now(from._internal_gt_now());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
}

void TimestampRules::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.TimestampRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TimestampRules::CopyFrom(const TimestampRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.TimestampRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimestampRules::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void TimestampRules::InternalSwap(TimestampRules* other) {
  using std::swap;
  _extensions_.Swap(&other->_extensions_);
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  example_.InternalSwap(&other->example_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimestampRules, within_)
      + sizeof(TimestampRules::within_)
      - PROTOBUF_FIELD_OFFSET(TimestampRules, const__)>(
          reinterpret_cast<char*>(&const__),
          reinterpret_cast<char*>(&other->const__));
  swap(less_than_, other->less_than_);
  swap(greater_than_, other->greater_than_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata TimestampRules::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Violations::InitAsDefaultInstance() {
}
class Violations::_Internal {
 public:
};

Violations::Violations(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  violations_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Violations)
}
Violations::Violations(const Violations& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      violations_(from.violations_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:buf.validate.Violations)
}

void Violations::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Violations_buf_2fvalidate_2fvalidate_2eproto.base);
}

Violations::~Violations() {
  // @@protoc_insertion_point(destructor:buf.validate.Violations)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Violations::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Violations::ArenaDtor(void* object) {
  Violations* _this = reinterpret_cast< Violations* >(object);
  (void)_this;
}
void Violations::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Violations::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Violations& Violations::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Violations_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void Violations::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Violations)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  violations_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Violations::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .buf.validate.Violation violations = 1[json_name = "violations"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_violations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Violations::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Violations)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .buf.validate.Violation violations = 1[json_name = "violations"];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_violations_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_violations(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Violations)
  return target;
}

size_t Violations::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Violations)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .buf.validate.Violation violations = 1[json_name = "violations"];
  total_size += 1UL * this->_internal_violations_size();
  for (const auto& msg : this->violations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Violations::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.Violations)
  GOOGLE_DCHECK_NE(&from, this);
  const Violations* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Violations>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.Violations)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.Violations)
    MergeFrom(*source);
  }
}

void Violations::MergeFrom(const Violations& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Violations)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  violations_.MergeFrom(from.violations_);
}

void Violations::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.Violations)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Violations::CopyFrom(const Violations& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Violations)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Violations::IsInitialized() const {
  return true;
}

void Violations::InternalSwap(Violations* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  violations_.InternalSwap(&other->violations_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Violations::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Violation::InitAsDefaultInstance() {
  ::buf::validate::_Violation_default_instance_._instance.get_mutable()->field_ = const_cast< ::buf::validate::FieldPath*>(
      ::buf::validate::FieldPath::internal_default_instance());
  ::buf::validate::_Violation_default_instance_._instance.get_mutable()->rule_ = const_cast< ::buf::validate::FieldPath*>(
      ::buf::validate::FieldPath::internal_default_instance());
}
class Violation::_Internal {
 public:
  using HasBits = decltype(std::declval<Violation>()._has_bits_);
  static const ::buf::validate::FieldPath& field(const Violation* msg);
  static void set_has_field(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::buf::validate::FieldPath& rule(const Violation* msg);
  static void set_has_rule(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rule_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_for_key(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::buf::validate::FieldPath&
Violation::_Internal::field(const Violation* msg) {
  return *msg->field_;
}
const ::buf::validate::FieldPath&
Violation::_Internal::rule(const Violation* msg) {
  return *msg->rule_;
}
Violation::Violation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Violation)
}
Violation::Violation(const Violation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  rule_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_rule_id()) {
    rule_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_rule_id(),
      GetArena());
  }
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_message(),
      GetArena());
  }
  if (from._internal_has_field()) {
    field_ = new ::buf::validate::FieldPath(*from.field_);
  } else {
    field_ = nullptr;
  }
  if (from._internal_has_rule()) {
    rule_ = new ::buf::validate::FieldPath(*from.rule_);
  } else {
    rule_ = nullptr;
  }
  for_key_ = from.for_key_;
  // @@protoc_insertion_point(copy_constructor:buf.validate.Violation)
}

void Violation::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Violation_buf_2fvalidate_2fvalidate_2eproto.base);
  rule_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&field_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&for_key_) -
      reinterpret_cast<char*>(&field_)) + sizeof(for_key_));
}

Violation::~Violation() {
  // @@protoc_insertion_point(destructor:buf.validate.Violation)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Violation::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  rule_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete field_;
  if (this != internal_default_instance()) delete rule_;
}

void Violation::ArenaDtor(void* object) {
  Violation* _this = reinterpret_cast< Violation* >(object);
  (void)_this;
}
void Violation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Violation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Violation& Violation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Violation_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void Violation::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Violation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      rule_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(field_ != nullptr);
      field_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(rule_ != nullptr);
      rule_->Clear();
    }
  }
  for_key_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Violation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string rule_id = 2[json_name = "ruleId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_rule_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.Violation.rule_id");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string message = 3[json_name = "message"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.Violation.message");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool for_key = 4[json_name = "forKey"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_for_key(&has_bits);
          for_key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .buf.validate.FieldPath field = 5[json_name = "field"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_field(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .buf.validate.FieldPath rule = 6[json_name = "rule"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_rule(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Violation::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Violation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string rule_id = 2[json_name = "ruleId"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_rule_id().data(), static_cast<int>(this->_internal_rule_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.Violation.rule_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_rule_id(), target);
  }

  // optional string message = 3[json_name = "message"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.Violation.message");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_message(), target);
  }

  // optional bool for_key = 4[json_name = "forKey"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_for_key(), target);
  }

  // optional .buf.validate.FieldPath field = 5[json_name = "field"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::field(this), target, stream);
  }

  // optional .buf.validate.FieldPath rule = 6[json_name = "rule"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::rule(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Violation)
  return target;
}

size_t Violation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Violation)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string rule_id = 2[json_name = "ruleId"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_rule_id());
    }

    // optional string message = 3[json_name = "message"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional .buf.validate.FieldPath field = 5[json_name = "field"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *field_);
    }

    // optional .buf.validate.FieldPath rule = 6[json_name = "rule"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rule_);
    }

    // optional bool for_key = 4[json_name = "forKey"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Violation::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.Violation)
  GOOGLE_DCHECK_NE(&from, this);
  const Violation* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Violation>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.Violation)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.Violation)
    MergeFrom(*source);
  }
}

void Violation::MergeFrom(const Violation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Violation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_rule_id(from._internal_rule_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_field()->::buf::validate::FieldPath::MergeFrom(from._internal_field());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_rule()->::buf::validate::FieldPath::MergeFrom(from._internal_rule());
    }
    if (cached_has_bits & 0x00000010u) {
      for_key_ = from.for_key_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Violation::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.Violation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Violation::CopyFrom(const Violation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Violation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Violation::IsInitialized() const {
  return true;
}

void Violation::InternalSwap(Violation* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  rule_id_.Swap(&other->rule_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  message_.Swap(&other->message_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Violation, for_key_)
      + sizeof(Violation::for_key_)
      - PROTOBUF_FIELD_OFFSET(Violation, field_)>(
          reinterpret_cast<char*>(&field_),
          reinterpret_cast<char*>(&other->field_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Violation::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void FieldPath::InitAsDefaultInstance() {
}
class FieldPath::_Internal {
 public:
};

FieldPath::FieldPath(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  elements_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.FieldPath)
}
FieldPath::FieldPath(const FieldPath& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      elements_(from.elements_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:buf.validate.FieldPath)
}

void FieldPath::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FieldPath_buf_2fvalidate_2fvalidate_2eproto.base);
}

FieldPath::~FieldPath() {
  // @@protoc_insertion_point(destructor:buf.validate.FieldPath)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void FieldPath::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void FieldPath::ArenaDtor(void* object) {
  FieldPath* _this = reinterpret_cast< FieldPath* >(object);
  (void)_this;
}
void FieldPath::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FieldPath::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FieldPath& FieldPath::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FieldPath_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void FieldPath::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.FieldPath)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  elements_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FieldPath::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .buf.validate.FieldPathElement elements = 1[json_name = "elements"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_elements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FieldPath::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.FieldPath)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .buf.validate.FieldPathElement elements = 1[json_name = "elements"];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_elements_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_elements(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.FieldPath)
  return target;
}

size_t FieldPath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.FieldPath)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .buf.validate.FieldPathElement elements = 1[json_name = "elements"];
  total_size += 1UL * this->_internal_elements_size();
  for (const auto& msg : this->elements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FieldPath::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.FieldPath)
  GOOGLE_DCHECK_NE(&from, this);
  const FieldPath* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FieldPath>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.FieldPath)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.FieldPath)
    MergeFrom(*source);
  }
}

void FieldPath::MergeFrom(const FieldPath& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.FieldPath)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  elements_.MergeFrom(from.elements_);
}

void FieldPath::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.FieldPath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FieldPath::CopyFrom(const FieldPath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.FieldPath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FieldPath::IsInitialized() const {
  return true;
}

void FieldPath::InternalSwap(FieldPath* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  elements_.InternalSwap(&other->elements_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FieldPath::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void FieldPathElement::InitAsDefaultInstance() {
  ::buf::validate::_FieldPathElement_default_instance_.index_ = PROTOBUF_ULONGLONG(0);
  ::buf::validate::_FieldPathElement_default_instance_.bool_key_ = false;
  ::buf::validate::_FieldPathElement_default_instance_.int_key_ = PROTOBUF_LONGLONG(0);
  ::buf::validate::_FieldPathElement_default_instance_.uint_key_ = PROTOBUF_ULONGLONG(0);
  ::buf::validate::_FieldPathElement_default_instance_.string_key_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
class FieldPathElement::_Internal {
 public:
  using HasBits = decltype(std::declval<FieldPathElement>()._has_bits_);
  static void set_has_field_number(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_field_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_field_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_key_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_value_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

FieldPathElement::FieldPathElement(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.FieldPathElement)
}
FieldPathElement::FieldPathElement(const FieldPathElement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  field_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_field_name()) {
    field_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_field_name(),
      GetArena());
  }
  ::memcpy(&field_number_, &from.field_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&key_type_) -
    reinterpret_cast<char*>(&field_number_)) + sizeof(key_type_));
  clear_has_subscript();
  switch (from.subscript_case()) {
    case kIndex: {
      _internal_set_index(from._internal_index());
      break;
    }
    case kBoolKey: {
      _internal_set_bool_key(from._internal_bool_key());
      break;
    }
    case kIntKey: {
      _internal_set_int_key(from._internal_int_key());
      break;
    }
    case kUintKey: {
      _internal_set_uint_key(from._internal_uint_key());
      break;
    }
    case kStringKey: {
      _internal_set_string_key(from._internal_string_key());
      break;
    }
    case SUBSCRIPT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:buf.validate.FieldPathElement)
}

void FieldPathElement::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FieldPathElement_buf_2fvalidate_2fvalidate_2eproto.base);
  field_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  field_number_ = 0;
  value_type_ = 1;
  field_type_ = 1;
  key_type_ = 1;
  clear_has_subscript();
}

FieldPathElement::~FieldPathElement() {
  // @@protoc_insertion_point(destructor:buf.validate.FieldPathElement)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void FieldPathElement::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  field_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (has_subscript()) {
    clear_subscript();
  }
}

void FieldPathElement::ArenaDtor(void* object) {
  FieldPathElement* _this = reinterpret_cast< FieldPathElement* >(object);
  (void)_this;
}
void FieldPathElement::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FieldPathElement::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FieldPathElement& FieldPathElement::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FieldPathElement_buf_2fvalidate_2fvalidate_2eproto.base);
  return *internal_default_instance();
}


void FieldPathElement::clear_subscript() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.FieldPathElement)
  switch (subscript_case()) {
    case kIndex: {
      // No need to clear
      break;
    }
    case kBoolKey: {
      // No need to clear
      break;
    }
    case kIntKey: {
      // No need to clear
      break;
    }
    case kUintKey: {
      // No need to clear
      break;
    }
    case kStringKey: {
      subscript_.string_key_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
      break;
    }
    case SUBSCRIPT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SUBSCRIPT_NOT_SET;
}


void FieldPathElement::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.FieldPathElement)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    field_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    field_number_ = 0;
    value_type_ = 1;
    field_type_ = 1;
    key_type_ = 1;
  }
  clear_subscript();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FieldPathElement::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 field_number = 1[json_name = "fieldNumber"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_field_number(&has_bits);
          field_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string field_name = 2[json_name = "fieldName"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_field_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.FieldPathElement.field_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .google.protobuf.FieldDescriptorProto.Type field_type = 3[json_name = "fieldType"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(PROTOBUF_NAMESPACE_ID::FieldDescriptorProto_Type_IsValid(val))) {
            _internal_set_field_type(static_cast<PROTOBUF_NAMESPACE_ID::FieldDescriptorProto_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .google.protobuf.FieldDescriptorProto.Type key_type = 4[json_name = "keyType"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(PROTOBUF_NAMESPACE_ID::FieldDescriptorProto_Type_IsValid(val))) {
            _internal_set_key_type(static_cast<PROTOBUF_NAMESPACE_ID::FieldDescriptorProto_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .google.protobuf.FieldDescriptorProto.Type value_type = 5[json_name = "valueType"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(PROTOBUF_NAMESPACE_ID::FieldDescriptorProto_Type_IsValid(val))) {
            _internal_set_value_type(static_cast<PROTOBUF_NAMESPACE_ID::FieldDescriptorProto_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // uint64 index = 6[json_name = "index"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _internal_set_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool bool_key = 7[json_name = "boolKey"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _internal_set_bool_key(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int64 int_key = 8[json_name = "intKey"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _internal_set_int_key(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 uint_key = 9[json_name = "uintKey"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _internal_set_uint_key(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string string_key = 10[json_name = "stringKey"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          auto str = _internal_mutable_string_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "buf.validate.FieldPathElement.string_key");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FieldPathElement::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.FieldPathElement)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 field_number = 1[json_name = "fieldNumber"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_field_number(), target);
  }

  // optional string field_name = 2[json_name = "fieldName"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_field_name().data(), static_cast<int>(this->_internal_field_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "buf.validate.FieldPathElement.field_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_field_name(), target);
  }

  // optional .google.protobuf.FieldDescriptorProto.Type field_type = 3[json_name = "fieldType"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_field_type(), target);
  }

  // optional .google.protobuf.FieldDescriptorProto.Type key_type = 4[json_name = "keyType"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_key_type(), target);
  }

  // optional .google.protobuf.FieldDescriptorProto.Type value_type = 5[json_name = "valueType"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_value_type(), target);
  }

  switch (subscript_case()) {
    case kIndex: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_index(), target);
      break;
    }
    case kBoolKey: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_bool_key(), target);
      break;
    }
    case kIntKey: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(8, this->_internal_int_key(), target);
      break;
    }
    case kUintKey: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(9, this->_internal_uint_key(), target);
      break;
    }
    case kStringKey: {
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_string_key().data(), static_cast<int>(this->_internal_string_key().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "buf.validate.FieldPathElement.string_key");
      target = stream->WriteStringMaybeAliased(
          10, this->_internal_string_key(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.FieldPathElement)
  return target;
}

size_t FieldPathElement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.FieldPathElement)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string field_name = 2[json_name = "fieldName"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_field_name());
    }

    // optional int32 field_number = 1[json_name = "fieldNumber"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_field_number());
    }

    // optional .google.protobuf.FieldDescriptorProto.Type value_type = 5[json_name = "valueType"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_value_type());
    }

    // optional .google.protobuf.FieldDescriptorProto.Type field_type = 3[json_name = "fieldType"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_field_type());
    }

    // optional .google.protobuf.FieldDescriptorProto.Type key_type = 4[json_name = "keyType"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_key_type());
    }

  }
  switch (subscript_case()) {
    // uint64 index = 6[json_name = "index"];
    case kIndex: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_index());
      break;
    }
    // bool bool_key = 7[json_name = "boolKey"];
    case kBoolKey: {
      total_size += 1 + 1;
      break;
    }
    // int64 int_key = 8[json_name = "intKey"];
    case kIntKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_int_key());
      break;
    }
    // uint64 uint_key = 9[json_name = "uintKey"];
    case kUintKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_uint_key());
      break;
    }
    // string string_key = 10[json_name = "stringKey"];
    case kStringKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_string_key());
      break;
    }
    case SUBSCRIPT_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FieldPathElement::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:buf.validate.FieldPathElement)
  GOOGLE_DCHECK_NE(&from, this);
  const FieldPathElement* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FieldPathElement>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:buf.validate.FieldPathElement)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:buf.validate.FieldPathElement)
    MergeFrom(*source);
  }
}

void FieldPathElement::MergeFrom(const FieldPathElement& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.FieldPathElement)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_field_name(from._internal_field_name());
    }
    if (cached_has_bits & 0x00000002u) {
      field_number_ = from.field_number_;
    }
    if (cached_has_bits & 0x00000004u) {
      value_type_ = from.value_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      field_type_ = from.field_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      key_type_ = from.key_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.subscript_case()) {
    case kIndex: {
      _internal_set_index(from._internal_index());
      break;
    }
    case kBoolKey: {
      _internal_set_bool_key(from._internal_bool_key());
      break;
    }
    case kIntKey: {
      _internal_set_int_key(from._internal_int_key());
      break;
    }
    case kUintKey: {
      _internal_set_uint_key(from._internal_uint_key());
      break;
    }
    case kStringKey: {
      _internal_set_string_key(from._internal_string_key());
      break;
    }
    case SUBSCRIPT_NOT_SET: {
      break;
    }
  }
}

void FieldPathElement::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:buf.validate.FieldPathElement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FieldPathElement::CopyFrom(const FieldPathElement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.FieldPathElement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FieldPathElement::IsInitialized() const {
  return true;
}

void FieldPathElement::InternalSwap(FieldPathElement* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  field_name_.Swap(&other->field_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(field_number_, other->field_number_);
  swap(value_type_, other->value_type_);
  swap(field_type_, other->field_type_);
  swap(key_type_, other->key_type_);
  swap(subscript_, other->subscript_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata FieldPathElement::GetMetadata() const {
  return GetMetadataStatic();
}

::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::buf::validate::MessageRules >, 11, false >
  message(kMessageFieldNumber, ::buf::validate::MessageRules::default_instance());
::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::OneofOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::buf::validate::OneofRules >, 11, false >
  oneof(kOneofFieldNumber, ::buf::validate::OneofRules::default_instance());
::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::buf::validate::FieldRules >, 11, false >
  field(kFieldFieldNumber, ::buf::validate::FieldRules::default_instance());
::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::buf::validate::PredefinedRules >, 11, false >
  predefined(kPredefinedFieldNumber, ::buf::validate::PredefinedRules::default_instance());

// @@protoc_insertion_point(namespace_scope)
}  // namespace validate
}  // namespace buf
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::buf::validate::Rule* Arena::CreateMaybeMessage< ::buf::validate::Rule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::Rule >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::MessageRules* Arena::CreateMaybeMessage< ::buf::validate::MessageRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::MessageRules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::MessageOneofRule* Arena::CreateMaybeMessage< ::buf::validate::MessageOneofRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::MessageOneofRule >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::OneofRules* Arena::CreateMaybeMessage< ::buf::validate::OneofRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::OneofRules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::FieldRules* Arena::CreateMaybeMessage< ::buf::validate::FieldRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::FieldRules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::PredefinedRules* Arena::CreateMaybeMessage< ::buf::validate::PredefinedRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::PredefinedRules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::FloatRules* Arena::CreateMaybeMessage< ::buf::validate::FloatRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::FloatRules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::DoubleRules* Arena::CreateMaybeMessage< ::buf::validate::DoubleRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::DoubleRules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::Int32Rules* Arena::CreateMaybeMessage< ::buf::validate::Int32Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::Int32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::Int64Rules* Arena::CreateMaybeMessage< ::buf::validate::Int64Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::Int64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::UInt32Rules* Arena::CreateMaybeMessage< ::buf::validate::UInt32Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::UInt32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::UInt64Rules* Arena::CreateMaybeMessage< ::buf::validate::UInt64Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::UInt64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::SInt32Rules* Arena::CreateMaybeMessage< ::buf::validate::SInt32Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::SInt32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::SInt64Rules* Arena::CreateMaybeMessage< ::buf::validate::SInt64Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::SInt64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::Fixed32Rules* Arena::CreateMaybeMessage< ::buf::validate::Fixed32Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::Fixed32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::Fixed64Rules* Arena::CreateMaybeMessage< ::buf::validate::Fixed64Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::Fixed64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::SFixed32Rules* Arena::CreateMaybeMessage< ::buf::validate::SFixed32Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::SFixed32Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::SFixed64Rules* Arena::CreateMaybeMessage< ::buf::validate::SFixed64Rules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::SFixed64Rules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::BoolRules* Arena::CreateMaybeMessage< ::buf::validate::BoolRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::BoolRules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::StringRules* Arena::CreateMaybeMessage< ::buf::validate::StringRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::StringRules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::BytesRules* Arena::CreateMaybeMessage< ::buf::validate::BytesRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::BytesRules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::EnumRules* Arena::CreateMaybeMessage< ::buf::validate::EnumRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::EnumRules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::RepeatedRules* Arena::CreateMaybeMessage< ::buf::validate::RepeatedRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::RepeatedRules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::MapRules* Arena::CreateMaybeMessage< ::buf::validate::MapRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::MapRules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::AnyRules* Arena::CreateMaybeMessage< ::buf::validate::AnyRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::AnyRules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::DurationRules* Arena::CreateMaybeMessage< ::buf::validate::DurationRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::DurationRules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::TimestampRules* Arena::CreateMaybeMessage< ::buf::validate::TimestampRules >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::TimestampRules >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::Violations* Arena::CreateMaybeMessage< ::buf::validate::Violations >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::Violations >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::Violation* Arena::CreateMaybeMessage< ::buf::validate::Violation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::Violation >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::FieldPath* Arena::CreateMaybeMessage< ::buf::validate::FieldPath >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::FieldPath >(arena);
}
template<> PROTOBUF_NOINLINE ::buf::validate::FieldPathElement* Arena::CreateMaybeMessage< ::buf::validate::FieldPathElement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::buf::validate::FieldPathElement >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

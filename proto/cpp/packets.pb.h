// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: packets.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_packets_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_packets_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "buf/validate/validate.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_packets_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_packets_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_packets_2eproto;
class ErrorPacket;
class ErrorPacketDefaultTypeInternal;
extern ErrorPacketDefaultTypeInternal _ErrorPacket_default_instance_;
class LoginPacket;
class LoginPacketDefaultTypeInternal;
extern LoginPacketDefaultTypeInternal _LoginPacket_default_instance_;
class MessagePacket;
class MessagePacketDefaultTypeInternal;
extern MessagePacketDefaultTypeInternal _MessagePacket_default_instance_;
class UniversalPacket;
class UniversalPacketDefaultTypeInternal;
extern UniversalPacketDefaultTypeInternal _UniversalPacket_default_instance_;
class VersionPacket;
class VersionPacketDefaultTypeInternal;
extern VersionPacketDefaultTypeInternal _VersionPacket_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ErrorPacket* Arena::CreateMaybeMessage<::ErrorPacket>(Arena*);
template<> ::LoginPacket* Arena::CreateMaybeMessage<::LoginPacket>(Arena*);
template<> ::MessagePacket* Arena::CreateMaybeMessage<::MessagePacket>(Arena*);
template<> ::UniversalPacket* Arena::CreateMaybeMessage<::UniversalPacket>(Arena*);
template<> ::VersionPacket* Arena::CreateMaybeMessage<::VersionPacket>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class VersionPacket PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VersionPacket) */ {
 public:
  inline VersionPacket() : VersionPacket(nullptr) {};
  virtual ~VersionPacket();

  VersionPacket(const VersionPacket& from);
  VersionPacket(VersionPacket&& from) noexcept
    : VersionPacket() {
    *this = ::std::move(from);
  }

  inline VersionPacket& operator=(const VersionPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionPacket& operator=(VersionPacket&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VersionPacket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VersionPacket* internal_default_instance() {
    return reinterpret_cast<const VersionPacket*>(
               &_VersionPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VersionPacket& a, VersionPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionPacket* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VersionPacket* New() const final {
    return CreateMaybeMessage<VersionPacket>(nullptr);
  }

  VersionPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VersionPacket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VersionPacket& from);
  void MergeFrom(const VersionPacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionPacket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VersionPacket";
  }
  protected:
  explicit VersionPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMajorVerFieldNumber = 1,
    kMinorVerFieldNumber = 2,
    kPatchVerFieldNumber = 3,
    kProtocolExtensionFieldNumber = 4,
  };
  // uint32 major_ver = 1[json_name = "majorVer", (.buf.validate.field) = {
  void clear_major_ver();
  ::PROTOBUF_NAMESPACE_ID::uint32 major_ver() const;
  void set_major_ver(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_major_ver() const;
  void _internal_set_major_ver(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 minor_ver = 2[json_name = "minorVer", (.buf.validate.field) = {
  void clear_minor_ver();
  ::PROTOBUF_NAMESPACE_ID::uint32 minor_ver() const;
  void set_minor_ver(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_minor_ver() const;
  void _internal_set_minor_ver(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 patch_ver = 3[json_name = "patchVer", (.buf.validate.field) = {
  void clear_patch_ver();
  ::PROTOBUF_NAMESPACE_ID::uint32 patch_ver() const;
  void set_patch_ver(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_patch_ver() const;
  void _internal_set_patch_ver(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 protocol_extension = 4[json_name = "protocolExtension", (.buf.validate.field) = {
  void clear_protocol_extension();
  ::PROTOBUF_NAMESPACE_ID::uint32 protocol_extension() const;
  void set_protocol_extension(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_protocol_extension() const;
  void _internal_set_protocol_extension(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:VersionPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 major_ver_;
  ::PROTOBUF_NAMESPACE_ID::uint32 minor_ver_;
  ::PROTOBUF_NAMESPACE_ID::uint32 patch_ver_;
  ::PROTOBUF_NAMESPACE_ID::uint32 protocol_extension_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class LoginPacket PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LoginPacket) */ {
 public:
  inline LoginPacket() : LoginPacket(nullptr) {};
  virtual ~LoginPacket();

  LoginPacket(const LoginPacket& from);
  LoginPacket(LoginPacket&& from) noexcept
    : LoginPacket() {
    *this = ::std::move(from);
  }

  inline LoginPacket& operator=(const LoginPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginPacket& operator=(LoginPacket&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginPacket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginPacket* internal_default_instance() {
    return reinterpret_cast<const LoginPacket*>(
               &_LoginPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginPacket& a, LoginPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginPacket* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginPacket* New() const final {
    return CreateMaybeMessage<LoginPacket>(nullptr);
  }

  LoginPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginPacket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginPacket& from);
  void MergeFrom(const LoginPacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginPacket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LoginPacket";
  }
  protected:
  explicit LoginPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdentifierFieldNumber = 1,
    kUserPasswordFieldNumber = 2,
  };
  // string user_identifier = 1[json_name = "userIdentifier", (.buf.validate.field) = {
  void clear_user_identifier();
  const std::string& user_identifier() const;
  void set_user_identifier(const std::string& value);
  void set_user_identifier(std::string&& value);
  void set_user_identifier(const char* value);
  void set_user_identifier(const char* value, size_t size);
  std::string* mutable_user_identifier();
  std::string* release_user_identifier();
  void set_allocated_user_identifier(std::string* user_identifier);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_user_identifier();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_user_identifier(
      std::string* user_identifier);
  private:
  const std::string& _internal_user_identifier() const;
  void _internal_set_user_identifier(const std::string& value);
  std::string* _internal_mutable_user_identifier();
  public:

  // string user_password = 2[json_name = "userPassword", (.buf.validate.field) = {
  void clear_user_password();
  const std::string& user_password() const;
  void set_user_password(const std::string& value);
  void set_user_password(std::string&& value);
  void set_user_password(const char* value);
  void set_user_password(const char* value, size_t size);
  std::string* mutable_user_password();
  std::string* release_user_password();
  void set_allocated_user_password(std::string* user_password);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_user_password();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_user_password(
      std::string* user_password);
  private:
  const std::string& _internal_user_password() const;
  void _internal_set_user_password(const std::string& value);
  std::string* _internal_mutable_user_password();
  public:

  // @@protoc_insertion_point(class_scope:LoginPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class MessagePacket PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MessagePacket) */ {
 public:
  inline MessagePacket() : MessagePacket(nullptr) {};
  virtual ~MessagePacket();

  MessagePacket(const MessagePacket& from);
  MessagePacket(MessagePacket&& from) noexcept
    : MessagePacket() {
    *this = ::std::move(from);
  }

  inline MessagePacket& operator=(const MessagePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessagePacket& operator=(MessagePacket&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessagePacket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessagePacket* internal_default_instance() {
    return reinterpret_cast<const MessagePacket*>(
               &_MessagePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MessagePacket& a, MessagePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(MessagePacket* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessagePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessagePacket* New() const final {
    return CreateMaybeMessage<MessagePacket>(nullptr);
  }

  MessagePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessagePacket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessagePacket& from);
  void MergeFrom(const MessagePacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessagePacket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MessagePacket";
  }
  protected:
  explicit MessagePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiersFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kMessageFieldNumber = 3,
  };
  // repeated string identifiers = 1[json_name = "identifiers", (.buf.validate.field) = {
  int identifiers_size() const;
  private:
  int _internal_identifiers_size() const;
  public:
  void clear_identifiers();
  const std::string& identifiers(int index) const;
  std::string* mutable_identifiers(int index);
  void set_identifiers(int index, const std::string& value);
  void set_identifiers(int index, std::string&& value);
  void set_identifiers(int index, const char* value);
  void set_identifiers(int index, const char* value, size_t size);
  std::string* add_identifiers();
  void add_identifiers(const std::string& value);
  void add_identifiers(std::string&& value);
  void add_identifiers(const char* value);
  void add_identifiers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& identifiers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_identifiers();
  private:
  const std::string& _internal_identifiers(int index) const;
  std::string* _internal_add_identifiers();
  public:

  // string channel_id = 2[json_name = "channelId", (.buf.validate.field) = {
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  const std::string& channel_id() const;
  void set_channel_id(const std::string& value);
  void set_channel_id(std::string&& value);
  void set_channel_id(const char* value);
  void set_channel_id(const char* value, size_t size);
  std::string* mutable_channel_id();
  std::string* release_channel_id();
  void set_allocated_channel_id(std::string* channel_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_channel_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_channel_id(
      std::string* channel_id);
  private:
  const std::string& _internal_channel_id() const;
  void _internal_set_channel_id(const std::string& value);
  std::string* _internal_mutable_channel_id();
  public:

  // string message = 3[json_name = "message", (.buf.validate.field) = {
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:MessagePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> identifiers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class ErrorPacket PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ErrorPacket) */ {
 public:
  inline ErrorPacket() : ErrorPacket(nullptr) {};
  virtual ~ErrorPacket();

  ErrorPacket(const ErrorPacket& from);
  ErrorPacket(ErrorPacket&& from) noexcept
    : ErrorPacket() {
    *this = ::std::move(from);
  }

  inline ErrorPacket& operator=(const ErrorPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorPacket& operator=(ErrorPacket&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ErrorPacket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorPacket* internal_default_instance() {
    return reinterpret_cast<const ErrorPacket*>(
               &_ErrorPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ErrorPacket& a, ErrorPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorPacket* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErrorPacket* New() const final {
    return CreateMaybeMessage<ErrorPacket>(nullptr);
  }

  ErrorPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErrorPacket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ErrorPacket& from);
  void MergeFrom(const ErrorPacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorPacket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ErrorPacket";
  }
  protected:
  explicit ErrorPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdentifierFieldNumber = 1,
    kErrorFieldNumber = 3,
  };
  // string user_identifier = 1[json_name = "userIdentifier", (.buf.validate.field) = {
  void clear_user_identifier();
  const std::string& user_identifier() const;
  void set_user_identifier(const std::string& value);
  void set_user_identifier(std::string&& value);
  void set_user_identifier(const char* value);
  void set_user_identifier(const char* value, size_t size);
  std::string* mutable_user_identifier();
  std::string* release_user_identifier();
  void set_allocated_user_identifier(std::string* user_identifier);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_user_identifier();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_user_identifier(
      std::string* user_identifier);
  private:
  const std::string& _internal_user_identifier() const;
  void _internal_set_user_identifier(const std::string& value);
  std::string* _internal_mutable_user_identifier();
  public:

  // string error = 3[json_name = "error", (.buf.validate.field) = {
  void clear_error();
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_error();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_error(
      std::string* error);
  private:
  const std::string& _internal_error() const;
  void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:ErrorPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class UniversalPacket PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UniversalPacket) */ {
 public:
  inline UniversalPacket() : UniversalPacket(nullptr) {};
  virtual ~UniversalPacket();

  UniversalPacket(const UniversalPacket& from);
  UniversalPacket(UniversalPacket&& from) noexcept
    : UniversalPacket() {
    *this = ::std::move(from);
  }

  inline UniversalPacket& operator=(const UniversalPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline UniversalPacket& operator=(UniversalPacket&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UniversalPacket& default_instance();

  enum PayloadCase {
    kVersion = 1,
    kError = 2,
    kLogin = 3,
    kMessage = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UniversalPacket* internal_default_instance() {
    return reinterpret_cast<const UniversalPacket*>(
               &_UniversalPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UniversalPacket& a, UniversalPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(UniversalPacket* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UniversalPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UniversalPacket* New() const final {
    return CreateMaybeMessage<UniversalPacket>(nullptr);
  }

  UniversalPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UniversalPacket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UniversalPacket& from);
  void MergeFrom(const UniversalPacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UniversalPacket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UniversalPacket";
  }
  protected:
  explicit UniversalPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kErrorFieldNumber = 2,
    kLoginFieldNumber = 3,
    kMessageFieldNumber = 4,
  };
  // .VersionPacket version = 1[json_name = "version"];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::VersionPacket& version() const;
  ::VersionPacket* release_version();
  ::VersionPacket* mutable_version();
  void set_allocated_version(::VersionPacket* version);
  private:
  const ::VersionPacket& _internal_version() const;
  ::VersionPacket* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::VersionPacket* version);
  ::VersionPacket* unsafe_arena_release_version();

  // .ErrorPacket error = 2[json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::ErrorPacket& error() const;
  ::ErrorPacket* release_error();
  ::ErrorPacket* mutable_error();
  void set_allocated_error(::ErrorPacket* error);
  private:
  const ::ErrorPacket& _internal_error() const;
  ::ErrorPacket* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::ErrorPacket* error);
  ::ErrorPacket* unsafe_arena_release_error();

  // .LoginPacket login = 3[json_name = "login"];
  bool has_login() const;
  private:
  bool _internal_has_login() const;
  public:
  void clear_login();
  const ::LoginPacket& login() const;
  ::LoginPacket* release_login();
  ::LoginPacket* mutable_login();
  void set_allocated_login(::LoginPacket* login);
  private:
  const ::LoginPacket& _internal_login() const;
  ::LoginPacket* _internal_mutable_login();
  public:
  void unsafe_arena_set_allocated_login(
      ::LoginPacket* login);
  ::LoginPacket* unsafe_arena_release_login();

  // .MessagePacket message = 4[json_name = "message"];
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::MessagePacket& message() const;
  ::MessagePacket* release_message();
  ::MessagePacket* mutable_message();
  void set_allocated_message(::MessagePacket* message);
  private:
  const ::MessagePacket& _internal_message() const;
  ::MessagePacket* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::MessagePacket* message);
  ::MessagePacket* unsafe_arena_release_message();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:UniversalPacket)
 private:
  class _Internal;
  void set_has_version();
  void set_has_error();
  void set_has_login();
  void set_has_message();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PayloadUnion {
    PayloadUnion() {}
    ::VersionPacket* version_;
    ::ErrorPacket* error_;
    ::LoginPacket* login_;
    ::MessagePacket* message_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_packets_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VersionPacket

// uint32 major_ver = 1[json_name = "majorVer", (.buf.validate.field) = {
inline void VersionPacket::clear_major_ver() {
  major_ver_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionPacket::_internal_major_ver() const {
  return major_ver_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionPacket::major_ver() const {
  // @@protoc_insertion_point(field_get:VersionPacket.major_ver)
  return _internal_major_ver();
}
inline void VersionPacket::_internal_set_major_ver(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  major_ver_ = value;
}
inline void VersionPacket::set_major_ver(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_major_ver(value);
  // @@protoc_insertion_point(field_set:VersionPacket.major_ver)
}

// uint32 minor_ver = 2[json_name = "minorVer", (.buf.validate.field) = {
inline void VersionPacket::clear_minor_ver() {
  minor_ver_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionPacket::_internal_minor_ver() const {
  return minor_ver_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionPacket::minor_ver() const {
  // @@protoc_insertion_point(field_get:VersionPacket.minor_ver)
  return _internal_minor_ver();
}
inline void VersionPacket::_internal_set_minor_ver(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  minor_ver_ = value;
}
inline void VersionPacket::set_minor_ver(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_minor_ver(value);
  // @@protoc_insertion_point(field_set:VersionPacket.minor_ver)
}

// uint32 patch_ver = 3[json_name = "patchVer", (.buf.validate.field) = {
inline void VersionPacket::clear_patch_ver() {
  patch_ver_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionPacket::_internal_patch_ver() const {
  return patch_ver_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionPacket::patch_ver() const {
  // @@protoc_insertion_point(field_get:VersionPacket.patch_ver)
  return _internal_patch_ver();
}
inline void VersionPacket::_internal_set_patch_ver(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  patch_ver_ = value;
}
inline void VersionPacket::set_patch_ver(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_patch_ver(value);
  // @@protoc_insertion_point(field_set:VersionPacket.patch_ver)
}

// uint32 protocol_extension = 4[json_name = "protocolExtension", (.buf.validate.field) = {
inline void VersionPacket::clear_protocol_extension() {
  protocol_extension_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionPacket::_internal_protocol_extension() const {
  return protocol_extension_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionPacket::protocol_extension() const {
  // @@protoc_insertion_point(field_get:VersionPacket.protocol_extension)
  return _internal_protocol_extension();
}
inline void VersionPacket::_internal_set_protocol_extension(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  protocol_extension_ = value;
}
inline void VersionPacket::set_protocol_extension(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_protocol_extension(value);
  // @@protoc_insertion_point(field_set:VersionPacket.protocol_extension)
}

// -------------------------------------------------------------------

// LoginPacket

// string user_identifier = 1[json_name = "userIdentifier", (.buf.validate.field) = {
inline void LoginPacket::clear_user_identifier() {
  user_identifier_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& LoginPacket::user_identifier() const {
  // @@protoc_insertion_point(field_get:LoginPacket.user_identifier)
  return _internal_user_identifier();
}
inline void LoginPacket::set_user_identifier(const std::string& value) {
  _internal_set_user_identifier(value);
  // @@protoc_insertion_point(field_set:LoginPacket.user_identifier)
}
inline std::string* LoginPacket::mutable_user_identifier() {
  // @@protoc_insertion_point(field_mutable:LoginPacket.user_identifier)
  return _internal_mutable_user_identifier();
}
inline const std::string& LoginPacket::_internal_user_identifier() const {
  return user_identifier_.Get();
}
inline void LoginPacket::_internal_set_user_identifier(const std::string& value) {
  
  user_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LoginPacket::set_user_identifier(std::string&& value) {
  
  user_identifier_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:LoginPacket.user_identifier)
}
inline void LoginPacket::set_user_identifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:LoginPacket.user_identifier)
}
inline void LoginPacket::set_user_identifier(const char* value,
    size_t size) {
  
  user_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:LoginPacket.user_identifier)
}
inline std::string* LoginPacket::_internal_mutable_user_identifier() {
  
  return user_identifier_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LoginPacket::release_user_identifier() {
  // @@protoc_insertion_point(field_release:LoginPacket.user_identifier)
  return user_identifier_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoginPacket::set_allocated_user_identifier(std::string* user_identifier) {
  if (user_identifier != nullptr) {
    
  } else {
    
  }
  user_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_identifier,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:LoginPacket.user_identifier)
}
inline std::string* LoginPacket::unsafe_arena_release_user_identifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:LoginPacket.user_identifier)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return user_identifier_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void LoginPacket::unsafe_arena_set_allocated_user_identifier(
    std::string* user_identifier) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (user_identifier != nullptr) {
    
  } else {
    
  }
  user_identifier_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      user_identifier, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LoginPacket.user_identifier)
}

// string user_password = 2[json_name = "userPassword", (.buf.validate.field) = {
inline void LoginPacket::clear_user_password() {
  user_password_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& LoginPacket::user_password() const {
  // @@protoc_insertion_point(field_get:LoginPacket.user_password)
  return _internal_user_password();
}
inline void LoginPacket::set_user_password(const std::string& value) {
  _internal_set_user_password(value);
  // @@protoc_insertion_point(field_set:LoginPacket.user_password)
}
inline std::string* LoginPacket::mutable_user_password() {
  // @@protoc_insertion_point(field_mutable:LoginPacket.user_password)
  return _internal_mutable_user_password();
}
inline const std::string& LoginPacket::_internal_user_password() const {
  return user_password_.Get();
}
inline void LoginPacket::_internal_set_user_password(const std::string& value) {
  
  user_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LoginPacket::set_user_password(std::string&& value) {
  
  user_password_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:LoginPacket.user_password)
}
inline void LoginPacket::set_user_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:LoginPacket.user_password)
}
inline void LoginPacket::set_user_password(const char* value,
    size_t size) {
  
  user_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:LoginPacket.user_password)
}
inline std::string* LoginPacket::_internal_mutable_user_password() {
  
  return user_password_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LoginPacket::release_user_password() {
  // @@protoc_insertion_point(field_release:LoginPacket.user_password)
  return user_password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoginPacket::set_allocated_user_password(std::string* user_password) {
  if (user_password != nullptr) {
    
  } else {
    
  }
  user_password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_password,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:LoginPacket.user_password)
}
inline std::string* LoginPacket::unsafe_arena_release_user_password() {
  // @@protoc_insertion_point(field_unsafe_arena_release:LoginPacket.user_password)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return user_password_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void LoginPacket::unsafe_arena_set_allocated_user_password(
    std::string* user_password) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (user_password != nullptr) {
    
  } else {
    
  }
  user_password_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      user_password, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LoginPacket.user_password)
}

// -------------------------------------------------------------------

// MessagePacket

// repeated string identifiers = 1[json_name = "identifiers", (.buf.validate.field) = {
inline int MessagePacket::_internal_identifiers_size() const {
  return identifiers_.size();
}
inline int MessagePacket::identifiers_size() const {
  return _internal_identifiers_size();
}
inline void MessagePacket::clear_identifiers() {
  identifiers_.Clear();
}
inline std::string* MessagePacket::add_identifiers() {
  // @@protoc_insertion_point(field_add_mutable:MessagePacket.identifiers)
  return _internal_add_identifiers();
}
inline const std::string& MessagePacket::_internal_identifiers(int index) const {
  return identifiers_.Get(index);
}
inline const std::string& MessagePacket::identifiers(int index) const {
  // @@protoc_insertion_point(field_get:MessagePacket.identifiers)
  return _internal_identifiers(index);
}
inline std::string* MessagePacket::mutable_identifiers(int index) {
  // @@protoc_insertion_point(field_mutable:MessagePacket.identifiers)
  return identifiers_.Mutable(index);
}
inline void MessagePacket::set_identifiers(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:MessagePacket.identifiers)
  identifiers_.Mutable(index)->assign(value);
}
inline void MessagePacket::set_identifiers(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:MessagePacket.identifiers)
  identifiers_.Mutable(index)->assign(std::move(value));
}
inline void MessagePacket::set_identifiers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  identifiers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MessagePacket.identifiers)
}
inline void MessagePacket::set_identifiers(int index, const char* value, size_t size) {
  identifiers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MessagePacket.identifiers)
}
inline std::string* MessagePacket::_internal_add_identifiers() {
  return identifiers_.Add();
}
inline void MessagePacket::add_identifiers(const std::string& value) {
  identifiers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MessagePacket.identifiers)
}
inline void MessagePacket::add_identifiers(std::string&& value) {
  identifiers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:MessagePacket.identifiers)
}
inline void MessagePacket::add_identifiers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  identifiers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MessagePacket.identifiers)
}
inline void MessagePacket::add_identifiers(const char* value, size_t size) {
  identifiers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MessagePacket.identifiers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MessagePacket::identifiers() const {
  // @@protoc_insertion_point(field_list:MessagePacket.identifiers)
  return identifiers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MessagePacket::mutable_identifiers() {
  // @@protoc_insertion_point(field_mutable_list:MessagePacket.identifiers)
  return &identifiers_;
}

// string channel_id = 2[json_name = "channelId", (.buf.validate.field) = {
inline bool MessagePacket::_internal_has_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessagePacket::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void MessagePacket::clear_channel_id() {
  channel_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MessagePacket::channel_id() const {
  // @@protoc_insertion_point(field_get:MessagePacket.channel_id)
  return _internal_channel_id();
}
inline void MessagePacket::set_channel_id(const std::string& value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:MessagePacket.channel_id)
}
inline std::string* MessagePacket::mutable_channel_id() {
  // @@protoc_insertion_point(field_mutable:MessagePacket.channel_id)
  return _internal_mutable_channel_id();
}
inline const std::string& MessagePacket::_internal_channel_id() const {
  return channel_id_.Get();
}
inline void MessagePacket::_internal_set_channel_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  channel_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MessagePacket::set_channel_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  channel_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MessagePacket.channel_id)
}
inline void MessagePacket::set_channel_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  channel_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MessagePacket.channel_id)
}
inline void MessagePacket::set_channel_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  channel_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MessagePacket.channel_id)
}
inline std::string* MessagePacket::_internal_mutable_channel_id() {
  _has_bits_[0] |= 0x00000001u;
  return channel_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MessagePacket::release_channel_id() {
  // @@protoc_insertion_point(field_release:MessagePacket.channel_id)
  if (!_internal_has_channel_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return channel_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MessagePacket::set_allocated_channel_id(std::string* channel_id) {
  if (channel_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  channel_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MessagePacket.channel_id)
}
inline std::string* MessagePacket::unsafe_arena_release_channel_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MessagePacket.channel_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return channel_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void MessagePacket::unsafe_arena_set_allocated_channel_id(
    std::string* channel_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (channel_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  channel_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      channel_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessagePacket.channel_id)
}

// string message = 3[json_name = "message", (.buf.validate.field) = {
inline void MessagePacket::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& MessagePacket::message() const {
  // @@protoc_insertion_point(field_get:MessagePacket.message)
  return _internal_message();
}
inline void MessagePacket::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:MessagePacket.message)
}
inline std::string* MessagePacket::mutable_message() {
  // @@protoc_insertion_point(field_mutable:MessagePacket.message)
  return _internal_mutable_message();
}
inline const std::string& MessagePacket::_internal_message() const {
  return message_.Get();
}
inline void MessagePacket::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MessagePacket::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MessagePacket.message)
}
inline void MessagePacket::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MessagePacket.message)
}
inline void MessagePacket::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MessagePacket.message)
}
inline std::string* MessagePacket::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MessagePacket::release_message() {
  // @@protoc_insertion_point(field_release:MessagePacket.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MessagePacket::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MessagePacket.message)
}
inline std::string* MessagePacket::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MessagePacket.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void MessagePacket::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessagePacket.message)
}

// -------------------------------------------------------------------

// ErrorPacket

// string user_identifier = 1[json_name = "userIdentifier", (.buf.validate.field) = {
inline void ErrorPacket::clear_user_identifier() {
  user_identifier_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ErrorPacket::user_identifier() const {
  // @@protoc_insertion_point(field_get:ErrorPacket.user_identifier)
  return _internal_user_identifier();
}
inline void ErrorPacket::set_user_identifier(const std::string& value) {
  _internal_set_user_identifier(value);
  // @@protoc_insertion_point(field_set:ErrorPacket.user_identifier)
}
inline std::string* ErrorPacket::mutable_user_identifier() {
  // @@protoc_insertion_point(field_mutable:ErrorPacket.user_identifier)
  return _internal_mutable_user_identifier();
}
inline const std::string& ErrorPacket::_internal_user_identifier() const {
  return user_identifier_.Get();
}
inline void ErrorPacket::_internal_set_user_identifier(const std::string& value) {
  
  user_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ErrorPacket::set_user_identifier(std::string&& value) {
  
  user_identifier_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ErrorPacket.user_identifier)
}
inline void ErrorPacket::set_user_identifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ErrorPacket.user_identifier)
}
inline void ErrorPacket::set_user_identifier(const char* value,
    size_t size) {
  
  user_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ErrorPacket.user_identifier)
}
inline std::string* ErrorPacket::_internal_mutable_user_identifier() {
  
  return user_identifier_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ErrorPacket::release_user_identifier() {
  // @@protoc_insertion_point(field_release:ErrorPacket.user_identifier)
  return user_identifier_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ErrorPacket::set_allocated_user_identifier(std::string* user_identifier) {
  if (user_identifier != nullptr) {
    
  } else {
    
  }
  user_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_identifier,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ErrorPacket.user_identifier)
}
inline std::string* ErrorPacket::unsafe_arena_release_user_identifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ErrorPacket.user_identifier)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return user_identifier_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ErrorPacket::unsafe_arena_set_allocated_user_identifier(
    std::string* user_identifier) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (user_identifier != nullptr) {
    
  } else {
    
  }
  user_identifier_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      user_identifier, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ErrorPacket.user_identifier)
}

// string error = 3[json_name = "error", (.buf.validate.field) = {
inline void ErrorPacket::clear_error() {
  error_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ErrorPacket::error() const {
  // @@protoc_insertion_point(field_get:ErrorPacket.error)
  return _internal_error();
}
inline void ErrorPacket::set_error(const std::string& value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:ErrorPacket.error)
}
inline std::string* ErrorPacket::mutable_error() {
  // @@protoc_insertion_point(field_mutable:ErrorPacket.error)
  return _internal_mutable_error();
}
inline const std::string& ErrorPacket::_internal_error() const {
  return error_.Get();
}
inline void ErrorPacket::_internal_set_error(const std::string& value) {
  
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ErrorPacket::set_error(std::string&& value) {
  
  error_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ErrorPacket.error)
}
inline void ErrorPacket::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ErrorPacket.error)
}
inline void ErrorPacket::set_error(const char* value,
    size_t size) {
  
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ErrorPacket.error)
}
inline std::string* ErrorPacket::_internal_mutable_error() {
  
  return error_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ErrorPacket::release_error() {
  // @@protoc_insertion_point(field_release:ErrorPacket.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ErrorPacket::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ErrorPacket.error)
}
inline std::string* ErrorPacket::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ErrorPacket.error)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return error_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ErrorPacket::unsafe_arena_set_allocated_error(
    std::string* error) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (error != nullptr) {
    
  } else {
    
  }
  error_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      error, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ErrorPacket.error)
}

// -------------------------------------------------------------------

// UniversalPacket

// .VersionPacket version = 1[json_name = "version"];
inline bool UniversalPacket::_internal_has_version() const {
  return payload_case() == kVersion;
}
inline bool UniversalPacket::has_version() const {
  return _internal_has_version();
}
inline void UniversalPacket::set_has_version() {
  _oneof_case_[0] = kVersion;
}
inline void UniversalPacket::clear_version() {
  if (_internal_has_version()) {
    if (GetArena() == nullptr) {
      delete payload_.version_;
    }
    clear_has_payload();
  }
}
inline ::VersionPacket* UniversalPacket::release_version() {
  // @@protoc_insertion_point(field_release:UniversalPacket.version)
  if (_internal_has_version()) {
    clear_has_payload();
      ::VersionPacket* temp = payload_.version_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.version_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::VersionPacket& UniversalPacket::_internal_version() const {
  return _internal_has_version()
      ? *payload_.version_
      : *reinterpret_cast< ::VersionPacket*>(&::_VersionPacket_default_instance_);
}
inline const ::VersionPacket& UniversalPacket::version() const {
  // @@protoc_insertion_point(field_get:UniversalPacket.version)
  return _internal_version();
}
inline ::VersionPacket* UniversalPacket::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UniversalPacket.version)
  if (_internal_has_version()) {
    clear_has_payload();
    ::VersionPacket* temp = payload_.version_;
    payload_.version_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UniversalPacket::unsafe_arena_set_allocated_version(::VersionPacket* version) {
  clear_payload();
  if (version) {
    set_has_version();
    payload_.version_ = version;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UniversalPacket.version)
}
inline ::VersionPacket* UniversalPacket::_internal_mutable_version() {
  if (!_internal_has_version()) {
    clear_payload();
    set_has_version();
    payload_.version_ = CreateMaybeMessage< ::VersionPacket >(GetArena());
  }
  return payload_.version_;
}
inline ::VersionPacket* UniversalPacket::mutable_version() {
  // @@protoc_insertion_point(field_mutable:UniversalPacket.version)
  return _internal_mutable_version();
}

// .ErrorPacket error = 2[json_name = "error"];
inline bool UniversalPacket::_internal_has_error() const {
  return payload_case() == kError;
}
inline bool UniversalPacket::has_error() const {
  return _internal_has_error();
}
inline void UniversalPacket::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void UniversalPacket::clear_error() {
  if (_internal_has_error()) {
    if (GetArena() == nullptr) {
      delete payload_.error_;
    }
    clear_has_payload();
  }
}
inline ::ErrorPacket* UniversalPacket::release_error() {
  // @@protoc_insertion_point(field_release:UniversalPacket.error)
  if (_internal_has_error()) {
    clear_has_payload();
      ::ErrorPacket* temp = payload_.error_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ErrorPacket& UniversalPacket::_internal_error() const {
  return _internal_has_error()
      ? *payload_.error_
      : *reinterpret_cast< ::ErrorPacket*>(&::_ErrorPacket_default_instance_);
}
inline const ::ErrorPacket& UniversalPacket::error() const {
  // @@protoc_insertion_point(field_get:UniversalPacket.error)
  return _internal_error();
}
inline ::ErrorPacket* UniversalPacket::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UniversalPacket.error)
  if (_internal_has_error()) {
    clear_has_payload();
    ::ErrorPacket* temp = payload_.error_;
    payload_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UniversalPacket::unsafe_arena_set_allocated_error(::ErrorPacket* error) {
  clear_payload();
  if (error) {
    set_has_error();
    payload_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UniversalPacket.error)
}
inline ::ErrorPacket* UniversalPacket::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_payload();
    set_has_error();
    payload_.error_ = CreateMaybeMessage< ::ErrorPacket >(GetArena());
  }
  return payload_.error_;
}
inline ::ErrorPacket* UniversalPacket::mutable_error() {
  // @@protoc_insertion_point(field_mutable:UniversalPacket.error)
  return _internal_mutable_error();
}

// .LoginPacket login = 3[json_name = "login"];
inline bool UniversalPacket::_internal_has_login() const {
  return payload_case() == kLogin;
}
inline bool UniversalPacket::has_login() const {
  return _internal_has_login();
}
inline void UniversalPacket::set_has_login() {
  _oneof_case_[0] = kLogin;
}
inline void UniversalPacket::clear_login() {
  if (_internal_has_login()) {
    if (GetArena() == nullptr) {
      delete payload_.login_;
    }
    clear_has_payload();
  }
}
inline ::LoginPacket* UniversalPacket::release_login() {
  // @@protoc_insertion_point(field_release:UniversalPacket.login)
  if (_internal_has_login()) {
    clear_has_payload();
      ::LoginPacket* temp = payload_.login_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.login_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LoginPacket& UniversalPacket::_internal_login() const {
  return _internal_has_login()
      ? *payload_.login_
      : *reinterpret_cast< ::LoginPacket*>(&::_LoginPacket_default_instance_);
}
inline const ::LoginPacket& UniversalPacket::login() const {
  // @@protoc_insertion_point(field_get:UniversalPacket.login)
  return _internal_login();
}
inline ::LoginPacket* UniversalPacket::unsafe_arena_release_login() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UniversalPacket.login)
  if (_internal_has_login()) {
    clear_has_payload();
    ::LoginPacket* temp = payload_.login_;
    payload_.login_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UniversalPacket::unsafe_arena_set_allocated_login(::LoginPacket* login) {
  clear_payload();
  if (login) {
    set_has_login();
    payload_.login_ = login;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UniversalPacket.login)
}
inline ::LoginPacket* UniversalPacket::_internal_mutable_login() {
  if (!_internal_has_login()) {
    clear_payload();
    set_has_login();
    payload_.login_ = CreateMaybeMessage< ::LoginPacket >(GetArena());
  }
  return payload_.login_;
}
inline ::LoginPacket* UniversalPacket::mutable_login() {
  // @@protoc_insertion_point(field_mutable:UniversalPacket.login)
  return _internal_mutable_login();
}

// .MessagePacket message = 4[json_name = "message"];
inline bool UniversalPacket::_internal_has_message() const {
  return payload_case() == kMessage;
}
inline bool UniversalPacket::has_message() const {
  return _internal_has_message();
}
inline void UniversalPacket::set_has_message() {
  _oneof_case_[0] = kMessage;
}
inline void UniversalPacket::clear_message() {
  if (_internal_has_message()) {
    if (GetArena() == nullptr) {
      delete payload_.message_;
    }
    clear_has_payload();
  }
}
inline ::MessagePacket* UniversalPacket::release_message() {
  // @@protoc_insertion_point(field_release:UniversalPacket.message)
  if (_internal_has_message()) {
    clear_has_payload();
      ::MessagePacket* temp = payload_.message_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MessagePacket& UniversalPacket::_internal_message() const {
  return _internal_has_message()
      ? *payload_.message_
      : *reinterpret_cast< ::MessagePacket*>(&::_MessagePacket_default_instance_);
}
inline const ::MessagePacket& UniversalPacket::message() const {
  // @@protoc_insertion_point(field_get:UniversalPacket.message)
  return _internal_message();
}
inline ::MessagePacket* UniversalPacket::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UniversalPacket.message)
  if (_internal_has_message()) {
    clear_has_payload();
    ::MessagePacket* temp = payload_.message_;
    payload_.message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UniversalPacket::unsafe_arena_set_allocated_message(::MessagePacket* message) {
  clear_payload();
  if (message) {
    set_has_message();
    payload_.message_ = message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UniversalPacket.message)
}
inline ::MessagePacket* UniversalPacket::_internal_mutable_message() {
  if (!_internal_has_message()) {
    clear_payload();
    set_has_message();
    payload_.message_ = CreateMaybeMessage< ::MessagePacket >(GetArena());
  }
  return payload_.message_;
}
inline ::MessagePacket* UniversalPacket::mutable_message() {
  // @@protoc_insertion_point(field_mutable:UniversalPacket.message)
  return _internal_mutable_message();
}

inline bool UniversalPacket::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void UniversalPacket::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline UniversalPacket::PayloadCase UniversalPacket::payload_case() const {
  return UniversalPacket::PayloadCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_packets_2eproto
